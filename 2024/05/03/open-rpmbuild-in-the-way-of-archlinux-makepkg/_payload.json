[{"data":1,"prerenderedAt":415},["ShallowReactive",2],{"post-2024-05-03-open-rpmbuild-in-the-way-of-archlinux-makepkg":3,"surround-2024-05-03-open-rpmbuild-in-the-way-of-archlinux-makepkg":403,"randomIndex/2024/05/03/open-rpmbuild-in-the-way-of-archlinux-makepkg/":414},{"id":4,"title":5,"body":6,"date":388,"description":12,"extension":389,"meta":390,"navigation":391,"path":392,"rawbody":393,"seo":394,"stem":395,"sticky":396,"tags":397,"__hash__":402},"posts/posts/open-rpmbuild-in-the-way-of-archlinux-makepkg.md","以 Archlinux 中 makepkg 的方式打开 rpmbuild",{"type":7,"value":8,"toc":381},"minimark",[9,13,21,102,119,127,167,174,178,181,184,198,201,216,224,227,230,233,241,244,247,250,276,283,303,310,316,323,326,333,351,354,357,364,371,374,377],[10,11,12],"p",{},"在 Redhat 系的发行版上打包软件的时候，会发现与 Archlinux 完全不同的思路。",[10,14,15,16,20],{},"Fedora 所代表的 Redhat 阵营一看就是那种宏大叙事的大型发行版，rpmbuild 在默认情况下会在 $HOME/rpmbuild 下的一系列文件夹进行构建过程。使用 ",[17,18,19],"code",{},"rpmdev-setuptree"," 命令会创建好下面这些目录进行构建。",[22,23,28],"pre",{"className":24,"code":25,"language":26,"meta":27,"style":27},"language-bash shiki shiki-themes one-light one-dark-pro","$ tree rpmbuild\nrpmbuild\n├── BUILD\n├── BUILDROOT\n├── RPMS\n├── SOURCES\n├── SPECS\n└── SRPMS\n","bash","",[17,29,30,46,52,61,69,77,85,93],{"__ignoreMap":27},[31,32,35,39,43],"span",{"class":33,"line":34},"line",1,[31,36,38],{"class":37},"sAdtL","$",[31,40,42],{"class":41},"sDhpE"," tree",[31,44,45],{"class":41}," rpmbuild\n",[31,47,49],{"class":33,"line":48},2,[31,50,51],{"class":37},"rpmbuild\n",[31,53,55,58],{"class":33,"line":54},3,[31,56,57],{"class":37},"├──",[31,59,60],{"class":41}," BUILD\n",[31,62,64,66],{"class":33,"line":63},4,[31,65,57],{"class":37},[31,67,68],{"class":41}," BUILDROOT\n",[31,70,72,74],{"class":33,"line":71},5,[31,73,57],{"class":37},[31,75,76],{"class":41}," RPMS\n",[31,78,80,82],{"class":33,"line":79},6,[31,81,57],{"class":37},[31,83,84],{"class":41}," SOURCES\n",[31,86,88,90],{"class":33,"line":87},7,[31,89,57],{"class":37},[31,91,92],{"class":41}," SPECS\n",[31,94,96,99],{"class":33,"line":95},8,[31,97,98],{"class":37},"└──",[31,100,101],{"class":41}," SRPMS\n",[10,103,104,105,112,113,118],{},"Fedora 将所有的软件的构建都集中在一个 rpmbuild 目录中，BUILD 是编译时使用的，BUILDROOT 是最终安装目录，RPMS 是存放最终产物的，SOURCES 是存放源码等文件的，SPECS 是存放指导构建过程的 spec 文件的，而 SRPMS 是 RH 系为了 reproducibility 而单独将 spec 和源文件打包的产物。除了 rpmbuild 命令以外，Fedora 还有一套使用容器构建 rpm 包的 ",[106,107,111],"a",{"href":108,"rel":109},"https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds",[110],"nofollow","mock"," 构建系统，与 Archlinux 的 ",[106,114,117],{"href":115,"rel":116},"https://archlinux.org/packages/extra/any/devtools/",[110],"devtools"," 类似，这里不作过多叙述。",[10,120,121,122,126],{},"反观 Arch 的构建目录，",[123,124,125],"del",{},"就有一股浓浓的小作坊气味","。每个软件包自己拥有一个目录，指导构建过程的 PKGBUILD 文件、源文件和最终的产物都放在这个目录下，目录下的 src 和 pkg 文件夹分别对应 rpm 的 BUILD 和 BUILDROOT，前者是源文件被解压的目录和编译过程进行的目录，后者是软件最终的安装目录。",[22,128,130],{"className":24,"code":129,"language":26,"meta":27,"style":27},"$ tree repo\nrepo\n├── src\n├── pkg\n└── PKGBUILD\n",[17,131,132,141,146,153,160],{"__ignoreMap":27},[31,133,134,136,138],{"class":33,"line":34},[31,135,38],{"class":37},[31,137,42],{"class":41},[31,139,140],{"class":41}," repo\n",[31,142,143],{"class":33,"line":48},[31,144,145],{"class":37},"repo\n",[31,147,148,150],{"class":33,"line":54},[31,149,57],{"class":37},[31,151,152],{"class":41}," src\n",[31,154,155,157],{"class":33,"line":63},[31,156,57],{"class":37},[31,158,159],{"class":41}," pkg\n",[31,161,162,164],{"class":33,"line":71},[31,163,98],{"class":37},[31,165,166],{"class":41}," PKGBUILD\n",[10,168,169,170,173],{},"好巧不巧，我偏偏习惯这个小作坊气息的 arch build system，每个软件包独享一个自己的目录，",[123,171,172],{},"干净又卫生","。我自然也希望在 Fedora 下打 rpm 包的时候能够使用类似 Archlinux 下 makepkg 使用的目录结构。",[175,176,177],"h2",{"id":177},"简单了解",[10,179,180],{},"在了解一系列 rpmbuild 中宏（macros）相关的知识后，我意识到这并非不可能。",[10,182,183],{},"使用如下的命令可以获取目前系统中定义的所有宏",[22,185,187],{"className":24,"code":186,"language":26,"meta":27,"style":27},"rpm --showrc\n",[17,188,189],{"__ignoreMap":27},[31,190,191,194],{"class":33,"line":34},[31,192,193],{"class":37},"rpm",[31,195,197],{"class":196},"sAGMh"," --showrc\n",[10,199,200],{},"而可以使用如下命令检查某一个宏目前被定义成了什么值",[22,202,204],{"className":24,"code":203,"language":26,"meta":27,"style":27},"rpm --eval \"%{_topdir}\"\n",[17,205,206],{"__ignoreMap":27},[31,207,208,210,213],{"class":33,"line":34},[31,209,193],{"class":37},[31,211,212],{"class":196}," --eval",[31,214,215],{"class":41}," \"%{_topdir}\"\n",[10,217,218,219,223],{},"更多关于宏的描述可以在 ",[106,220,221],{"href":221,"rel":222},"https://rpm-software-management.github.io/rpm/manual/macros.html",[110]," 获取",[175,225,226],{"id":226},"修改路径",[10,228,229],{},"我们可以把定义成 $HOME/rpmbuild 的 %_topdir 重新定义成当前目录。",[10,231,232],{},"在 $HOME/.rpmmacros 中，去除顶部对 %_topdir 的定义，重新填上以下这些定义，即可初步完成我想要的效果。",[22,234,239],{"className":235,"code":237,"language":238},[236],"language-text","%_topdir    %(pwd)\n%_builddir %{_topdir}/src\n%_buildrootdir %{_topdir}/pkg\n%_rpmdir %{_topdir}\n%_sourcedir %{_topdir}\n%_specdir %{_topdir}\n%_srcrpmdir %{_topdir}\n","text",[17,240,237],{"__ignoreMap":27},[10,242,243],{},"现在在任何一个目录下执行 rpmbuild 相关命令，都会把 src 认为是构建目录，pkg 是最后安装目录，spec 文件和源文件早当前文件夹下，构建产物在当前文件夹下的 x86_64（或者别的架构名，这一层目录我还没有找到应该如何去掉）下。",[175,245,246],{"id":246},"自动安装依赖文件",[10,248,249],{},"Fedora 中的 rpmbuild 不带有 makepkg -s 的功能，不能自动安装依赖。不过这也不意味着需要自己傻傻地去翻 spec 看看需要哪些构建依赖。可以使用 dnf 的 builddep 命令实现",[22,251,253],{"className":24,"code":252,"language":26,"meta":27,"style":27},"sudo dnf builddep ./*.spec\n",[17,254,255],{"__ignoreMap":27},[31,256,257,260,263,266,269,273],{"class":33,"line":34},[31,258,259],{"class":37},"sudo",[31,261,262],{"class":41}," dnf",[31,264,265],{"class":41}," builddep",[31,267,268],{"class":41}," ./",[31,270,272],{"class":271},"s2QsP","*",[31,274,275],{"class":41},".spec\n",[10,277,278,279,282],{},"不过 dnf 没有什么完成构建后自动卸载依赖的选项。",[123,280,281],{},"这些依赖装完以后就一辈子赖在你的电脑上了","，才不是，可以在构建完成后使用 dnf 自带的后悔药功能撤销上一条命令执行的效果。",[22,284,286],{"className":24,"code":285,"language":26,"meta":27,"style":27},"sudo dnf history undo 0\n",[17,287,288],{"__ignoreMap":27},[31,289,290,292,294,297,300],{"class":33,"line":34},[31,291,259],{"class":37},[31,293,262],{"class":41},[31,295,296],{"class":41}," history",[31,298,299],{"class":41}," undo",[31,301,302],{"class":196}," 0\n",[10,304,305,306,309],{},"不过如果在 builddep 过程中，dnf 从 updates 源里更新了一些软件，那么它在 undo 时可能就没法获取更新前的软件版本。会有 ",[17,307,308],{},"Cannot find rpm nevra","  的提示",[10,311,312],{},[313,314],"img",{"alt":27,"src":315},"https://static.031130.xyz/uploads/2024/08/12/6635018238ffa.webp",[10,317,318,319,322],{},"可以使用 ",[17,320,321],{},"--skip-broken"," 命令跳过那些没法找到老版本的软件，继续卸载其余的软件。",[175,324,325],{"id":325},"自动下载源文件",[10,327,328,329,332],{},"很多使用 spec 中会在 source 里写上下载地址，而不是附上源码文件。rpm 似乎因为一些原因禁止了 rpmbuild 自动下载源文件的功能。可以通过在使用 rpmbuild 的时候带上 ",[17,330,331],{},"--undefine=_disable_source_fetch"," 取消定义这个行为，或者干脆在调用 rpmbuild 之前执行一遍",[22,334,336],{"className":24,"code":335,"language":26,"meta":27,"style":27},"spectool -gR *.spec\n",[17,337,338],{"__ignoreMap":27},[31,339,340,343,346,349],{"class":33,"line":34},[31,341,342],{"class":37},"spectool",[31,344,345],{"class":196}," -gR",[31,347,348],{"class":271}," *",[31,350,275],{"class":41},[10,352,353],{},"这样也能自动下载源文件。",[175,355,356],{"id":356},"构建行为",[10,358,359,360,363],{},"makepkg 的默认构建行为就是只构建最终的安装包，Archlinux 中并没有 Fedora 那样打 source rpm 保证 reproduceability 的行为，这在 rpmbuild 中对应的是 ",[17,361,362],{},"-bb"," 选项。",[10,365,366,367,370],{},"使用 ",[17,368,369],{},"rpmbuild -bb *.spec"," 即可",[372,373],"hr",{},[10,375,376],{},"上面介绍完了 rpmbuild 和 makepkg 的主要差异，应该可以自己搓一个 rpmbuild-wrapper 去实现以 makepkg 的方式打开 rpmbuild 的目标了，具体的 wrapper 脚本我就不放出来献丑了。",[378,379,380],"style",{},"html pre.shiki code .sAdtL, html code.shiki .sAdtL{--shiki-default:#4078F2;--shiki-dark:#61AFEF}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}html pre.shiki code .s2QsP, html code.shiki .s2QsP{--shiki-default:#E45649;--shiki-dark:#E5C07B}",{"title":27,"searchDepth":48,"depth":48,"links":382},[383,384,385,386,387],{"id":177,"depth":48,"text":177},{"id":226,"depth":48,"text":226},{"id":246,"depth":48,"text":246},{"id":325,"depth":48,"text":325},{"id":356,"depth":48,"text":356},"2024-05-03 22:48:39","md",{},true,"/2024/05/03/open-rpmbuild-in-the-way-of-archlinux-makepkg","---\ntitle: 以 Archlinux 中 makepkg 的方式打开 rpmbuild\ndate: 2024-05-03 22:48:39\nsticky:\ntags:\n- Archlinux\n- Fedora\n- RPM Package\n- Linux\n---\n\n在 Redhat 系的发行版上打包软件的时候，会发现与 Archlinux 完全不同的思路。\n\nFedora 所代表的 Redhat 阵营一看就是那种宏大叙事的大型发行版，rpmbuild 在默认情况下会在 $HOME/rpmbuild 下的一系列文件夹进行构建过程。使用 `rpmdev-setuptree` 命令会创建好下面这些目录进行构建。\n\n```bash\n$ tree rpmbuild\nrpmbuild\n├── BUILD\n├── BUILDROOT\n├── RPMS\n├── SOURCES\n├── SPECS\n└── SRPMS\n```\n\nFedora 将所有的软件的构建都集中在一个 rpmbuild 目录中，BUILD 是编译时使用的，BUILDROOT 是最终安装目录，RPMS 是存放最终产物的，SOURCES 是存放源码等文件的，SPECS 是存放指导构建过程的 spec 文件的，而 SRPMS 是 RH 系为了 reproducibility 而单独将 spec 和源文件打包的产物。除了 rpmbuild 命令以外，Fedora 还有一套使用容器构建 rpm 包的 [mock](https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds) 构建系统，与 Archlinux 的 [devtools](https://archlinux.org/packages/extra/any/devtools/) 类似，这里不作过多叙述。\n\n反观 Arch 的构建目录，~~就有一股浓浓的小作坊气味~~。每个软件包自己拥有一个目录，指导构建过程的 PKGBUILD 文件、源文件和最终的产物都放在这个目录下，目录下的 src 和 pkg 文件夹分别对应 rpm 的 BUILD 和 BUILDROOT，前者是源文件被解压的目录和编译过程进行的目录，后者是软件最终的安装目录。\n\n```bash\n$ tree repo\nrepo\n├── src\n├── pkg\n└── PKGBUILD\n```\n\n好巧不巧，我偏偏习惯这个小作坊气息的 arch build system，每个软件包独享一个自己的目录，~~干净又卫生~~。我自然也希望在 Fedora 下打 rpm 包的时候能够使用类似 Archlinux 下 makepkg 使用的目录结构。\n\n## 简单了解\n\n在了解一系列 rpmbuild 中宏（macros）相关的知识后，我意识到这并非不可能。\n\n使用如下的命令可以获取目前系统中定义的所有宏\n\n```bash\nrpm --showrc\n```\n\n而可以使用如下命令检查某一个宏目前被定义成了什么值\n\n```bash\nrpm --eval \"%{_topdir}\"\n```\n\n更多关于宏的描述可以在 https://rpm-software-management.github.io/rpm/manual/macros.html 获取\n\n## 修改路径\n\n我们可以把定义成 $HOME/rpmbuild 的 %_topdir 重新定义成当前目录。\n\n在 $HOME/.rpmmacros 中，去除顶部对 %_topdir 的定义，重新填上以下这些定义，即可初步完成我想要的效果。\n\n```\n%_topdir    %(pwd)\n%_builddir %{_topdir}/src\n%_buildrootdir %{_topdir}/pkg\n%_rpmdir %{_topdir}\n%_sourcedir %{_topdir}\n%_specdir %{_topdir}\n%_srcrpmdir %{_topdir}\n```\n\n现在在任何一个目录下执行 rpmbuild 相关命令，都会把 src 认为是构建目录，pkg 是最后安装目录，spec 文件和源文件早当前文件夹下，构建产物在当前文件夹下的 x86_64（或者别的架构名，这一层目录我还没有找到应该如何去掉）下。\n\n## 自动安装依赖文件\n\nFedora 中的 rpmbuild 不带有 makepkg -s 的功能，不能自动安装依赖。不过这也不意味着需要自己傻傻地去翻 spec 看看需要哪些构建依赖。可以使用 dnf 的 builddep 命令实现\n\n```bash\nsudo dnf builddep ./*.spec\n```\n\n不过 dnf 没有什么完成构建后自动卸载依赖的选项。~~这些依赖装完以后就一辈子赖在你的电脑上了~~，才不是，可以在构建完成后使用 dnf 自带的后悔药功能撤销上一条命令执行的效果。\n\n```bash\nsudo dnf history undo 0\n```\n\n不过如果在 builddep 过程中，dnf 从 updates 源里更新了一些软件，那么它在 undo 时可能就没法获取更新前的软件版本。会有 `Cannot find rpm nevra`  的提示\n\n![](https://static.031130.xyz/uploads/2024/08/12/6635018238ffa.webp)\n\n可以使用 `--skip-broken` 命令跳过那些没法找到老版本的软件，继续卸载其余的软件。\n\n## 自动下载源文件\n\n很多使用 spec 中会在 source 里写上下载地址，而不是附上源码文件。rpm 似乎因为一些原因禁止了 rpmbuild 自动下载源文件的功能。可以通过在使用 rpmbuild 的时候带上 `--undefine=_disable_source_fetch` 取消定义这个行为，或者干脆在调用 rpmbuild 之前执行一遍\n\n```bash\nspectool -gR *.spec\n```\n\n这样也能自动下载源文件。\n\n## 构建行为\n\nmakepkg 的默认构建行为就是只构建最终的安装包，Archlinux 中并没有 Fedora 那样打 source rpm 保证 reproduceability 的行为，这在 rpmbuild 中对应的是 `-bb` 选项。\n\n使用 `rpmbuild -bb *.spec` 即可\n\n***\n\n上面介绍完了 rpmbuild 和 makepkg 的主要差异，应该可以自己搓一个 rpmbuild-wrapper 去实现以 makepkg 的方式打开 rpmbuild 的目标了，具体的 wrapper 脚本我就不放出来献丑了。\n",{"title":5,"description":12},"posts/open-rpmbuild-in-the-way-of-archlinux-makepkg",false,[398,399,400,401],"Archlinux","Fedora","RPM Package","Linux","_lVS4czB-jufzLsSP6WFO439g4suCao26bscc9bWD1Y",[404,409],{"title":405,"path":406,"stem":407,"date":408,"children":-1},"使用 Windows 虚拟机运行虚拟专用网客户端为 Linux 提供内网环境","/2024/05/23/setup-network-environment-for-non-linux-vpn-client-with-virtual-machine","posts/setup-network-environment-for-non-linux-vpn-client-with-virtual-machine","2024-05-23 01:07:44",{"title":410,"path":411,"stem":412,"date":413,"children":-1},"使用 Github Action 更新用于 rpm 打包的 spec 文件","/2024/04/29/update-a-rpm-spec-by-github-action","posts/update-a-rpm-spec-by-github-action","2024-04-29 19:19:54",15,1761738550622]