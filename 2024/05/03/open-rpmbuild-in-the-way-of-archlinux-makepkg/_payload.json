[{"data":1,"prerenderedAt":407},["ShallowReactive",2],{"post-2024-05-03-open-rpmbuild-in-the-way-of-archlinux-makepkg-zh":3,"surround-2024-05-03-open-rpmbuild-in-the-way-of-archlinux-makepkg-zh":394,"randomIndex/2024/05/03/open-rpmbuild-in-the-way-of-archlinux-makepkg/":77,"language-switch-/2024/05/03/open-rpmbuild-in-the-way-of-archlinux-makepkg/-en":406},{"title":4,"date":5,"path":6,"tags":7,"body":12,"description":18},"以 Archlinux 中 makepkg 的方式打开 rpmbuild","2024-05-03 22:48:39","/2024/05/03/open-rpmbuild-in-the-way-of-archlinux-makepkg",[8,9,10,11],"Archlinux","Fedora","RPM Package","Linux",{"type":13,"value":14,"toc":387},"minimark",[15,19,27,108,125,133,173,180,184,187,190,204,207,222,230,233,236,239,247,250,253,256,282,289,309,316,322,329,332,339,357,360,363,370,377,380,383],[16,17,18],"p",{},"在 Redhat 系的发行版上打包软件的时候，会发现与 Archlinux 完全不同的思路。",[16,20,21,22,26],{},"Fedora 所代表的 Redhat 阵营一看就是那种宏大叙事的大型发行版，rpmbuild 在默认情况下会在 $HOME/rpmbuild 下的一系列文件夹进行构建过程。使用 ",[23,24,25],"code",{},"rpmdev-setuptree"," 命令会创建好下面这些目录进行构建。",[28,29,34],"pre",{"className":30,"code":31,"language":32,"meta":33,"style":33},"language-bash shiki shiki-themes one-light one-dark-pro","$ tree rpmbuild\nrpmbuild\n├── BUILD\n├── BUILDROOT\n├── RPMS\n├── SOURCES\n├── SPECS\n└── SRPMS\n","bash","",[23,35,36,52,58,67,75,83,91,99],{"__ignoreMap":33},[37,38,41,45,49],"span",{"class":39,"line":40},"line",1,[37,42,44],{"class":43},"sAdtL","$",[37,46,48],{"class":47},"sDhpE"," tree",[37,50,51],{"class":47}," rpmbuild\n",[37,53,55],{"class":39,"line":54},2,[37,56,57],{"class":43},"rpmbuild\n",[37,59,61,64],{"class":39,"line":60},3,[37,62,63],{"class":43},"├──",[37,65,66],{"class":47}," BUILD\n",[37,68,70,72],{"class":39,"line":69},4,[37,71,63],{"class":43},[37,73,74],{"class":47}," BUILDROOT\n",[37,76,78,80],{"class":39,"line":77},5,[37,79,63],{"class":43},[37,81,82],{"class":47}," RPMS\n",[37,84,86,88],{"class":39,"line":85},6,[37,87,63],{"class":43},[37,89,90],{"class":47}," SOURCES\n",[37,92,94,96],{"class":39,"line":93},7,[37,95,63],{"class":43},[37,97,98],{"class":47}," SPECS\n",[37,100,102,105],{"class":39,"line":101},8,[37,103,104],{"class":43},"└──",[37,106,107],{"class":47}," SRPMS\n",[16,109,110,111,118,119,124],{},"Fedora 将所有的软件的构建都集中在一个 rpmbuild 目录中，BUILD 是编译时使用的，BUILDROOT 是最终安装目录，RPMS 是存放最终产物的，SOURCES 是存放源码等文件的，SPECS 是存放指导构建过程的 spec 文件的，而 SRPMS 是 RH 系为了 reproducibility 而单独将 spec 和源文件打包的产物。除了 rpmbuild 命令以外，Fedora 还有一套使用容器构建 rpm 包的 ",[112,113,117],"a",{"href":114,"rel":115},"https://fedoraproject.org/wiki/Using_Mock_to_test_package_builds",[116],"nofollow","mock"," 构建系统，与 Archlinux 的 ",[112,120,123],{"href":121,"rel":122},"https://archlinux.org/packages/extra/any/devtools/",[116],"devtools"," 类似，这里不作过多叙述。",[16,126,127,128,132],{},"反观 Arch 的构建目录，",[129,130,131],"del",{},"就有一股浓浓的小作坊气味","。每个软件包自己拥有一个目录，指导构建过程的 PKGBUILD 文件、源文件和最终的产物都放在这个目录下，目录下的 src 和 pkg 文件夹分别对应 rpm 的 BUILD 和 BUILDROOT，前者是源文件被解压的目录和编译过程进行的目录，后者是软件最终的安装目录。",[28,134,136],{"className":30,"code":135,"language":32,"meta":33,"style":33},"$ tree repo\nrepo\n├── src\n├── pkg\n└── PKGBUILD\n",[23,137,138,147,152,159,166],{"__ignoreMap":33},[37,139,140,142,144],{"class":39,"line":40},[37,141,44],{"class":43},[37,143,48],{"class":47},[37,145,146],{"class":47}," repo\n",[37,148,149],{"class":39,"line":54},[37,150,151],{"class":43},"repo\n",[37,153,154,156],{"class":39,"line":60},[37,155,63],{"class":43},[37,157,158],{"class":47}," src\n",[37,160,161,163],{"class":39,"line":69},[37,162,63],{"class":43},[37,164,165],{"class":47}," pkg\n",[37,167,168,170],{"class":39,"line":77},[37,169,104],{"class":43},[37,171,172],{"class":47}," PKGBUILD\n",[16,174,175,176,179],{},"好巧不巧，我偏偏习惯这个小作坊气息的 arch build system，每个软件包独享一个自己的目录，",[129,177,178],{},"干净又卫生","。我自然也希望在 Fedora 下打 rpm 包的时候能够使用类似 Archlinux 下 makepkg 使用的目录结构。",[181,182,183],"h2",{"id":183},"简单了解",[16,185,186],{},"在了解一系列 rpmbuild 中宏（macros）相关的知识后，我意识到这并非不可能。",[16,188,189],{},"使用如下的命令可以获取目前系统中定义的所有宏",[28,191,193],{"className":30,"code":192,"language":32,"meta":33,"style":33},"rpm --showrc\n",[23,194,195],{"__ignoreMap":33},[37,196,197,200],{"class":39,"line":40},[37,198,199],{"class":43},"rpm",[37,201,203],{"class":202},"sAGMh"," --showrc\n",[16,205,206],{},"而可以使用如下命令检查某一个宏目前被定义成了什么值",[28,208,210],{"className":30,"code":209,"language":32,"meta":33,"style":33},"rpm --eval \"%{_topdir}\"\n",[23,211,212],{"__ignoreMap":33},[37,213,214,216,219],{"class":39,"line":40},[37,215,199],{"class":43},[37,217,218],{"class":202}," --eval",[37,220,221],{"class":47}," \"%{_topdir}\"\n",[16,223,224,225,229],{},"更多关于宏的描述可以在 ",[112,226,227],{"href":227,"rel":228},"https://rpm-software-management.github.io/rpm/manual/macros.html",[116]," 获取",[181,231,232],{"id":232},"修改路径",[16,234,235],{},"我们可以把定义成 $HOME/rpmbuild 的 %_topdir 重新定义成当前目录。",[16,237,238],{},"在 $HOME/.rpmmacros 中，去除顶部对 %_topdir 的定义，重新填上以下这些定义，即可初步完成我想要的效果。",[28,240,245],{"className":241,"code":243,"language":244},[242],"language-text","%_topdir    %(pwd)\n%_builddir %{_topdir}/src\n%_buildrootdir %{_topdir}/pkg\n%_rpmdir %{_topdir}\n%_sourcedir %{_topdir}\n%_specdir %{_topdir}\n%_srcrpmdir %{_topdir}\n","text",[23,246,243],{"__ignoreMap":33},[16,248,249],{},"现在在任何一个目录下执行 rpmbuild 相关命令，都会把 src 认为是构建目录，pkg 是最后安装目录，spec 文件和源文件早当前文件夹下，构建产物在当前文件夹下的 x86_64（或者别的架构名，这一层目录我还没有找到应该如何去掉）下。",[181,251,252],{"id":252},"自动安装依赖文件",[16,254,255],{},"Fedora 中的 rpmbuild 不带有 makepkg -s 的功能，不能自动安装依赖。不过这也不意味着需要自己傻傻地去翻 spec 看看需要哪些构建依赖。可以使用 dnf 的 builddep 命令实现",[28,257,259],{"className":30,"code":258,"language":32,"meta":33,"style":33},"sudo dnf builddep ./*.spec\n",[23,260,261],{"__ignoreMap":33},[37,262,263,266,269,272,275,279],{"class":39,"line":40},[37,264,265],{"class":43},"sudo",[37,267,268],{"class":47}," dnf",[37,270,271],{"class":47}," builddep",[37,273,274],{"class":47}," ./",[37,276,278],{"class":277},"s2QsP","*",[37,280,281],{"class":47},".spec\n",[16,283,284,285,288],{},"不过 dnf 没有什么完成构建后自动卸载依赖的选项。",[129,286,287],{},"这些依赖装完以后就一辈子赖在你的电脑上了","，才不是，可以在构建完成后使用 dnf 自带的后悔药功能撤销上一条命令执行的效果。",[28,290,292],{"className":30,"code":291,"language":32,"meta":33,"style":33},"sudo dnf history undo 0\n",[23,293,294],{"__ignoreMap":33},[37,295,296,298,300,303,306],{"class":39,"line":40},[37,297,265],{"class":43},[37,299,268],{"class":47},[37,301,302],{"class":47}," history",[37,304,305],{"class":47}," undo",[37,307,308],{"class":202}," 0\n",[16,310,311,312,315],{},"不过如果在 builddep 过程中，dnf 从 updates 源里更新了一些软件，那么它在 undo 时可能就没法获取更新前的软件版本。会有 ",[23,313,314],{},"Cannot find rpm nevra","  的提示",[16,317,318],{},[319,320],"img",{"alt":33,"src":321},"https://static.031130.xyz/uploads/2024/08/12/6635018238ffa.webp",[16,323,324,325,328],{},"可以使用 ",[23,326,327],{},"--skip-broken"," 命令跳过那些没法找到老版本的软件，继续卸载其余的软件。",[181,330,331],{"id":331},"自动下载源文件",[16,333,334,335,338],{},"很多使用 spec 中会在 source 里写上下载地址，而不是附上源码文件。rpm 似乎因为一些原因禁止了 rpmbuild 自动下载源文件的功能。可以通过在使用 rpmbuild 的时候带上 ",[23,336,337],{},"--undefine=_disable_source_fetch"," 取消定义这个行为，或者干脆在调用 rpmbuild 之前执行一遍",[28,340,342],{"className":30,"code":341,"language":32,"meta":33,"style":33},"spectool -gR *.spec\n",[23,343,344],{"__ignoreMap":33},[37,345,346,349,352,355],{"class":39,"line":40},[37,347,348],{"class":43},"spectool",[37,350,351],{"class":202}," -gR",[37,353,354],{"class":277}," *",[37,356,281],{"class":47},[16,358,359],{},"这样也能自动下载源文件。",[181,361,362],{"id":362},"构建行为",[16,364,365,366,369],{},"makepkg 的默认构建行为就是只构建最终的安装包，Archlinux 中并没有 Fedora 那样打 source rpm 保证 reproduceability 的行为，这在 rpmbuild 中对应的是 ",[23,367,368],{},"-bb"," 选项。",[16,371,372,373,376],{},"使用 ",[23,374,375],{},"rpmbuild -bb *.spec"," 即可",[378,379],"hr",{},[16,381,382],{},"上面介绍完了 rpmbuild 和 makepkg 的主要差异，应该可以自己搓一个 rpmbuild-wrapper 去实现以 makepkg 的方式打开 rpmbuild 的目标了，具体的 wrapper 脚本我就不放出来献丑了。",[384,385,386],"style",{},"html pre.shiki code .sAdtL, html code.shiki .sAdtL{--shiki-default:#4078F2;--shiki-dark:#61AFEF}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}html pre.shiki code .s2QsP, html code.shiki .s2QsP{--shiki-default:#E45649;--shiki-dark:#E5C07B}",{"title":33,"searchDepth":54,"depth":54,"links":388},[389,390,391,392,393],{"id":183,"depth":54,"text":183},{"id":232,"depth":54,"text":232},{"id":252,"depth":54,"text":252},{"id":331,"depth":54,"text":331},{"id":362,"depth":54,"text":362},[395,401],{"title":396,"path":397,"stem":398,"date":399,"lang":400,"children":-1},"使用 Windows 虚拟机运行虚拟专用网客户端为 Linux 提供内网环境","/2024/05/23/setup-network-environment-for-non-linux-vpn-client-with-virtual-machine","posts/zh/setup-network-environment-for-non-linux-vpn-client-with-virtual-machine","2024-05-23 01:07:44","zh-CN",{"title":402,"path":403,"stem":404,"date":405,"lang":400,"children":-1},"使用 Github Action 更新用于 rpm 打包的 spec 文件","/2024/04/29/update-a-rpm-spec-by-github-action","posts/zh/update-a-rpm-spec-by-github-action","2024-04-29 19:19:54",null,1765392890662]