[{"data":1,"prerenderedAt":864},["ShallowReactive",2],{"post-2024-08-13-build-restful-api-for-cloudflare-r2-with-cloudflare-workers":3,"surround-2024-08-13-build-restful-api-for-cloudflare-r2-with-cloudflare-workers":853,"randomIndex/2024/08/13/build-restful-api-for-cloudflare-r2-with-cloudflare-workers/":226},{"id":4,"title":5,"body":6,"date":839,"description":206,"extension":840,"meta":841,"navigation":235,"path":842,"rawbody":843,"seo":844,"stem":845,"sticky":846,"tags":847,"__hash__":852},"posts/posts/build-restful-api-for-cloudflare-r2-with-cloudflare-workers.md","自建图床小记二——使用 Workers 为 R2 构建 Restful API",{"type":7,"value":8,"toc":821},"minimark",[9,14,18,23,30,34,40,43,49,53,56,59,68,74,77,84,86,91,95,99,102,108,112,117,133,138,142,145,149,163,169,171,176,180,183,193,197,200,595,598,612,615,619,622,627,631,634,637,711,714,721,724,727,786,789,817],[10,11,13],"h2",{"id":12},"访问-r2-的两种方式","访问 R2 的两种方式",[15,16,17],"p",{},"一般来说，想要访问 Cloudflare R2 中的文件，会有两种方式。",[19,20,22],"h3",{"id":21},"一种是在-r2-的设置界面设置自定义域","一种是在 R2 的设置界面设置自定义域",[15,24,25],{},[26,27],"img",{"alt":28,"src":29},"设置自定义域","https://static.031130.xyz/uploads/2024/08/13/61fe9ede194af.webp",[19,31,33],{"id":32},"另一种是通过-cloudflare-workers-进行访问","另一种是通过 Cloudflare Workers 进行访问",[15,35,36],{},[26,37],{"alt":38,"src":39},"通过 Cloudflare Workers","https://static.031130.xyz/uploads/2024/08/13/846164273571d.webp",[41,42],"hr",{},[15,44,45],{},[46,47,48],"strong",{},"那么应该选择哪种？选择 Cloudflare Workers！",[10,50,52],{"id":51},"为什么是-cloudflare-workers","为什么是 Cloudflare Workers？",[15,54,55],{},"要回答这个问题比较困难，但可以回答另一个问题——「为什么不设置自定义域实现直接访问？」",[19,57,58],{"id":58},"自定义域的访问存在限制",[15,60,61,62,67],{},"设置自定义域的访问方式存在较多的限制，让我们先来复习一下",[63,64,66],"a",{"href":65},"/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/","上一篇博客中","提到的 DNS 解析方案 1",[15,69,70],{},[26,71],{"alt":72,"src":73},"DNS 解析方案 1","https://static.031130.xyz/uploads/2024/08/13/03d8243b67593.webp",[15,75,76],{},"在这里，我们需要将图床访问域名通过 NS 接入 DnsPod 实现境内外的分流，但 R2 所允许设置的自定义域必须是通过 NS 接入 Cloudflare 的，这存在冲突。那如果我们先将自定义域设置为通过 NS 接入 Cloudflare 的工具人域名，再将图床访问域名通过 CNAME 解析到工具人域名会不会有问题呢？恭喜你获得 403 Forbidden。",[15,78,79,80,83],{},"如果通过",[63,81,82],{"href":65},"上一篇文章","中的 DNS 解析方案 2 来进行 DNS 解析，能不能成功设置为 Cloudflare R2 的自定义域呢？也不行，Cloudflare R2 的自定义域会占用域名的解析，这意味着你无法将图床访问域名解析到用于分流的工具人域名。",[41,85],{},[15,87,88],{},[46,89,90],{},"结论：截至本文写作时间，设置自定义域的方案不适用于 DNS 分流的图床架构。",[19,92,94],{"id":93},"如何上传文件到-cloudflare-r2","如何上传文件到 Cloudflare R2？",[96,97,98],"h4",{"id":98},"网页端直接上传",[15,100,101],{},"最简单的上传方式是直接在 Cloudflare 进行网页上传，但这种方案不适合自动化脚本，也没法接入 Typora",[15,103,104],{},[26,105],{"alt":106,"src":107},"直接在网页端进行上传","https://static.031130.xyz/uploads/2024/08/13/b4d1b5b3edfae.webp",[96,109,111],{"id":110},"使用-amazon-s3-的兼容-api","使用 Amazon S3 的兼容 API",[113,114,116],"h5",{"id":115},"手动调用-s3-api","手动调用 S3 API",[15,118,119,120,126,127,132],{},"Cloudflare R2 被设计为兼容 Amazon S3 的存储方案，自然兼容 Amazon S3 的上传 API，在 ",[63,121,125],{"href":122,"rel":123},"https://developers.cloudflare.com/r2/api/s3/api/",[124],"nofollow","Cloudflare Docs 中有关于 S3 API 的实现情况","记载，大部分接口功能都是实现了的。但。。。但 S3 使用的是 ",[63,128,131],{"href":129,"rel":130},"https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html",[124],"AWS Signature"," 作为鉴权，你不会希望在每个自动化程序中都自己实现一次的。。。",[15,134,135],{},[26,136],{"alt":137,"src":137},"https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png",[113,139,141],{"id":140},"使用-aws-cli-等-sdk","使用 aws-cli 等 SDK",[15,143,144],{},"使用 aws-cli 可以自动实现计算 AWS Signature，这是一种可行的方案，但我可能会在别的服务中使用到我的图床，不是所有的服务所处的环境都能够执行 shell 命令，也不是所有的编程语言都有现成的 SDK 可用。",[96,146,148],{"id":147},"使用-cloudflare-workers-构建-restful-api","使用 Cloudflare Workers 构建 Restful API",[15,150,151,156,157,162],{},[63,152,155],{"href":153,"rel":154},"https://developers.cloudflare.com/r2/api/workers/workers-api-usage/#5-access-your-r2-bucket-from-your-worker",[124],"在 Cloudflare Docs 中明确提出可以使用 Cloudflare Workers 访问 Cloudflare R2 Bucket，","通过 Workers 设置界面的按钮，可以非常方便的将 R2 Bucket 作为一个 R2Object 绑定到 JavaScript 的一个变量中，",[63,158,161],{"href":159,"rel":160},"https://developers.cloudflare.com/r2/api/workers/workers-api-reference/",[124],"这里有相关的开发文档","。",[15,164,165],{},[26,166],{"alt":167,"src":168},"绑定为变量","https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp",[41,170],{},[15,172,173],{},[46,174,175],{},"结论: 从易用性上来看，使用 Cloudflare Workers 构建 Restful API 这种上传文件的方案是最为合适的。",[10,177,179],{"id":178},"使用-cloudflare-workers-构建-restful-api-的方案有没有什么缺点","使用 Cloudflare Workers 构建 Restful API 的方案有没有什么缺点？",[15,181,182],{},"有。",[184,185,186,190],"ul",{},[187,188,189],"li",{},"Cloudflare Workers 的每日额度是有限的，在极端的流量下可能会用完（应该不会吧？）",[187,191,192],{},"Cloudflare Workers 的内存限制为 128MB，在上传下载 > 100MB 的文件时可能会出错。有这种体积上传需求的场景建议使用别的上传方案。",[10,194,196],{"id":195},"如何构建","如何构建？",[15,198,199],{},"直接贴代码",[201,202,207],"pre",{"className":203,"code":204,"language":205,"meta":206,"style":206},"language-javascript shiki shiki-themes github-light github-dark","const hasValidHeader = (request, env) => {\n    return request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n};\n\nfunction authorizeRequest(request, env, key) {\n    switch (request.method) {\n        case 'PUT':\n        case 'DELETE':\n            return hasValidHeader(request, env);\n        case 'GET':\n            return true;\n        default:\n            return false;\n    }\n}\n\nexport default {\n    async fetch(request, env) {\n        const url = new URL(request.url);\n        const key = decodeURI(url.pathname.slice(1));\n\n        if (!authorizeRequest(request, env, key)) {\n            return new Response('Forbidden\\n', { status: 403 });\n        }\n\n        switch (request.method) {\n            case 'PUT':\n                const objectExists = await env.MY_BUCKET.get(key);\n\n                if (objectExists !== null) {\n                    if (request.headers.get('Overwrite') !== 'true') {\n                        return new Response('Object Already Exists\\n', { status: 409 });\n                    }\n                }\n\n                await env.MY_BUCKET.put(key, request.body);\n                return new Response(`Put ${key} successfully!\\n`);\n\n            case 'GET':\n                const object = await env.MY_BUCKET.get(key);\n\n                if (object === null) {\n                    return new Response('Object Not Found\\n', { status: 404 });\n                }\n\n                const headers = new Headers();\n                object.writeHttpMetadata(headers);\n                headers.set('etag', object.httpEtag);\n\n                return new Response(object.body, {\n                    headers,\n                });\n            case 'DELETE':\n                await env.MY_BUCKET.delete(key);\n                return new Response('Deleted!\\n');\n\n            default:\n                return new Response('Method Not Allowed\\n', {\n                    status: 405,\n                    headers: {\n                        Allow: 'PUT, GET, DELETE',\n                    },\n                });\n        }\n    },\n};\n","javascript","",[208,209,210,218,224,230,237,243,249,255,261,267,273,279,285,291,297,303,308,314,320,326,332,337,343,349,355,360,366,372,378,383,389,395,401,407,413,418,424,430,435,441,447,452,458,464,469,474,480,486,492,497,503,509,515,521,527,533,538,544,550,556,562,568,574,579,584,590],"code",{"__ignoreMap":206},[211,212,215],"span",{"class":213,"line":214},"line",1,[211,216,217],{},"const hasValidHeader = (request, env) => {\n",[211,219,221],{"class":213,"line":220},2,[211,222,223],{},"    return request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n",[211,225,227],{"class":213,"line":226},3,[211,228,229],{},"};\n",[211,231,233],{"class":213,"line":232},4,[211,234,236],{"emptyLinePlaceholder":235},true,"\n",[211,238,240],{"class":213,"line":239},5,[211,241,242],{},"function authorizeRequest(request, env, key) {\n",[211,244,246],{"class":213,"line":245},6,[211,247,248],{},"    switch (request.method) {\n",[211,250,252],{"class":213,"line":251},7,[211,253,254],{},"        case 'PUT':\n",[211,256,258],{"class":213,"line":257},8,[211,259,260],{},"        case 'DELETE':\n",[211,262,264],{"class":213,"line":263},9,[211,265,266],{},"            return hasValidHeader(request, env);\n",[211,268,270],{"class":213,"line":269},10,[211,271,272],{},"        case 'GET':\n",[211,274,276],{"class":213,"line":275},11,[211,277,278],{},"            return true;\n",[211,280,282],{"class":213,"line":281},12,[211,283,284],{},"        default:\n",[211,286,288],{"class":213,"line":287},13,[211,289,290],{},"            return false;\n",[211,292,294],{"class":213,"line":293},14,[211,295,296],{},"    }\n",[211,298,300],{"class":213,"line":299},15,[211,301,302],{},"}\n",[211,304,306],{"class":213,"line":305},16,[211,307,236],{"emptyLinePlaceholder":235},[211,309,311],{"class":213,"line":310},17,[211,312,313],{},"export default {\n",[211,315,317],{"class":213,"line":316},18,[211,318,319],{},"    async fetch(request, env) {\n",[211,321,323],{"class":213,"line":322},19,[211,324,325],{},"        const url = new URL(request.url);\n",[211,327,329],{"class":213,"line":328},20,[211,330,331],{},"        const key = decodeURI(url.pathname.slice(1));\n",[211,333,335],{"class":213,"line":334},21,[211,336,236],{"emptyLinePlaceholder":235},[211,338,340],{"class":213,"line":339},22,[211,341,342],{},"        if (!authorizeRequest(request, env, key)) {\n",[211,344,346],{"class":213,"line":345},23,[211,347,348],{},"            return new Response('Forbidden\\n', { status: 403 });\n",[211,350,352],{"class":213,"line":351},24,[211,353,354],{},"        }\n",[211,356,358],{"class":213,"line":357},25,[211,359,236],{"emptyLinePlaceholder":235},[211,361,363],{"class":213,"line":362},26,[211,364,365],{},"        switch (request.method) {\n",[211,367,369],{"class":213,"line":368},27,[211,370,371],{},"            case 'PUT':\n",[211,373,375],{"class":213,"line":374},28,[211,376,377],{},"                const objectExists = await env.MY_BUCKET.get(key);\n",[211,379,381],{"class":213,"line":380},29,[211,382,236],{"emptyLinePlaceholder":235},[211,384,386],{"class":213,"line":385},30,[211,387,388],{},"                if (objectExists !== null) {\n",[211,390,392],{"class":213,"line":391},31,[211,393,394],{},"                    if (request.headers.get('Overwrite') !== 'true') {\n",[211,396,398],{"class":213,"line":397},32,[211,399,400],{},"                        return new Response('Object Already Exists\\n', { status: 409 });\n",[211,402,404],{"class":213,"line":403},33,[211,405,406],{},"                    }\n",[211,408,410],{"class":213,"line":409},34,[211,411,412],{},"                }\n",[211,414,416],{"class":213,"line":415},35,[211,417,236],{"emptyLinePlaceholder":235},[211,419,421],{"class":213,"line":420},36,[211,422,423],{},"                await env.MY_BUCKET.put(key, request.body);\n",[211,425,427],{"class":213,"line":426},37,[211,428,429],{},"                return new Response(`Put ${key} successfully!\\n`);\n",[211,431,433],{"class":213,"line":432},38,[211,434,236],{"emptyLinePlaceholder":235},[211,436,438],{"class":213,"line":437},39,[211,439,440],{},"            case 'GET':\n",[211,442,444],{"class":213,"line":443},40,[211,445,446],{},"                const object = await env.MY_BUCKET.get(key);\n",[211,448,450],{"class":213,"line":449},41,[211,451,236],{"emptyLinePlaceholder":235},[211,453,455],{"class":213,"line":454},42,[211,456,457],{},"                if (object === null) {\n",[211,459,461],{"class":213,"line":460},43,[211,462,463],{},"                    return new Response('Object Not Found\\n', { status: 404 });\n",[211,465,467],{"class":213,"line":466},44,[211,468,412],{},[211,470,472],{"class":213,"line":471},45,[211,473,236],{"emptyLinePlaceholder":235},[211,475,477],{"class":213,"line":476},46,[211,478,479],{},"                const headers = new Headers();\n",[211,481,483],{"class":213,"line":482},47,[211,484,485],{},"                object.writeHttpMetadata(headers);\n",[211,487,489],{"class":213,"line":488},48,[211,490,491],{},"                headers.set('etag', object.httpEtag);\n",[211,493,495],{"class":213,"line":494},49,[211,496,236],{"emptyLinePlaceholder":235},[211,498,500],{"class":213,"line":499},50,[211,501,502],{},"                return new Response(object.body, {\n",[211,504,506],{"class":213,"line":505},51,[211,507,508],{},"                    headers,\n",[211,510,512],{"class":213,"line":511},52,[211,513,514],{},"                });\n",[211,516,518],{"class":213,"line":517},53,[211,519,520],{},"            case 'DELETE':\n",[211,522,524],{"class":213,"line":523},54,[211,525,526],{},"                await env.MY_BUCKET.delete(key);\n",[211,528,530],{"class":213,"line":529},55,[211,531,532],{},"                return new Response('Deleted!\\n');\n",[211,534,536],{"class":213,"line":535},56,[211,537,236],{"emptyLinePlaceholder":235},[211,539,541],{"class":213,"line":540},57,[211,542,543],{},"            default:\n",[211,545,547],{"class":213,"line":546},58,[211,548,549],{},"                return new Response('Method Not Allowed\\n', {\n",[211,551,553],{"class":213,"line":552},59,[211,554,555],{},"                    status: 405,\n",[211,557,559],{"class":213,"line":558},60,[211,560,561],{},"                    headers: {\n",[211,563,565],{"class":213,"line":564},61,[211,566,567],{},"                        Allow: 'PUT, GET, DELETE',\n",[211,569,571],{"class":213,"line":570},62,[211,572,573],{},"                    },\n",[211,575,577],{"class":213,"line":576},63,[211,578,514],{},[211,580,582],{"class":213,"line":581},64,[211,583,354],{},[211,585,587],{"class":213,"line":586},65,[211,588,589],{},"    },\n",[211,591,593],{"class":213,"line":592},66,[211,594,229],{},[15,596,597],{},"代码的大部分都是基于 Cloudflare Docs 中给出的样例，修改了几个小的优化点",[184,599,600,603,609],{},[187,601,602],{},"删除了 ALLOW_LIST 部分代码，默认所有文件都是可以被访问的",[187,604,605,606],{},"在上传一个文件时，如果目标路径存在同名文件，则不直接覆盖，而是返回 409 的异常 HTTP 相应，如果想要强制覆盖，则需要在 Http Header 中加入 ",[208,607,608],{},"Overwrite: true",[187,610,611],{},"解出请求路径时，使用 decodeURI( ) 方法先进行解码，解决文件路径中含有中文时会导致请求失败的问题。",[15,613,614],{},"填入代码后，还需要绑定两个变量，一个是 R2 Bucket",[15,616,617],{},[26,618],{"alt":206,"src":168},[15,620,621],{},"另一个是自己的管理密码",[15,623,624],{},[26,625],{"alt":206,"src":626},"https://static.031130.xyz/uploads/2024/08/14/96da1f62f5fe7.webp",[10,628,630],{"id":629},"如何使用-cloudflare-workers-构建的-restful-api-进行文件操作","如何使用 Cloudflare Workers 构建的 Restful API 进行文件操作？",[19,632,633],{"id":633},"上传",[15,635,636],{},"以 python 为例，上传一个文件 1MB.bin 到 /example/ 目录下，上传的 url 就是文件最终的存在路径。",[201,638,642],{"className":639,"code":640,"language":641,"meta":206,"style":206},"language-python shiki shiki-themes github-light github-dark","import requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n    \nrequests.put(\n    'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET,\n        'Overwrite': True   # 如果不需要强制覆盖可以删除这一行\n    }\n)\n","python",[208,643,644,649,653,658,662,667,672,677,682,687,692,697,702,706],{"__ignoreMap":206},[211,645,646],{"class":213,"line":214},[211,647,648],{},"import requests\n",[211,650,651],{"class":213,"line":220},[211,652,236],{"emptyLinePlaceholder":235},[211,654,655],{"class":213,"line":226},[211,656,657],{},"AUTH_KEY_SECRET='1145141919810'\n",[211,659,660],{"class":213,"line":232},[211,661,236],{"emptyLinePlaceholder":235},[211,663,664],{"class":213,"line":239},[211,665,666],{},"with open('1MB.bin', ''rb) as f:\n",[211,668,669],{"class":213,"line":245},[211,670,671],{},"    file_content = f.read()\n",[211,673,674],{"class":213,"line":251},[211,675,676],{},"    \n",[211,678,679],{"class":213,"line":257},[211,680,681],{},"requests.put(\n",[211,683,684],{"class":213,"line":263},[211,685,686],{},"    'https://r2.example.workers.dev/example/1MB.bin',\n",[211,688,689],{"class":213,"line":269},[211,690,691],{},"    headers={\n",[211,693,694],{"class":213,"line":275},[211,695,696],{},"        'X-Custom-Auth-Key': AUTH_KEY_SECRET,\n",[211,698,699],{"class":213,"line":281},[211,700,701],{},"        'Overwrite': True   # 如果不需要强制覆盖可以删除这一行\n",[211,703,704],{"class":213,"line":287},[211,705,296],{},[211,707,708],{"class":213,"line":293},[211,709,710],{},")\n",[19,712,713],{"id":713},"访问",[15,715,716,717,720],{},"通过浏览器直接访问 ",[208,718,719],{},"https://r2.example.workers.dev/example/1MB.bin"," 应该就能访问到",[19,722,723],{"id":723},"删除",[15,725,726],{},"仍然以 python 为例，删除刚才的文件",[201,728,730],{"className":639,"code":729,"language":641,"meta":206,"style":206},"import requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n    \nrequests.delete(\n    'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET\n    }\n)\n",[208,731,732,736,740,744,748,752,756,760,765,769,773,778,782],{"__ignoreMap":206},[211,733,734],{"class":213,"line":214},[211,735,648],{},[211,737,738],{"class":213,"line":220},[211,739,236],{"emptyLinePlaceholder":235},[211,741,742],{"class":213,"line":226},[211,743,657],{},[211,745,746],{"class":213,"line":232},[211,747,236],{"emptyLinePlaceholder":235},[211,749,750],{"class":213,"line":239},[211,751,666],{},[211,753,754],{"class":213,"line":245},[211,755,671],{},[211,757,758],{"class":213,"line":251},[211,759,676],{},[211,761,762],{"class":213,"line":257},[211,763,764],{},"requests.delete(\n",[211,766,767],{"class":213,"line":263},[211,768,686],{},[211,770,771],{"class":213,"line":269},[211,772,691],{},[211,774,775],{"class":213,"line":275},[211,776,777],{},"        'X-Custom-Auth-Key': AUTH_KEY_SECRET\n",[211,779,780],{"class":213,"line":281},[211,781,296],{},[211,783,784],{"class":213,"line":287},[211,785,710],{},[10,787,788],{"id":788},"参见",[184,790,791,798,804,811],{},[187,792,793],{},[63,794,797],{"href":795,"rel":796},"https://blog.yswtrue.com/yong-cloudflare-de-r2-he-worker-lai-zuo-wen-jian-tuo-guan/",[124],"用 cloudflare 的 R2 和 worker 来做文件托管",[187,799,800],{},[63,801,803],{"href":159,"rel":802},[124],"Workers API reference",[187,805,806],{},[63,807,810],{"href":808,"rel":809},"https://developers.cloudflare.com/r2/api/workers/workers-api-usage/",[124],"Use R2 from Workers",[187,812,813],{},[63,814,816],{"href":129,"rel":815},[124],"创建已签名的 AWS API 请求",[818,819,820],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":206,"searchDepth":220,"depth":220,"links":822},[823,827,831,832,833,838],{"id":12,"depth":220,"text":13,"children":824},[825,826],{"id":21,"depth":226,"text":22},{"id":32,"depth":226,"text":33},{"id":51,"depth":220,"text":52,"children":828},[829,830],{"id":58,"depth":226,"text":58},{"id":93,"depth":226,"text":94},{"id":178,"depth":220,"text":179},{"id":195,"depth":220,"text":196},{"id":629,"depth":220,"text":630,"children":834},[835,836,837],{"id":633,"depth":226,"text":633},{"id":713,"depth":226,"text":713},{"id":723,"depth":226,"text":723},{"id":788,"depth":220,"text":788},"2024-08-13 22:58:26","md",{},"/2024/08/13/build-restful-api-for-cloudflare-r2-with-cloudflare-workers","---\ntitle: 自建图床小记二——使用 Workers 为 R2 构建 Restful API\ndate: 2024-08-13 22:58:26\nsticky:\ntags:\n- 图床\n- Cloudflare\n- JavaScript\n- Python\n---\n\n## 访问 R2 的两种方式\n\n一般来说，想要访问 Cloudflare R2 中的文件，会有两种方式。\n\n### 一种是在 R2 的设置界面设置自定义域\n\n![设置自定义域](https://static.031130.xyz/uploads/2024/08/13/61fe9ede194af.webp)\n\n### 另一种是通过 Cloudflare Workers 进行访问\n\n![通过 Cloudflare Workers](https://static.031130.xyz/uploads/2024/08/13/846164273571d.webp)\n\n***\n\n**那么应该选择哪种？选择 Cloudflare Workers！**\n\n## 为什么是 Cloudflare Workers？\n\n要回答这个问题比较困难，但可以回答另一个问题——「为什么不设置自定义域实现直接访问？」\n\n### 自定义域的访问存在限制\n\n设置自定义域的访问方式存在较多的限制，让我们先来复习一下[上一篇博客中](/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/)提到的 DNS 解析方案 1\n\n![DNS 解析方案 1](https://static.031130.xyz/uploads/2024/08/13/03d8243b67593.webp)\n\n在这里，我们需要将图床访问域名通过 NS 接入 DnsPod 实现境内外的分流，但 R2 所允许设置的自定义域必须是通过 NS 接入 Cloudflare 的，这存在冲突。那如果我们先将自定义域设置为通过 NS 接入 Cloudflare 的工具人域名，再将图床访问域名通过 CNAME 解析到工具人域名会不会有问题呢？恭喜你获得 403 Forbidden。\n\n如果通过[上一篇文章](/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/)中的 DNS 解析方案 2 来进行 DNS 解析，能不能成功设置为 Cloudflare R2 的自定义域呢？也不行，Cloudflare R2 的自定义域会占用域名的解析，这意味着你无法将图床访问域名解析到用于分流的工具人域名。\n\n***\n\n**结论：截至本文写作时间，设置自定义域的方案不适用于 DNS 分流的图床架构。**\n\n### 如何上传文件到 Cloudflare R2？\n\n#### 网页端直接上传\n\n最简单的上传方式是直接在 Cloudflare 进行网页上传，但这种方案不适合自动化脚本，也没法接入 Typora\n\n![直接在网页端进行上传](https://static.031130.xyz/uploads/2024/08/13/b4d1b5b3edfae.webp)\n\n#### 使用 Amazon S3 的兼容 API\n\n##### 手动调用 S3 API\n\nCloudflare R2 被设计为兼容 Amazon S3 的存储方案，自然兼容 Amazon S3 的上传 API，在 [Cloudflare Docs 中有关于 S3 API 的实现情况](https://developers.cloudflare.com/r2/api/s3/api/)记载，大部分接口功能都是实现了的。但。。。但 S3 使用的是 [AWS Signature](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html) 作为鉴权，你不会希望在每个自动化程序中都自己实现一次的。。。\n\n![https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png)\n\n##### 使用 aws-cli 等 SDK\n\n使用 aws-cli 可以自动实现计算 AWS Signature，这是一种可行的方案，但我可能会在别的服务中使用到我的图床，不是所有的服务所处的环境都能够执行 shell 命令，也不是所有的编程语言都有现成的 SDK 可用。\n\n#### 使用 Cloudflare Workers 构建 Restful API\n\n[在 Cloudflare Docs 中明确提出可以使用 Cloudflare Workers 访问 Cloudflare R2 Bucket，](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/#5-access-your-r2-bucket-from-your-worker)通过 Workers 设置界面的按钮，可以非常方便的将 R2 Bucket 作为一个 R2Object 绑定到 JavaScript 的一个变量中，[这里有相关的开发文档](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)。\n\n![绑定为变量](https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp)\n\n***\n\n**结论: 从易用性上来看，使用 Cloudflare Workers 构建 Restful API 这种上传文件的方案是最为合适的。**\n\n## 使用 Cloudflare Workers 构建 Restful API 的方案有没有什么缺点？\n\n有。\n\n- Cloudflare Workers 的每日额度是有限的，在极端的流量下可能会用完（应该不会吧？）\n- Cloudflare Workers 的内存限制为 128MB，在上传下载 > 100MB 的文件时可能会出错。有这种体积上传需求的场景建议使用别的上传方案。\n\n## 如何构建？\n\n直接贴代码\n\n```javascript\nconst hasValidHeader = (request, env) => {\n\treturn request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n};\n\nfunction authorizeRequest(request, env, key) {\n\tswitch (request.method) {\n\t\tcase 'PUT':\n\t\tcase 'DELETE':\n\t\t\treturn hasValidHeader(request, env);\n\t\tcase 'GET':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport default {\n\tasync fetch(request, env) {\n\t\tconst url = new URL(request.url);\n\t\tconst key = decodeURI(url.pathname.slice(1));\n\n\t\tif (!authorizeRequest(request, env, key)) {\n\t\t\treturn new Response('Forbidden\\n', { status: 403 });\n\t\t}\n\n\t\tswitch (request.method) {\n\t\t\tcase 'PUT':\n\t\t\t\tconst objectExists = await env.MY_BUCKET.get(key);\n\n\t\t\t\tif (objectExists !== null) {\n\t\t\t\t\tif (request.headers.get('Overwrite') !== 'true') {\n\t\t\t\t\t\treturn new Response('Object Already Exists\\n', { status: 409 });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait env.MY_BUCKET.put(key, request.body);\n\t\t\t\treturn new Response(`Put ${key} successfully!\\n`);\n\n\t\t\tcase 'GET':\n\t\t\t\tconst object = await env.MY_BUCKET.get(key);\n\n\t\t\t\tif (object === null) {\n\t\t\t\t\treturn new Response('Object Not Found\\n', { status: 404 });\n\t\t\t\t}\n\n\t\t\t\tconst headers = new Headers();\n\t\t\t\tobject.writeHttpMetadata(headers);\n\t\t\t\theaders.set('etag', object.httpEtag);\n\n\t\t\t\treturn new Response(object.body, {\n\t\t\t\t\theaders,\n\t\t\t\t});\n\t\t\tcase 'DELETE':\n\t\t\t\tawait env.MY_BUCKET.delete(key);\n\t\t\t\treturn new Response('Deleted!\\n');\n\n\t\t\tdefault:\n\t\t\t\treturn new Response('Method Not Allowed\\n', {\n\t\t\t\t\tstatus: 405,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAllow: 'PUT, GET, DELETE',\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t}\n\t},\n};\n```\n\n代码的大部分都是基于 Cloudflare Docs 中给出的样例，修改了几个小的优化点\n\n- 删除了 ALLOW_LIST 部分代码，默认所有文件都是可以被访问的\n- 在上传一个文件时，如果目标路径存在同名文件，则不直接覆盖，而是返回 409 的异常 HTTP 相应，如果想要强制覆盖，则需要在 Http Header 中加入 `Overwrite: true` \n- 解出请求路径时，使用 decodeURI( ) 方法先进行解码，解决文件路径中含有中文时会导致请求失败的问题。\n\n填入代码后，还需要绑定两个变量，一个是 R2 Bucket\n\n![](https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp)\n\n另一个是自己的管理密码\n\n![](https://static.031130.xyz/uploads/2024/08/14/96da1f62f5fe7.webp)\n\n## 如何使用 Cloudflare Workers 构建的 Restful API 进行文件操作？\n\n### 上传\n\n以 python 为例，上传一个文件 1MB.bin 到 /example/ 目录下，上传的 url 就是文件最终的存在路径。\n\n```python\nimport requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n    \nrequests.put(\n\t'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET,\n        'Overwrite': True\t# 如果不需要强制覆盖可以删除这一行\n    }\n)\n```\n\n### 访问\n\n通过浏览器直接访问 `https://r2.example.workers.dev/example/1MB.bin` 应该就能访问到\n\n### 删除\n\n仍然以 python 为例，删除刚才的文件\n\n```python\nimport requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n    \nrequests.delete(\n\t'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET\n    }\n)\n```\n\n## 参见\n\n- [用 cloudflare 的 R2 和 worker 来做文件托管](https://blog.yswtrue.com/yong-cloudflare-de-r2-he-worker-lai-zuo-wen-jian-tuo-guan/)\n- [Workers API reference](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)\n- [Use R2 from Workers](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/)\n- [创建已签名的 AWS API 请求](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html)\n",{"title":5,"description":206},"posts/build-restful-api-for-cloudflare-r2-with-cloudflare-workers",false,[848,849,850,851],"图床","Cloudflare","JavaScript","Python","bb5UosY3PbSKjMv_GzTPo2bi7OUD92oNzmbsid7JleE",[854,859],{"title":855,"path":856,"stem":857,"date":858},"自建图床小记三—— SSL 证书的自动更新与部署","/2024/08/14/auto-renew-ssl-certificate-and-deploy-to-upyun-with-github-action","posts/auto-renew-ssl-certificate-and-deploy-to-upyun-with-github-action","2024-08-14 10:35:18",{"title":860,"path":861,"stem":862,"date":863},"自建图床小记一——图床架构与 DNS 解析","/2024/08/12/new-picbed-based-on-cloudflare-and-upyun","posts/new-picbed-based-on-cloudflare-and-upyun","2024-08-12 17:07:11",1761695683048]