[{"data":1,"prerenderedAt":991},["ShallowReactive",2],{"post-2024-08-13-build-restful-api-for-cloudflare-r2-with-cloudflare-workers":3,"has-en-2024-08-13-build-restful-api-for-cloudflare-r2-with-cloudflare-workers":973,"surround-2024-08-13-build-restful-api-for-cloudflare-r2-with-cloudflare-workers":980,"randomIndex/2024/08/13/build-restful-api-for-cloudflare-r2-with-cloudflare-workers/":269},{"id":4,"title":5,"body":6,"date":965,"description":206,"extension":966,"lang":967,"meta":968,"navigation":235,"path":969,"rawbody":970,"seo":971,"stem":972,"sticky":973,"tags":974,"__hash__":979},"posts/posts/build-restful-api-for-cloudflare-r2-with-cloudflare-workers.md","自建图床小记二——使用 Workers 为 R2 构建 Restful API",{"type":7,"value":8,"toc":947},"minimark",[9,14,18,23,30,34,40,43,49,53,56,59,68,74,77,84,86,91,95,99,102,108,112,117,133,138,142,145,149,163,169,171,176,180,183,193,197,200,595,598,612,615,619,622,627,631,634,637,793,796,803,806,809,912,915,943],[10,11,13],"h2",{"id":12},"访问-r2-的两种方式","访问 R2 的两种方式",[15,16,17],"p",{},"一般来说，想要访问 Cloudflare R2 中的文件，会有两种方式。",[19,20,22],"h3",{"id":21},"一种是在-r2-的设置界面设置自定义域","一种是在 R2 的设置界面设置自定义域",[15,24,25],{},[26,27],"img",{"alt":28,"src":29},"设置自定义域","https://static.031130.xyz/uploads/2024/08/13/61fe9ede194af.webp",[19,31,33],{"id":32},"另一种是通过-cloudflare-workers-进行访问","另一种是通过 Cloudflare Workers 进行访问",[15,35,36],{},[26,37],{"alt":38,"src":39},"通过 Cloudflare Workers","https://static.031130.xyz/uploads/2024/08/13/846164273571d.webp",[41,42],"hr",{},[15,44,45],{},[46,47,48],"strong",{},"那么应该选择哪种？选择 Cloudflare Workers！",[10,50,52],{"id":51},"为什么是-cloudflare-workers","为什么是 Cloudflare Workers？",[15,54,55],{},"要回答这个问题比较困难，但可以回答另一个问题——「为什么不设置自定义域实现直接访问？」",[19,57,58],{"id":58},"自定义域的访问存在限制",[15,60,61,62,67],{},"设置自定义域的访问方式存在较多的限制，让我们先来复习一下",[63,64,66],"a",{"href":65},"/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/","上一篇博客中","提到的 DNS 解析方案 1",[15,69,70],{},[26,71],{"alt":72,"src":73},"DNS 解析方案 1","https://static.031130.xyz/uploads/2024/08/13/03d8243b67593.webp",[15,75,76],{},"在这里，我们需要将图床访问域名通过 NS 接入 DnsPod 实现境内外的分流，但 R2 所允许设置的自定义域必须是通过 NS 接入 Cloudflare 的，这存在冲突。那如果我们先将自定义域设置为通过 NS 接入 Cloudflare 的工具人域名，再将图床访问域名通过 CNAME 解析到工具人域名会不会有问题呢？恭喜你获得 403 Forbidden。",[15,78,79,80,83],{},"如果通过",[63,81,82],{"href":65},"上一篇文章","中的 DNS 解析方案 2 来进行 DNS 解析，能不能成功设置为 Cloudflare R2 的自定义域呢？也不行，Cloudflare R2 的自定义域会占用域名的解析，这意味着你无法将图床访问域名解析到用于分流的工具人域名。",[41,85],{},[15,87,88],{},[46,89,90],{},"结论：截至本文写作时间，设置自定义域的方案不适用于 DNS 分流的图床架构。",[19,92,94],{"id":93},"如何上传文件到-cloudflare-r2","如何上传文件到 Cloudflare R2？",[96,97,98],"h4",{"id":98},"网页端直接上传",[15,100,101],{},"最简单的上传方式是直接在 Cloudflare 进行网页上传，但这种方案不适合自动化脚本，也没法接入 Typora",[15,103,104],{},[26,105],{"alt":106,"src":107},"直接在网页端进行上传","https://static.031130.xyz/uploads/2024/08/13/b4d1b5b3edfae.webp",[96,109,111],{"id":110},"使用-amazon-s3-的兼容-api","使用 Amazon S3 的兼容 API",[113,114,116],"h5",{"id":115},"手动调用-s3-api","手动调用 S3 API",[15,118,119,120,126,127,132],{},"Cloudflare R2 被设计为兼容 Amazon S3 的存储方案，自然兼容 Amazon S3 的上传 API，在 ",[63,121,125],{"href":122,"rel":123},"https://developers.cloudflare.com/r2/api/s3/api/",[124],"nofollow","Cloudflare Docs 中有关于 S3 API 的实现情况","记载，大部分接口功能都是实现了的。但。。。但 S3 使用的是 ",[63,128,131],{"href":129,"rel":130},"https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html",[124],"AWS Signature"," 作为鉴权，你不会希望在每个自动化程序中都自己实现一次的。。。",[15,134,135],{},[26,136],{"alt":137,"src":137},"https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png",[113,139,141],{"id":140},"使用-aws-cli-等-sdk","使用 aws-cli 等 SDK",[15,143,144],{},"使用 aws-cli 可以自动实现计算 AWS Signature，这是一种可行的方案，但我可能会在别的服务中使用到我的图床，不是所有的服务所处的环境都能够执行 shell 命令，也不是所有的编程语言都有现成的 SDK 可用。",[96,146,148],{"id":147},"使用-cloudflare-workers-构建-restful-api","使用 Cloudflare Workers 构建 Restful API",[15,150,151,156,157,162],{},[63,152,155],{"href":153,"rel":154},"https://developers.cloudflare.com/r2/api/workers/workers-api-usage/#5-access-your-r2-bucket-from-your-worker",[124],"在 Cloudflare Docs 中明确提出可以使用 Cloudflare Workers 访问 Cloudflare R2 Bucket，","通过 Workers 设置界面的按钮，可以非常方便的将 R2 Bucket 作为一个 R2Object 绑定到 JavaScript 的一个变量中，",[63,158,161],{"href":159,"rel":160},"https://developers.cloudflare.com/r2/api/workers/workers-api-reference/",[124],"这里有相关的开发文档","。",[15,164,165],{},[26,166],{"alt":167,"src":168},"绑定为变量","https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp",[41,170],{},[15,172,173],{},[46,174,175],{},"结论: 从易用性上来看，使用 Cloudflare Workers 构建 Restful API 这种上传文件的方案是最为合适的。",[10,177,179],{"id":178},"使用-cloudflare-workers-构建-restful-api-的方案有没有什么缺点","使用 Cloudflare Workers 构建 Restful API 的方案有没有什么缺点？",[15,181,182],{},"有。",[184,185,186,190],"ul",{},[187,188,189],"li",{},"Cloudflare Workers 的每日额度是有限的，在极端的流量下可能会用完（应该不会吧？）",[187,191,192],{},"Cloudflare Workers 的内存限制为 128MB，在上传下载 > 100MB 的文件时可能会出错。有这种体积上传需求的场景建议使用别的上传方案。",[10,194,196],{"id":195},"如何构建","如何构建？",[15,198,199],{},"直接贴代码",[201,202,207],"pre",{"className":203,"code":204,"language":205,"meta":206,"style":206},"language-javascript shiki shiki-themes one-light one-dark-pro","const hasValidHeader = (request, env) => {\n    return request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n};\n\nfunction authorizeRequest(request, env, key) {\n    switch (request.method) {\n        case 'PUT':\n        case 'DELETE':\n            return hasValidHeader(request, env);\n        case 'GET':\n            return true;\n        default:\n            return false;\n    }\n}\n\nexport default {\n    async fetch(request, env) {\n        const url = new URL(request.url);\n        const key = decodeURI(url.pathname.slice(1));\n\n        if (!authorizeRequest(request, env, key)) {\n            return new Response('Forbidden\\n', { status: 403 });\n        }\n\n        switch (request.method) {\n            case 'PUT':\n                const objectExists = await env.MY_BUCKET.get(key);\n\n                if (objectExists !== null) {\n                    if (request.headers.get('Overwrite') !== 'true') {\n                        return new Response('Object Already Exists\\n', { status: 409 });\n                    }\n                }\n\n                await env.MY_BUCKET.put(key, request.body);\n                return new Response(`Put ${key} successfully!\\n`);\n\n            case 'GET':\n                const object = await env.MY_BUCKET.get(key);\n\n                if (object === null) {\n                    return new Response('Object Not Found\\n', { status: 404 });\n                }\n\n                const headers = new Headers();\n                object.writeHttpMetadata(headers);\n                headers.set('etag', object.httpEtag);\n\n                return new Response(object.body, {\n                    headers,\n                });\n            case 'DELETE':\n                await env.MY_BUCKET.delete(key);\n                return new Response('Deleted!\\n');\n\n            default:\n                return new Response('Method Not Allowed\\n', {\n                    status: 405,\n                    headers: {\n                        Allow: 'PUT, GET, DELETE',\n                    },\n                });\n        }\n    },\n};\n","javascript","",[208,209,210,218,224,230,237,243,249,255,261,267,273,279,285,291,297,303,308,314,320,326,332,337,343,349,355,360,366,372,378,383,389,395,401,407,413,418,424,430,435,441,447,452,458,464,469,474,480,486,492,497,503,509,515,521,527,533,538,544,550,556,562,568,574,579,584,590],"code",{"__ignoreMap":206},[211,212,215],"span",{"class":213,"line":214},"line",1,[211,216,217],{},"const hasValidHeader = (request, env) => {\n",[211,219,221],{"class":213,"line":220},2,[211,222,223],{},"    return request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n",[211,225,227],{"class":213,"line":226},3,[211,228,229],{},"};\n",[211,231,233],{"class":213,"line":232},4,[211,234,236],{"emptyLinePlaceholder":235},true,"\n",[211,238,240],{"class":213,"line":239},5,[211,241,242],{},"function authorizeRequest(request, env, key) {\n",[211,244,246],{"class":213,"line":245},6,[211,247,248],{},"    switch (request.method) {\n",[211,250,252],{"class":213,"line":251},7,[211,253,254],{},"        case 'PUT':\n",[211,256,258],{"class":213,"line":257},8,[211,259,260],{},"        case 'DELETE':\n",[211,262,264],{"class":213,"line":263},9,[211,265,266],{},"            return hasValidHeader(request, env);\n",[211,268,270],{"class":213,"line":269},10,[211,271,272],{},"        case 'GET':\n",[211,274,276],{"class":213,"line":275},11,[211,277,278],{},"            return true;\n",[211,280,282],{"class":213,"line":281},12,[211,283,284],{},"        default:\n",[211,286,288],{"class":213,"line":287},13,[211,289,290],{},"            return false;\n",[211,292,294],{"class":213,"line":293},14,[211,295,296],{},"    }\n",[211,298,300],{"class":213,"line":299},15,[211,301,302],{},"}\n",[211,304,306],{"class":213,"line":305},16,[211,307,236],{"emptyLinePlaceholder":235},[211,309,311],{"class":213,"line":310},17,[211,312,313],{},"export default {\n",[211,315,317],{"class":213,"line":316},18,[211,318,319],{},"    async fetch(request, env) {\n",[211,321,323],{"class":213,"line":322},19,[211,324,325],{},"        const url = new URL(request.url);\n",[211,327,329],{"class":213,"line":328},20,[211,330,331],{},"        const key = decodeURI(url.pathname.slice(1));\n",[211,333,335],{"class":213,"line":334},21,[211,336,236],{"emptyLinePlaceholder":235},[211,338,340],{"class":213,"line":339},22,[211,341,342],{},"        if (!authorizeRequest(request, env, key)) {\n",[211,344,346],{"class":213,"line":345},23,[211,347,348],{},"            return new Response('Forbidden\\n', { status: 403 });\n",[211,350,352],{"class":213,"line":351},24,[211,353,354],{},"        }\n",[211,356,358],{"class":213,"line":357},25,[211,359,236],{"emptyLinePlaceholder":235},[211,361,363],{"class":213,"line":362},26,[211,364,365],{},"        switch (request.method) {\n",[211,367,369],{"class":213,"line":368},27,[211,370,371],{},"            case 'PUT':\n",[211,373,375],{"class":213,"line":374},28,[211,376,377],{},"                const objectExists = await env.MY_BUCKET.get(key);\n",[211,379,381],{"class":213,"line":380},29,[211,382,236],{"emptyLinePlaceholder":235},[211,384,386],{"class":213,"line":385},30,[211,387,388],{},"                if (objectExists !== null) {\n",[211,390,392],{"class":213,"line":391},31,[211,393,394],{},"                    if (request.headers.get('Overwrite') !== 'true') {\n",[211,396,398],{"class":213,"line":397},32,[211,399,400],{},"                        return new Response('Object Already Exists\\n', { status: 409 });\n",[211,402,404],{"class":213,"line":403},33,[211,405,406],{},"                    }\n",[211,408,410],{"class":213,"line":409},34,[211,411,412],{},"                }\n",[211,414,416],{"class":213,"line":415},35,[211,417,236],{"emptyLinePlaceholder":235},[211,419,421],{"class":213,"line":420},36,[211,422,423],{},"                await env.MY_BUCKET.put(key, request.body);\n",[211,425,427],{"class":213,"line":426},37,[211,428,429],{},"                return new Response(`Put ${key} successfully!\\n`);\n",[211,431,433],{"class":213,"line":432},38,[211,434,236],{"emptyLinePlaceholder":235},[211,436,438],{"class":213,"line":437},39,[211,439,440],{},"            case 'GET':\n",[211,442,444],{"class":213,"line":443},40,[211,445,446],{},"                const object = await env.MY_BUCKET.get(key);\n",[211,448,450],{"class":213,"line":449},41,[211,451,236],{"emptyLinePlaceholder":235},[211,453,455],{"class":213,"line":454},42,[211,456,457],{},"                if (object === null) {\n",[211,459,461],{"class":213,"line":460},43,[211,462,463],{},"                    return new Response('Object Not Found\\n', { status: 404 });\n",[211,465,467],{"class":213,"line":466},44,[211,468,412],{},[211,470,472],{"class":213,"line":471},45,[211,473,236],{"emptyLinePlaceholder":235},[211,475,477],{"class":213,"line":476},46,[211,478,479],{},"                const headers = new Headers();\n",[211,481,483],{"class":213,"line":482},47,[211,484,485],{},"                object.writeHttpMetadata(headers);\n",[211,487,489],{"class":213,"line":488},48,[211,490,491],{},"                headers.set('etag', object.httpEtag);\n",[211,493,495],{"class":213,"line":494},49,[211,496,236],{"emptyLinePlaceholder":235},[211,498,500],{"class":213,"line":499},50,[211,501,502],{},"                return new Response(object.body, {\n",[211,504,506],{"class":213,"line":505},51,[211,507,508],{},"                    headers,\n",[211,510,512],{"class":213,"line":511},52,[211,513,514],{},"                });\n",[211,516,518],{"class":213,"line":517},53,[211,519,520],{},"            case 'DELETE':\n",[211,522,524],{"class":213,"line":523},54,[211,525,526],{},"                await env.MY_BUCKET.delete(key);\n",[211,528,530],{"class":213,"line":529},55,[211,531,532],{},"                return new Response('Deleted!\\n');\n",[211,534,536],{"class":213,"line":535},56,[211,537,236],{"emptyLinePlaceholder":235},[211,539,541],{"class":213,"line":540},57,[211,542,543],{},"            default:\n",[211,545,547],{"class":213,"line":546},58,[211,548,549],{},"                return new Response('Method Not Allowed\\n', {\n",[211,551,553],{"class":213,"line":552},59,[211,554,555],{},"                    status: 405,\n",[211,557,559],{"class":213,"line":558},60,[211,560,561],{},"                    headers: {\n",[211,563,565],{"class":213,"line":564},61,[211,566,567],{},"                        Allow: 'PUT, GET, DELETE',\n",[211,569,571],{"class":213,"line":570},62,[211,572,573],{},"                    },\n",[211,575,577],{"class":213,"line":576},63,[211,578,514],{},[211,580,582],{"class":213,"line":581},64,[211,583,354],{},[211,585,587],{"class":213,"line":586},65,[211,588,589],{},"    },\n",[211,591,593],{"class":213,"line":592},66,[211,594,229],{},[15,596,597],{},"代码的大部分都是基于 Cloudflare Docs 中给出的样例，修改了几个小的优化点",[184,599,600,603,609],{},[187,601,602],{},"删除了 ALLOW_LIST 部分代码，默认所有文件都是可以被访问的",[187,604,605,606],{},"在上传一个文件时，如果目标路径存在同名文件，则不直接覆盖，而是返回 409 的异常 HTTP 相应，如果想要强制覆盖，则需要在 Http Header 中加入 ",[208,607,608],{},"Overwrite: true",[187,610,611],{},"解出请求路径时，使用 decodeURI( ) 方法先进行解码，解决文件路径中含有中文时会导致请求失败的问题。",[15,613,614],{},"填入代码后，还需要绑定两个变量，一个是 R2 Bucket",[15,616,617],{},[26,618],{"alt":206,"src":168},[15,620,621],{},"另一个是自己的管理密码",[15,623,624],{},[26,625],{"alt":206,"src":626},"https://static.031130.xyz/uploads/2024/08/14/96da1f62f5fe7.webp",[10,628,630],{"id":629},"如何使用-cloudflare-workers-构建的-restful-api-进行文件操作","如何使用 Cloudflare Workers 构建的 Restful API 进行文件操作？",[19,632,633],{"id":633},"上传",[15,635,636],{},"以 python 为例，上传一个文件 1MB.bin 到 /example/ 目录下，上传的 url 就是文件最终的存在路径。",[201,638,642],{"className":639,"code":640,"language":641,"meta":206,"style":206},"language-python shiki shiki-themes one-light one-dark-pro","import requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n\nrequests.put(\n    'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET,\n        'Overwrite': True   # 如果不需要强制覆盖可以删除这一行\n    }\n)\n","python",[208,643,644,654,658,672,676,706,723,727,738,746,757,769,784,788],{"__ignoreMap":206},[211,645,646,650],{"class":213,"line":214},[211,647,649],{"class":648},"sLKXg","import",[211,651,653],{"class":652},"s5ixo"," requests\n",[211,655,656],{"class":213,"line":220},[211,657,236],{"emptyLinePlaceholder":235},[211,659,660,664,668],{"class":213,"line":226},[211,661,663],{"class":662},"sYebD","AUTH_KEY_SECRET",[211,665,667],{"class":666},"sknuh","=",[211,669,671],{"class":670},"sDhpE","'1145141919810'\n",[211,673,674],{"class":213,"line":232},[211,675,236],{"emptyLinePlaceholder":235},[211,677,678,681,685,688,691,694,697,700,703],{"class":213,"line":239},[211,679,680],{"class":648},"with",[211,682,684],{"class":683},"s_Sar"," open",[211,686,687],{"class":652},"(",[211,689,690],{"class":670},"'1MB.bin'",[211,692,693],{"class":652},", ",[211,695,696],{"class":670},"''",[211,698,699],{"class":652},"rb) ",[211,701,702],{"class":648},"as",[211,704,705],{"class":652}," f:\n",[211,707,708,711,713,716,720],{"class":213,"line":245},[211,709,710],{"class":652},"    file_content ",[211,712,667],{"class":666},[211,714,715],{"class":652}," f.",[211,717,719],{"class":718},"slOjB","read",[211,721,722],{"class":652},"()\n",[211,724,725],{"class":213,"line":251},[211,726,236],{"emptyLinePlaceholder":235},[211,728,729,732,735],{"class":213,"line":257},[211,730,731],{"class":652},"requests.",[211,733,734],{"class":718},"put",[211,736,737],{"class":652},"(\n",[211,739,740,743],{"class":213,"line":263},[211,741,742],{"class":670},"    'https://r2.example.workers.dev/example/1MB.bin'",[211,744,745],{"class":652},",\n",[211,747,748,752,754],{"class":213,"line":269},[211,749,751],{"class":750},"sp7wS","    headers",[211,753,667],{"class":666},[211,755,756],{"class":652},"{\n",[211,758,759,762,765,767],{"class":213,"line":275},[211,760,761],{"class":670},"        'X-Custom-Auth-Key'",[211,763,764],{"class":652},": ",[211,766,663],{"class":662},[211,768,745],{"class":652},[211,770,771,774,776,780],{"class":213,"line":281},[211,772,773],{"class":670},"        'Overwrite'",[211,775,764],{"class":652},[211,777,779],{"class":778},"sAGMh","True",[211,781,783],{"class":782},"sW2Sy","   # 如果不需要强制覆盖可以删除这一行\n",[211,785,786],{"class":213,"line":287},[211,787,296],{"class":652},[211,789,790],{"class":213,"line":293},[211,791,792],{"class":652},")\n",[19,794,795],{"id":795},"访问",[15,797,798,799,802],{},"通过浏览器直接访问 ",[208,800,801],{},"https://r2.example.workers.dev/example/1MB.bin"," 应该就能访问到",[19,804,805],{"id":805},"删除",[15,807,808],{},"仍然以 python 为例，删除刚才的文件",[201,810,812],{"className":639,"code":811,"language":641,"meta":206,"style":206},"import requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n\nrequests.delete(\n    'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET\n    }\n)\n",[208,813,814,820,824,832,836,856,868,872,881,887,895,904,908],{"__ignoreMap":206},[211,815,816,818],{"class":213,"line":214},[211,817,649],{"class":648},[211,819,653],{"class":652},[211,821,822],{"class":213,"line":220},[211,823,236],{"emptyLinePlaceholder":235},[211,825,826,828,830],{"class":213,"line":226},[211,827,663],{"class":662},[211,829,667],{"class":666},[211,831,671],{"class":670},[211,833,834],{"class":213,"line":232},[211,835,236],{"emptyLinePlaceholder":235},[211,837,838,840,842,844,846,848,850,852,854],{"class":213,"line":239},[211,839,680],{"class":648},[211,841,684],{"class":683},[211,843,687],{"class":652},[211,845,690],{"class":670},[211,847,693],{"class":652},[211,849,696],{"class":670},[211,851,699],{"class":652},[211,853,702],{"class":648},[211,855,705],{"class":652},[211,857,858,860,862,864,866],{"class":213,"line":245},[211,859,710],{"class":652},[211,861,667],{"class":666},[211,863,715],{"class":652},[211,865,719],{"class":718},[211,867,722],{"class":652},[211,869,870],{"class":213,"line":251},[211,871,236],{"emptyLinePlaceholder":235},[211,873,874,876,879],{"class":213,"line":257},[211,875,731],{"class":652},[211,877,878],{"class":718},"delete",[211,880,737],{"class":652},[211,882,883,885],{"class":213,"line":263},[211,884,742],{"class":670},[211,886,745],{"class":652},[211,888,889,891,893],{"class":213,"line":269},[211,890,751],{"class":750},[211,892,667],{"class":666},[211,894,756],{"class":652},[211,896,897,899,901],{"class":213,"line":275},[211,898,761],{"class":670},[211,900,764],{"class":652},[211,902,903],{"class":662},"AUTH_KEY_SECRET\n",[211,905,906],{"class":213,"line":281},[211,907,296],{"class":652},[211,909,910],{"class":213,"line":287},[211,911,792],{"class":652},[10,913,914],{"id":914},"参见",[184,916,917,924,930,937],{},[187,918,919],{},[63,920,923],{"href":921,"rel":922},"https://blog.yswtrue.com/yong-cloudflare-de-r2-he-worker-lai-zuo-wen-jian-tuo-guan/",[124],"用 cloudflare 的 R2 和 worker 来做文件托管",[187,925,926],{},[63,927,929],{"href":159,"rel":928},[124],"Workers API reference",[187,931,932],{},[63,933,936],{"href":934,"rel":935},"https://developers.cloudflare.com/r2/api/workers/workers-api-usage/",[124],"Use R2 from Workers",[187,938,939],{},[63,940,942],{"href":129,"rel":941},[124],"创建已签名的 AWS API 请求",[944,945,946],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .sLKXg, html code.shiki .sLKXg{--shiki-default:#A626A4;--shiki-dark:#C678DD}html pre.shiki code .s5ixo, html code.shiki .s5ixo{--shiki-default:#383A42;--shiki-dark:#ABB2BF}html pre.shiki code .sYebD, html code.shiki .sYebD{--shiki-default:#383A42;--shiki-dark:#D19A66}html pre.shiki code .sknuh, html code.shiki .sknuh{--shiki-default:#383A42;--shiki-dark:#56B6C2}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html pre.shiki code .s_Sar, html code.shiki .s_Sar{--shiki-default:#0184BC;--shiki-dark:#56B6C2}html pre.shiki code .slOjB, html code.shiki .slOjB{--shiki-default:#383A42;--shiki-dark:#61AFEF}html pre.shiki code .sp7wS, html code.shiki .sp7wS{--shiki-default:#986801;--shiki-default-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}html pre.shiki code .sW2Sy, html code.shiki .sW2Sy{--shiki-default:#A0A1A7;--shiki-default-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic}",{"title":206,"searchDepth":220,"depth":220,"links":948},[949,953,957,958,959,964],{"id":12,"depth":220,"text":13,"children":950},[951,952],{"id":21,"depth":226,"text":22},{"id":32,"depth":226,"text":33},{"id":51,"depth":220,"text":52,"children":954},[955,956],{"id":58,"depth":226,"text":58},{"id":93,"depth":226,"text":94},{"id":178,"depth":220,"text":179},{"id":195,"depth":220,"text":196},{"id":629,"depth":220,"text":630,"children":960},[961,962,963],{"id":633,"depth":226,"text":633},{"id":795,"depth":226,"text":795},{"id":805,"depth":226,"text":805},{"id":914,"depth":220,"text":914},"2024-08-13 22:58:26","md","zh-CN",{},"/2024/08/13/build-restful-api-for-cloudflare-r2-with-cloudflare-workers","---\ntitle: 自建图床小记二——使用 Workers 为 R2 构建 Restful API\ndate: 2024-08-13 22:58:26\nsticky:\ntags:\n- Image Hosting\n- Cloudflare\n- JavaScript\n- Python\n---\n\n## 访问 R2 的两种方式\n\n一般来说，想要访问 Cloudflare R2 中的文件，会有两种方式。\n\n### 一种是在 R2 的设置界面设置自定义域\n\n![设置自定义域](https://static.031130.xyz/uploads/2024/08/13/61fe9ede194af.webp)\n\n### 另一种是通过 Cloudflare Workers 进行访问\n\n![通过 Cloudflare Workers](https://static.031130.xyz/uploads/2024/08/13/846164273571d.webp)\n\n***\n\n**那么应该选择哪种？选择 Cloudflare Workers！**\n\n## 为什么是 Cloudflare Workers？\n\n要回答这个问题比较困难，但可以回答另一个问题——「为什么不设置自定义域实现直接访问？」\n\n### 自定义域的访问存在限制\n\n设置自定义域的访问方式存在较多的限制，让我们先来复习一下[上一篇博客中](/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/)提到的 DNS 解析方案 1\n\n![DNS 解析方案 1](https://static.031130.xyz/uploads/2024/08/13/03d8243b67593.webp)\n\n在这里，我们需要将图床访问域名通过 NS 接入 DnsPod 实现境内外的分流，但 R2 所允许设置的自定义域必须是通过 NS 接入 Cloudflare 的，这存在冲突。那如果我们先将自定义域设置为通过 NS 接入 Cloudflare 的工具人域名，再将图床访问域名通过 CNAME 解析到工具人域名会不会有问题呢？恭喜你获得 403 Forbidden。\n\n如果通过[上一篇文章](/2024/08/12/new-picbed-based-on-cloudflare-and-upyun/)中的 DNS 解析方案 2 来进行 DNS 解析，能不能成功设置为 Cloudflare R2 的自定义域呢？也不行，Cloudflare R2 的自定义域会占用域名的解析，这意味着你无法将图床访问域名解析到用于分流的工具人域名。\n\n***\n\n**结论：截至本文写作时间，设置自定义域的方案不适用于 DNS 分流的图床架构。**\n\n### 如何上传文件到 Cloudflare R2？\n\n#### 网页端直接上传\n\n最简单的上传方式是直接在 Cloudflare 进行网页上传，但这种方案不适合自动化脚本，也没法接入 Typora\n\n![直接在网页端进行上传](https://static.031130.xyz/uploads/2024/08/13/b4d1b5b3edfae.webp)\n\n#### 使用 Amazon S3 的兼容 API\n\n##### 手动调用 S3 API\n\nCloudflare R2 被设计为兼容 Amazon S3 的存储方案，自然兼容 Amazon S3 的上传 API，在 [Cloudflare Docs 中有关于 S3 API 的实现情况](https://developers.cloudflare.com/r2/api/s3/api/)记载，大部分接口功能都是实现了的。但。。。但 S3 使用的是 [AWS Signature](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html) 作为鉴权，你不会希望在每个自动化程序中都自己实现一次的。。。\n\n![https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/images/sigV4-using-auth-header.png)\n\n##### 使用 aws-cli 等 SDK\n\n使用 aws-cli 可以自动实现计算 AWS Signature，这是一种可行的方案，但我可能会在别的服务中使用到我的图床，不是所有的服务所处的环境都能够执行 shell 命令，也不是所有的编程语言都有现成的 SDK 可用。\n\n#### 使用 Cloudflare Workers 构建 Restful API\n\n[在 Cloudflare Docs 中明确提出可以使用 Cloudflare Workers 访问 Cloudflare R2 Bucket，](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/#5-access-your-r2-bucket-from-your-worker)通过 Workers 设置界面的按钮，可以非常方便的将 R2 Bucket 作为一个 R2Object 绑定到 JavaScript 的一个变量中，[这里有相关的开发文档](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)。\n\n![绑定为变量](https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp)\n\n***\n\n**结论: 从易用性上来看，使用 Cloudflare Workers 构建 Restful API 这种上传文件的方案是最为合适的。**\n\n## 使用 Cloudflare Workers 构建 Restful API 的方案有没有什么缺点？\n\n有。\n\n- Cloudflare Workers 的每日额度是有限的，在极端的流量下可能会用完（应该不会吧？）\n- Cloudflare Workers 的内存限制为 128MB，在上传下载 > 100MB 的文件时可能会出错。有这种体积上传需求的场景建议使用别的上传方案。\n\n## 如何构建？\n\n直接贴代码\n\n```javascript\nconst hasValidHeader = (request, env) => {\n\treturn request.headers.get('X-Custom-Auth-Key') === env.AUTH_KEY_SECRET;\n};\n\nfunction authorizeRequest(request, env, key) {\n\tswitch (request.method) {\n\t\tcase 'PUT':\n\t\tcase 'DELETE':\n\t\t\treturn hasValidHeader(request, env);\n\t\tcase 'GET':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport default {\n\tasync fetch(request, env) {\n\t\tconst url = new URL(request.url);\n\t\tconst key = decodeURI(url.pathname.slice(1));\n\n\t\tif (!authorizeRequest(request, env, key)) {\n\t\t\treturn new Response('Forbidden\\n', { status: 403 });\n\t\t}\n\n\t\tswitch (request.method) {\n\t\t\tcase 'PUT':\n\t\t\t\tconst objectExists = await env.MY_BUCKET.get(key);\n\n\t\t\t\tif (objectExists !== null) {\n\t\t\t\t\tif (request.headers.get('Overwrite') !== 'true') {\n\t\t\t\t\t\treturn new Response('Object Already Exists\\n', { status: 409 });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait env.MY_BUCKET.put(key, request.body);\n\t\t\t\treturn new Response(`Put ${key} successfully!\\n`);\n\n\t\t\tcase 'GET':\n\t\t\t\tconst object = await env.MY_BUCKET.get(key);\n\n\t\t\t\tif (object === null) {\n\t\t\t\t\treturn new Response('Object Not Found\\n', { status: 404 });\n\t\t\t\t}\n\n\t\t\t\tconst headers = new Headers();\n\t\t\t\tobject.writeHttpMetadata(headers);\n\t\t\t\theaders.set('etag', object.httpEtag);\n\n\t\t\t\treturn new Response(object.body, {\n\t\t\t\t\theaders,\n\t\t\t\t});\n\t\t\tcase 'DELETE':\n\t\t\t\tawait env.MY_BUCKET.delete(key);\n\t\t\t\treturn new Response('Deleted!\\n');\n\n\t\t\tdefault:\n\t\t\t\treturn new Response('Method Not Allowed\\n', {\n\t\t\t\t\tstatus: 405,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tAllow: 'PUT, GET, DELETE',\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t}\n\t},\n};\n```\n\n代码的大部分都是基于 Cloudflare Docs 中给出的样例，修改了几个小的优化点\n\n- 删除了 ALLOW_LIST 部分代码，默认所有文件都是可以被访问的\n- 在上传一个文件时，如果目标路径存在同名文件，则不直接覆盖，而是返回 409 的异常 HTTP 相应，如果想要强制覆盖，则需要在 Http Header 中加入 `Overwrite: true`\n- 解出请求路径时，使用 decodeURI( ) 方法先进行解码，解决文件路径中含有中文时会导致请求失败的问题。\n\n填入代码后，还需要绑定两个变量，一个是 R2 Bucket\n\n![](https://static.031130.xyz/uploads/2024/08/13/45e58b47f3aeb.webp)\n\n另一个是自己的管理密码\n\n![](https://static.031130.xyz/uploads/2024/08/14/96da1f62f5fe7.webp)\n\n## 如何使用 Cloudflare Workers 构建的 Restful API 进行文件操作？\n\n### 上传\n\n以 python 为例，上传一个文件 1MB.bin 到 /example/ 目录下，上传的 url 就是文件最终的存在路径。\n\n```python\nimport requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n\nrequests.put(\n\t'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET,\n        'Overwrite': True\t# 如果不需要强制覆盖可以删除这一行\n    }\n)\n```\n\n### 访问\n\n通过浏览器直接访问 `https://r2.example.workers.dev/example/1MB.bin` 应该就能访问到\n\n### 删除\n\n仍然以 python 为例，删除刚才的文件\n\n```python\nimport requests\n\nAUTH_KEY_SECRET='1145141919810'\n\nwith open('1MB.bin', ''rb) as f:\n    file_content = f.read()\n\nrequests.delete(\n\t'https://r2.example.workers.dev/example/1MB.bin',\n    headers={\n        'X-Custom-Auth-Key': AUTH_KEY_SECRET\n    }\n)\n```\n\n## 参见\n\n- [用 cloudflare 的 R2 和 worker 来做文件托管](https://blog.yswtrue.com/yong-cloudflare-de-r2-he-worker-lai-zuo-wen-jian-tuo-guan/)\n- [Workers API reference](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)\n- [Use R2 from Workers](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/)\n- [创建已签名的 AWS API 请求](https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/create-signed-request.html)\n",{"title":5,"description":206},"posts/build-restful-api-for-cloudflare-r2-with-cloudflare-workers",false,[975,976,977,978],"Image Hosting","Cloudflare","JavaScript","Python","5fhDRbhgJzMzlKRKwlkNoBm1m1GjEWMgUeZTFKvc8QM",[981,986],{"title":982,"path":983,"stem":984,"date":985,"children":-1},"自建图床小记三—— SSL 证书的自动更新与部署","/2024/08/14/auto-renew-ssl-certificate-and-deploy-to-upyun-with-github-action","posts/auto-renew-ssl-certificate-and-deploy-to-upyun-with-github-action","2024-08-14 10:35:18",{"title":987,"path":988,"stem":989,"date":990,"children":-1},"自建图床小记一——图床架构与 DNS 解析","/2024/08/12/new-picbed-based-on-cloudflare-and-upyun","posts/new-picbed-based-on-cloudflare-and-upyun","2024-08-12 17:07:11",1762982420330]