[{"data":1,"prerenderedAt":538},["ShallowReactive",2],{"post-2024-01-10-cors-when-using-splited-frontend-and-backend":3,"surround-2024-01-10-cors-when-using-splited-frontend-and-backend":527,"randomIndex/2024/01/10/cors-when-using-splited-frontend-and-backend/":445},{"id":4,"title":5,"body":6,"date":511,"description":512,"extension":513,"meta":514,"navigation":319,"path":515,"rawbody":516,"seo":517,"stem":518,"sticky":519,"tags":520,"__hash__":526},"posts/posts/cors-when-using-splited-frontend-and-backend.md","结合 Vue.js 与 php 完成的 web 期末大作业，讲讲前后端分离站点开发与部署中可能遇到的 CORS 跨域问题",{"type":7,"value":8,"toc":501},"minimark",[9,19,22,27,31,39,45,56,70,73,89,92,105,114,123,129,134,137,146,149,152,165,168,171,174,177,184,235,238,471,478,485,488,497],[10,11,12,13,18],"p",{},"在",[14,15,17],"a",{"href":16},"/2023/12/27/php-and-vuejs-project-deploy-on-caddy/","上一篇博客","中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。",[10,20,21],{},"在使用 Vue.js 开发前端界面时，我选择了使用 vite 脚手架帮助开发，这意味着我的作品将使用前后端分离的架构实现。因此在开发部署过程中均遇到了跨域的问题，故写下这篇博客记录下解决方案。",[23,24,26],"h2",{"id":25},"基于后端返回对应-http-响应头的解决方案","基于后端返回对应 http 响应头的解决方案",[28,29,30],"h3",{"id":30},"开发阶段",[10,32,33,34,38],{},"在我完成前后端的开发，并且经过 Apifox 的 mock 测试后，第一次在浏览器尝试前后端对接，遇到了 ",[35,36,37],"code",{},"CORS Missing Allow Origin"," 的报错。",[10,40,41],{},[42,43],"img",{"alt":37,"src":44},"https://static.031130.xyz/uploads/2024/08/12/659ec607c69af.webp",[10,46,47,48,51,52,55],{},"vite 启动的 dev 开发服务器使用的域是 ",[35,49,50],{},"http://localhost:5173"," ，而 php 后端我指定的是 ",[35,53,54],{},"http://127.0.0.1:8080"," ，前后端并不运行在一个域下，前端使用 Axios(AJAX) 向后端发送请求获取资源输入 CORS 跨域资源共享的范畴。",[10,57,58,59,65,66,69],{},"关于跨域资源共享 CORS 的相关内容，",[14,60,64],{"href":61,"rel":62},"https://www.ruanyifeng.com/blog/2016/04/cors.html",[63],"nofollow","阮一峰老师在 2016 年就已经在他的博客中有过解释","，看了下也是全网中文内容中解释得比较通俗易懂的，因此本文在这方面不过多做解释。错误的提示信息是 Missing Allow Origin，结合阮一峰老师的博文，我们应该在后端向前端发送的 http 响应头中添加 ",[35,67,68],{},"Access-Control-Allow-Origin"," 这一字段。",[10,71,72],{},"在一般的前后端分离项目（不涉及 cookie 等 Credentials 属性）中，我们可以将这一字段设置为 * 通配符，默认允许所有的域向自己发起跨域资源请求。php 可以通过下面这行代码很方便地进行设置:",[74,75,80],"pre",{"className":76,"code":77,"language":78,"meta":79,"style":79},"language-php shiki shiki-themes one-light one-dark-pro","header('Access-Control-Allow-Origin: *');\n","php","",[35,81,82],{"__ignoreMap":79},[83,84,87],"span",{"class":85,"line":86},"line",1,[83,88,77],{},[10,90,91],{},"但在用户的注册登录方面，我使用了 session 作为用户的登录凭据。阮一峰老师关于 CORS 的博文中有这样一句话:",[93,94,95],"blockquote",{},[10,96,97,98,100,101,104],{},"需要注意的是，如果要发送Cookie，",[35,99,68],{},"就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的",[35,102,103],{},"document.cookie","也无法读取服务器域名下的Cookie。",[10,106,107,108,110,111,113],{},"因此，我们必须明确指定 ",[35,109,68],{}," 字段为前端所使用的域，写上 ",[35,112,50],{}," 才行。",[74,115,117],{"className":76,"code":116,"language":78,"meta":79,"style":79},"header('Access-Control-Allow-Origin: http://localhost:5173');\n",[35,118,119],{"__ignoreMap":79},[83,120,121],{"class":85,"line":86},[83,122,116],{},[10,124,125,126],{},"再次刷新网页，获得了新的错误 ",[35,127,128],{},"CORS Missing Allow Credentials",[10,130,131],{},[42,132],{"alt":128,"src":133},"https://static.031130.xyz/uploads/2024/08/12/659ec95acc0bc.webp",[10,135,136],{},"这个问题处理起来也简单",[74,138,140],{"className":76,"code":139,"language":78,"meta":79,"style":79},"header('Access-Control-Allow-Credentials: true');\n",[35,141,142],{"__ignoreMap":79},[83,143,144],{"class":85,"line":86},[83,145,139],{},[10,147,148],{},"再次运行网页，跨域问题成功解决。",[28,150,151],{"id":151},"部署阶段",[10,153,154,155,157,158,161,162,164],{},"顺着这个思路进行下去，我们在部署阶段解决跨域问题需要做的事情很简单。提前将前端部署起来，将前端的域写到后端返回给前端的 http 相应头中即可。需要注意的是，",[35,156,68],{}," 字段仅允许填写一个值，如果需要同时允许来自多个不同域的跨域资源共享，后端部分需要根据前端发来的请求头中的 ",[35,159,160],{},"Origin"," 字段相应地设置响应头中的 ",[35,163,68],{}," 。当然，nginx 等先进的 static server 也支持劫持 http 请求，添加相关的 Access-Control 语句，也可以在这一层解决这个问题。",[23,166,167],{"id":167},"直接规避跨域的方案",[10,169,170],{},"上面通过后端返回带有 Access-Control 语句相应头的解决方案确实可以解决问题，却显得不够优雅。开发和部署阶段都要手动的去指定前端的域来允许跨域资源共享，这一点过于麻烦了，因此引出了下面的解决方案。",[28,172,30],{"id":173},"开发阶段-1",[10,175,176],{},"在 vite（或者其他同类开发服务器）的帮助下，我们可以使用前端的开发服务器去反向代理后端服务，也就是让前端的请求打到前端服务器上，由前端服务器去返回后端服务器返回的结果。",[10,178,179,180,183],{},"在 ",[35,181,182],{},"vite.config.ts"," 配置文件下，我将原本的",[74,185,189],{"className":186,"code":187,"language":188,"meta":79,"style":79},"language-typescript shiki shiki-themes one-light one-dark-pro","export default defineConfig({\n  plugins: [vue()],\n})\n","typescript",[35,190,191,209,229],{"__ignoreMap":79},[83,192,193,197,201,205],{"class":85,"line":86},[83,194,196],{"class":195},"sLKXg","export",[83,198,200],{"class":199},"sq3v1"," default",[83,202,204],{"class":203},"sAdtL"," defineConfig",[83,206,208],{"class":207},"s5ixo","({\n",[83,210,212,216,220,223,226],{"class":85,"line":211},2,[83,213,215],{"class":214},"sJa8x","  plugins",[83,217,219],{"class":218},"st7oF",":",[83,221,222],{"class":207}," [",[83,224,225],{"class":203},"vue",[83,227,228],{"class":207},"()],\n",[83,230,232],{"class":85,"line":231},3,[83,233,234],{"class":207},"})\n",[10,236,237],{},"换成了",[74,239,241],{"className":186,"code":240,"language":188,"meta":79,"style":79},"export default () => {\n  process.env = { ...process.env, ...loadEnv(process.cwd(),'') };\n\n  const config = {\n    plugins: [vue()],\n    server: {\n      proxy: {\n        '/api': {\n          target: http://127.0.0.1:8080,\n          changeOrigin: true,\n          secure: false,\n        }\n      }\n    }\n  }\n  return defineConfig(config)\n};\n",[35,242,243,258,315,321,335,349,359,369,379,396,412,425,431,437,443,449,465],{"__ignoreMap":79},[83,244,245,247,249,252,255],{"class":85,"line":86},[83,246,196],{"class":195},[83,248,200],{"class":199},[83,250,251],{"class":207}," () ",[83,253,254],{"class":195},"=>",[83,256,257],{"class":207}," {\n",[83,259,260,264,267,270,274,277,280,283,285,287,290,292,295,298,300,302,305,308,312],{"class":85,"line":211},[83,261,263],{"class":262},"s7GmK","  process",[83,265,266],{"class":207},".",[83,268,269],{"class":214},"env",[83,271,273],{"class":272},"s_Sar"," =",[83,275,276],{"class":207}," { ",[83,278,279],{"class":218},"...",[83,281,282],{"class":262},"process",[83,284,266],{"class":207},[83,286,269],{"class":214},[83,288,289],{"class":207},", ",[83,291,279],{"class":218},[83,293,294],{"class":203},"loadEnv",[83,296,297],{"class":207},"(",[83,299,282],{"class":262},[83,301,266],{"class":207},[83,303,304],{"class":203},"cwd",[83,306,307],{"class":207},"(),",[83,309,311],{"class":310},"sDhpE","''",[83,313,314],{"class":207},") };\n",[83,316,317],{"class":85,"line":231},[83,318,320],{"emptyLinePlaceholder":319},true,"\n",[83,322,324,327,331,333],{"class":85,"line":323},4,[83,325,326],{"class":195},"  const",[83,328,330],{"class":329},"sNmU0"," config",[83,332,273],{"class":272},[83,334,257],{"class":207},[83,336,338,341,343,345,347],{"class":85,"line":337},5,[83,339,340],{"class":214},"    plugins",[83,342,219],{"class":218},[83,344,222],{"class":207},[83,346,225],{"class":203},[83,348,228],{"class":207},[83,350,352,355,357],{"class":85,"line":351},6,[83,353,354],{"class":214},"    server",[83,356,219],{"class":218},[83,358,257],{"class":207},[83,360,362,365,367],{"class":85,"line":361},7,[83,363,364],{"class":214},"      proxy",[83,366,219],{"class":218},[83,368,257],{"class":207},[83,370,372,375,377],{"class":85,"line":371},8,[83,373,374],{"class":310},"        '/api'",[83,376,219],{"class":218},[83,378,257],{"class":207},[83,380,382,385,387,390,392],{"class":85,"line":381},9,[83,383,384],{"class":214},"          target",[83,386,219],{"class":218},[83,388,389],{"class":214}," http",[83,391,219],{"class":207},[83,393,395],{"class":394},"sW2Sy","//127.0.0.1:8080,\n",[83,397,399,402,405,409],{"class":85,"line":398},10,[83,400,401],{"class":214},"          changeOrigin",[83,403,404],{"class":207},": ",[83,406,408],{"class":407},"sAGMh","true",[83,410,411],{"class":207},",\n",[83,413,415,418,420,423],{"class":85,"line":414},11,[83,416,417],{"class":214},"          secure",[83,419,219],{"class":218},[83,421,422],{"class":407}," false",[83,424,411],{"class":207},[83,426,428],{"class":85,"line":427},12,[83,429,430],{"class":207},"        }\n",[83,432,434],{"class":85,"line":433},13,[83,435,436],{"class":207},"      }\n",[83,438,440],{"class":85,"line":439},14,[83,441,442],{"class":207},"    }\n",[83,444,446],{"class":85,"line":445},15,[83,447,448],{"class":207},"  }\n",[83,450,452,455,457,459,462],{"class":85,"line":451},16,[83,453,454],{"class":195},"  return",[83,456,204],{"class":203},[83,458,297],{"class":207},[83,460,461],{"class":214},"config",[83,463,464],{"class":207},")\n",[83,466,468],{"class":85,"line":467},17,[83,469,470],{"class":207},"};\n",[10,472,473,474,477],{},"同时将 Axios create 时的 ",[35,475,476],{},"baseURL"," 参数去除。",[10,479,480,481,484],{},"这样一套组合拳下来，将所有打向 ",[35,482,483],{},"/api*"," 的请求和响应通过前端的开发服务器作为中介做了中转，让浏览器以为并没有跨域（事实上也没有跨域），从而解决了相关的问题。",[28,486,151],{"id":487},"部署阶段-1",[10,489,490,491,496],{},"在开发阶段，我们通过 vite 的开发服务器做反向代理规避了跨域请求，但在部署阶段就用不了了。由于 vite 服务器的性能太弱，一般情况下我们是不会在生产环境中使用 vite 作为正式的服务器的，而是使用 vite build 出网站的静态网页资源，通过 nginx 等 static server 去向用户提供前端网页。而通过 vite build 出来的静态网页资源本身是不具备反向代理的能力的，这意味着没法在前端侧规避跨域问题。此时，我们应该配置 nginx 规避跨域问题。我一向不怎么使用 nginx，使用的是它的平替品 caddy，因此 nginx 的配置文件需要大家自行搜索，",[14,492,495],{"href":493,"rel":494},"https://zhul.in/2023/12/27/php-and-vuejs-project-deploy-on-caddy/#Caddy-%E9%85%8D%E7%BD%AE",[63],"我的 caddyfile 在上一篇博客中已经给出","，仅供参考。",[498,499,500],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .sLKXg, html code.shiki .sLKXg{--shiki-default:#A626A4;--shiki-dark:#C678DD}html pre.shiki code .sq3v1, html code.shiki .sq3v1{--shiki-default:#E45649;--shiki-dark:#C678DD}html pre.shiki code .sAdtL, html code.shiki .sAdtL{--shiki-default:#4078F2;--shiki-dark:#61AFEF}html pre.shiki code .s5ixo, html code.shiki .s5ixo{--shiki-default:#383A42;--shiki-dark:#ABB2BF}html pre.shiki code .sJa8x, html code.shiki .sJa8x{--shiki-default:#E45649;--shiki-dark:#E06C75}html pre.shiki code .st7oF, html code.shiki .st7oF{--shiki-default:#0184BC;--shiki-dark:#ABB2BF}html pre.shiki code .s7GmK, html code.shiki .s7GmK{--shiki-default:#383A42;--shiki-dark:#E5C07B}html pre.shiki code .s_Sar, html code.shiki .s_Sar{--shiki-default:#0184BC;--shiki-dark:#56B6C2}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html pre.shiki code .sNmU0, html code.shiki .sNmU0{--shiki-default:#986801;--shiki-dark:#E5C07B}html pre.shiki code .sW2Sy, html code.shiki .sW2Sy{--shiki-default:#A0A1A7;--shiki-default-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}",{"title":79,"searchDepth":211,"depth":211,"links":502},[503,507],{"id":25,"depth":211,"text":26,"children":504},[505,506],{"id":30,"depth":231,"text":30},{"id":151,"depth":231,"text":151},{"id":167,"depth":211,"text":167,"children":508},[509,510],{"id":173,"depth":231,"text":30},{"id":487,"depth":231,"text":151},"2024-01-10 23:55:36","在上一篇博客中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。","md",{},"/2024/01/10/cors-when-using-splited-frontend-and-backend","---\ntitle: 结合 Vue.js 与 php 完成的 web 期末大作业，讲讲前后端分离站点开发与部署中可能遇到的 CORS 跨域问题\ndate: 2024-01-10 23:55:36\nsticky:\ntags:\n- Vue.js\n- PHP\n- Network\n- 笔记\n- Web\n---\n\n在[上一篇博客](/2023/12/27/php-and-vuejs-project-deploy-on-caddy/)中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。\n\n在使用 Vue.js 开发前端界面时，我选择了使用 vite 脚手架帮助开发，这意味着我的作品将使用前后端分离的架构实现。因此在开发部署过程中均遇到了跨域的问题，故写下这篇博客记录下解决方案。\n\n## 基于后端返回对应 http 响应头的解决方案\n\n### 开发阶段\n\n在我完成前后端的开发，并且经过 Apifox 的 mock 测试后，第一次在浏览器尝试前后端对接，遇到了 `CORS Missing Allow Origin` 的报错。\n\n![CORS Missing Allow Origin](https://static.031130.xyz/uploads/2024/08/12/659ec607c69af.webp)\n\nvite 启动的 dev 开发服务器使用的域是 `http://localhost:5173` ，而 php 后端我指定的是 `http://127.0.0.1:8080` ，前后端并不运行在一个域下，前端使用 Axios(AJAX) 向后端发送请求获取资源输入 CORS 跨域资源共享的范畴。\n\n关于跨域资源共享 CORS 的相关内容，[阮一峰老师在 2016 年就已经在他的博客中有过解释](https://www.ruanyifeng.com/blog/2016/04/cors.html)，看了下也是全网中文内容中解释得比较通俗易懂的，因此本文在这方面不过多做解释。错误的提示信息是 Missing Allow Origin，结合阮一峰老师的博文，我们应该在后端向前端发送的 http 响应头中添加 `Access-Control-Allow-Origin` 这一字段。\n\n在一般的前后端分离项目（不涉及 cookie 等 Credentials 属性）中，我们可以将这一字段设置为 * 通配符，默认允许所有的域向自己发起跨域资源请求。php 可以通过下面这行代码很方便地进行设置:\n\n```php\nheader('Access-Control-Allow-Origin: *');\n```\n\n但在用户的注册登录方面，我使用了 session 作为用户的登录凭据。阮一峰老师关于 CORS 的博文中有这样一句话:\n\n> 需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。\n\n因此，我们必须明确指定 `Access-Control-Allow-Origin` 字段为前端所使用的域，写上 `http://localhost:5173` 才行。\n\n```php\nheader('Access-Control-Allow-Origin: http://localhost:5173');\n```\n\n再次刷新网页，获得了新的错误 `CORS Missing Allow Credentials`\n\n![CORS Missing Allow Credentials](https://static.031130.xyz/uploads/2024/08/12/659ec95acc0bc.webp)\n\n这个问题处理起来也简单\n\n```php\nheader('Access-Control-Allow-Credentials: true');\n```\n\n再次运行网页，跨域问题成功解决。\n\n### 部署阶段\n\n顺着这个思路进行下去，我们在部署阶段解决跨域问题需要做的事情很简单。提前将前端部署起来，将前端的域写到后端返回给前端的 http 相应头中即可。需要注意的是，`Access-Control-Allow-Origin` 字段仅允许填写一个值，如果需要同时允许来自多个不同域的跨域资源共享，后端部分需要根据前端发来的请求头中的 `Origin` 字段相应地设置响应头中的 `Access-Control-Allow-Origin` 。当然，nginx 等先进的 static server 也支持劫持 http 请求，添加相关的 Access-Control 语句，也可以在这一层解决这个问题。\n\n## 直接规避跨域的方案\n\n上面通过后端返回带有 Access-Control 语句相应头的解决方案确实可以解决问题，却显得不够优雅。开发和部署阶段都要手动的去指定前端的域来允许跨域资源共享，这一点过于麻烦了，因此引出了下面的解决方案。\n\n### 开发阶段\n\n在 vite（或者其他同类开发服务器）的帮助下，我们可以使用前端的开发服务器去反向代理后端服务，也就是让前端的请求打到前端服务器上，由前端服务器去返回后端服务器返回的结果。\n\n在 `vite.config.ts` 配置文件下，我将原本的\n\n```typescript\nexport default defineConfig({\n  plugins: [vue()],\n})\n```\n\n换成了\n\n```typescript\nexport default () => {\n  process.env = { ...process.env, ...loadEnv(process.cwd(),'') };\n\n  const config = {\n    plugins: [vue()],\n    server: {\n      proxy: {\n        '/api': {\n          target: http://127.0.0.1:8080,\n          changeOrigin: true,\n          secure: false,\n        }\n      }\n    }\n  }\n  return defineConfig(config)\n};\n```\n\n同时将 Axios create 时的 `baseURL` 参数去除。\n\n这样一套组合拳下来，将所有打向 `/api*` 的请求和响应通过前端的开发服务器作为中介做了中转，让浏览器以为并没有跨域（事实上也没有跨域），从而解决了相关的问题。\n\n### 部署阶段\n\n在开发阶段，我们通过 vite 的开发服务器做反向代理规避了跨域请求，但在部署阶段就用不了了。由于 vite 服务器的性能太弱，一般情况下我们是不会在生产环境中使用 vite 作为正式的服务器的，而是使用 vite build 出网站的静态网页资源，通过 nginx 等 static server 去向用户提供前端网页。而通过 vite build 出来的静态网页资源本身是不具备反向代理的能力的，这意味着没法在前端侧规避跨域问题。此时，我们应该配置 nginx 规避跨域问题。我一向不怎么使用 nginx，使用的是它的平替品 caddy，因此 nginx 的配置文件需要大家自行搜索，[我的 caddyfile 在上一篇博客中已经给出](https://zhul.in/2023/12/27/php-and-vuejs-project-deploy-on-caddy/#Caddy-%E9%85%8D%E7%BD%AE)，仅供参考。\n",{"title":5,"description":512},"posts/cors-when-using-splited-frontend-and-backend",false,[521,522,523,524,525],"Vue.js","PHP","Network","笔记","Web","rM7v-z8DVa7C4ywywlQEfoZZy0hlUdAJOwFfIBrSNro",[528,533],{"title":529,"path":530,"stem":531,"date":532,"children":-1},"在 JavaScript 中，箭头函数中的 this 指针到底指向哪里？","/2024/01/14/where-does-this-refer-in-arrow-function-in-js","posts/where-does-this-refer-in-arrow-function-in-js","2024-01-14 02:50:03",{"title":534,"path":535,"stem":536,"date":537,"children":-1},"vuejs、php、caddy 与 docker —— web 期末大作业上云部署","/2023/12/27/php-and-vuejs-project-deploy-on-caddy","posts/php-and-vuejs-project-deploy-on-caddy","2023-12-27 22:09:00",1761897607534]