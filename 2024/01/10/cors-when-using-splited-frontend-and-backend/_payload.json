[{"data":1,"prerenderedAt":481},["ShallowReactive",2],{"post-2024-01-10-cors-when-using-splited-frontend-and-backend":3,"surround-2024-01-10-cors-when-using-splited-frontend-and-backend":469,"randomIndex/2024/01/10/cors-when-using-splited-frontend-and-backend/":480},{"id":4,"title":5,"body":6,"date":453,"description":454,"extension":455,"meta":456,"navigation":291,"path":457,"rawbody":458,"seo":459,"stem":460,"sticky":461,"tags":462,"__hash__":468},"posts/posts/cors-when-using-splited-frontend-and-backend.md","结合 Vue.js 与 php 完成的 web 期末大作业，讲讲前后端分离站点开发与部署中可能遇到的 CORS 跨域问题",{"type":7,"value":8,"toc":443},"minimark",[9,19,22,27,31,39,45,56,70,73,89,92,105,114,123,129,134,137,146,149,152,165,168,171,174,177,184,226,229,413,420,427,430,439],[10,11,12,13,18],"p",{},"在",[14,15,17],"a",{"href":16},"/2023/12/27/php-and-vuejs-project-deploy-on-caddy/","上一篇博客","中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。",[10,20,21],{},"在使用 Vue.js 开发前端界面时，我选择了使用 vite 脚手架帮助开发，这意味着我的作品将使用前后端分离的架构实现。因此在开发部署过程中均遇到了跨域的问题，故写下这篇博客记录下解决方案。",[23,24,26],"h2",{"id":25},"基于后端返回对应-http-响应头的解决方案","基于后端返回对应 http 响应头的解决方案",[28,29,30],"h3",{"id":30},"开发阶段",[10,32,33,34,38],{},"在我完成前后端的开发，并且经过 Apifox 的 mock 测试后，第一次在浏览器尝试前后端对接，遇到了 ",[35,36,37],"code",{},"CORS Missing Allow Origin"," 的报错。",[10,40,41],{},[42,43],"img",{"alt":37,"src":44},"https://static.031130.xyz/uploads/2024/08/12/659ec607c69af.webp",[10,46,47,48,51,52,55],{},"vite 启动的 dev 开发服务器使用的域是 ",[35,49,50],{},"http://localhost:5173"," ，而 php 后端我指定的是 ",[35,53,54],{},"http://127.0.0.1:8080"," ，前后端并不运行在一个域下，前端使用 Axios(AJAX) 向后端发送请求获取资源输入 CORS 跨域资源共享的范畴。",[10,57,58,59,65,66,69],{},"关于跨域资源共享 CORS 的相关内容，",[14,60,64],{"href":61,"rel":62},"https://www.ruanyifeng.com/blog/2016/04/cors.html",[63],"nofollow","阮一峰老师在 2016 年就已经在他的博客中有过解释","，看了下也是全网中文内容中解释得比较通俗易懂的，因此本文在这方面不过多做解释。错误的提示信息是 Missing Allow Origin，结合阮一峰老师的博文，我们应该在后端向前端发送的 http 响应头中添加 ",[35,67,68],{},"Access-Control-Allow-Origin"," 这一字段。",[10,71,72],{},"在一般的前后端分离项目（不涉及 cookie 等 Credentials 属性）中，我们可以将这一字段设置为 * 通配符，默认允许所有的域向自己发起跨域资源请求。php 可以通过下面这行代码很方便地进行设置:",[74,75,80],"pre",{"className":76,"code":77,"language":78,"meta":79,"style":79},"language-php shiki shiki-themes github-light github-dark","header('Access-Control-Allow-Origin: *');\n","php","",[35,81,82],{"__ignoreMap":79},[83,84,87],"span",{"class":85,"line":86},"line",1,[83,88,77],{},[10,90,91],{},"但在用户的注册登录方面，我使用了 session 作为用户的登录凭据。阮一峰老师关于 CORS 的博文中有这样一句话:",[93,94,95],"blockquote",{},[10,96,97,98,100,101,104],{},"需要注意的是，如果要发送Cookie，",[35,99,68],{},"就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的",[35,102,103],{},"document.cookie","也无法读取服务器域名下的Cookie。",[10,106,107,108,110,111,113],{},"因此，我们必须明确指定 ",[35,109,68],{}," 字段为前端所使用的域，写上 ",[35,112,50],{}," 才行。",[74,115,117],{"className":76,"code":116,"language":78,"meta":79,"style":79},"header('Access-Control-Allow-Origin: http://localhost:5173');\n",[35,118,119],{"__ignoreMap":79},[83,120,121],{"class":85,"line":86},[83,122,116],{},[10,124,125,126],{},"再次刷新网页，获得了新的错误 ",[35,127,128],{},"CORS Missing Allow Credentials",[10,130,131],{},[42,132],{"alt":128,"src":133},"https://static.031130.xyz/uploads/2024/08/12/659ec95acc0bc.webp",[10,135,136],{},"这个问题处理起来也简单",[74,138,140],{"className":76,"code":139,"language":78,"meta":79,"style":79},"header('Access-Control-Allow-Credentials: true');\n",[35,141,142],{"__ignoreMap":79},[83,143,144],{"class":85,"line":86},[83,145,139],{},[10,147,148],{},"再次运行网页，跨域问题成功解决。",[28,150,151],{"id":151},"部署阶段",[10,153,154,155,157,158,161,162,164],{},"顺着这个思路进行下去，我们在部署阶段解决跨域问题需要做的事情很简单。提前将前端部署起来，将前端的域写到后端返回给前端的 http 相应头中即可。需要注意的是，",[35,156,68],{}," 字段仅允许填写一个值，如果需要同时允许来自多个不同域的跨域资源共享，后端部分需要根据前端发来的请求头中的 ",[35,159,160],{},"Origin"," 字段相应地设置响应头中的 ",[35,163,68],{}," 。当然，nginx 等先进的 static server 也支持劫持 http 请求，添加相关的 Access-Control 语句，也可以在这一层解决这个问题。",[23,166,167],{"id":167},"直接规避跨域的方案",[10,169,170],{},"上面通过后端返回带有 Access-Control 语句相应头的解决方案确实可以解决问题，却显得不够优雅。开发和部署阶段都要手动的去指定前端的域来允许跨域资源共享，这一点过于麻烦了，因此引出了下面的解决方案。",[28,172,30],{"id":173},"开发阶段-1",[10,175,176],{},"在 vite（或者其他同类开发服务器）的帮助下，我们可以使用前端的开发服务器去反向代理后端服务，也就是让前端的请求打到前端服务器上，由前端服务器去返回后端服务器返回的结果。",[10,178,179,180,183],{},"在 ",[35,181,182],{},"vite.config.ts"," 配置文件下，我将原本的",[74,185,189],{"className":186,"code":187,"language":188,"meta":79,"style":79},"language-typescript shiki shiki-themes github-light github-dark","export default defineConfig({\n  plugins: [vue()],\n})\n","typescript",[35,190,191,208,220],{"__ignoreMap":79},[83,192,193,197,200,204],{"class":85,"line":86},[83,194,196],{"class":195},"szBVR","export",[83,198,199],{"class":195}," default",[83,201,203],{"class":202},"sScJk"," defineConfig",[83,205,207],{"class":206},"sVt8B","({\n",[83,209,211,214,217],{"class":85,"line":210},2,[83,212,213],{"class":206},"  plugins: [",[83,215,216],{"class":202},"vue",[83,218,219],{"class":206},"()],\n",[83,221,223],{"class":85,"line":222},3,[83,224,225],{"class":206},"})\n",[10,227,228],{},"换成了",[74,230,232],{"className":186,"code":231,"language":188,"meta":79,"style":79},"export default () => {\n  process.env = { ...process.env, ...loadEnv(process.cwd(),'') };\n\n  const config = {\n    plugins: [vue()],\n    server: {\n      proxy: {\n        '/api': {\n          target: http://127.0.0.1:8080,\n          changeOrigin: true,\n          secure: false,\n        }\n      }\n    }\n  }\n  return defineConfig(config)\n};\n",[35,233,234,249,287,293,308,318,324,330,339,349,361,372,378,384,390,396,407],{"__ignoreMap":79},[83,235,236,238,240,243,246],{"class":85,"line":86},[83,237,196],{"class":195},[83,239,199],{"class":195},[83,241,242],{"class":206}," () ",[83,244,245],{"class":195},"=>",[83,247,248],{"class":206}," {\n",[83,250,251,254,257,260,263,266,268,271,274,277,280,284],{"class":85,"line":210},[83,252,253],{"class":206},"  process.env ",[83,255,256],{"class":195},"=",[83,258,259],{"class":206}," { ",[83,261,262],{"class":195},"...",[83,264,265],{"class":206},"process.env, ",[83,267,262],{"class":195},[83,269,270],{"class":202},"loadEnv",[83,272,273],{"class":206},"(process.",[83,275,276],{"class":202},"cwd",[83,278,279],{"class":206},"(),",[83,281,283],{"class":282},"sZZnC","''",[83,285,286],{"class":206},") };\n",[83,288,289],{"class":85,"line":222},[83,290,292],{"emptyLinePlaceholder":291},true,"\n",[83,294,296,299,303,306],{"class":85,"line":295},4,[83,297,298],{"class":195},"  const",[83,300,302],{"class":301},"sj4cs"," config",[83,304,305],{"class":195}," =",[83,307,248],{"class":206},[83,309,311,314,316],{"class":85,"line":310},5,[83,312,313],{"class":206},"    plugins: [",[83,315,216],{"class":202},[83,317,219],{"class":206},[83,319,321],{"class":85,"line":320},6,[83,322,323],{"class":206},"    server: {\n",[83,325,327],{"class":85,"line":326},7,[83,328,329],{"class":206},"      proxy: {\n",[83,331,333,336],{"class":85,"line":332},8,[83,334,335],{"class":282},"        '/api'",[83,337,338],{"class":206},": {\n",[83,340,342,345],{"class":85,"line":341},9,[83,343,344],{"class":206},"          target: http:",[83,346,348],{"class":347},"sJ8bj","//127.0.0.1:8080,\n",[83,350,352,355,358],{"class":85,"line":351},10,[83,353,354],{"class":206},"          changeOrigin: ",[83,356,357],{"class":301},"true",[83,359,360],{"class":206},",\n",[83,362,364,367,370],{"class":85,"line":363},11,[83,365,366],{"class":206},"          secure: ",[83,368,369],{"class":301},"false",[83,371,360],{"class":206},[83,373,375],{"class":85,"line":374},12,[83,376,377],{"class":206},"        }\n",[83,379,381],{"class":85,"line":380},13,[83,382,383],{"class":206},"      }\n",[83,385,387],{"class":85,"line":386},14,[83,388,389],{"class":206},"    }\n",[83,391,393],{"class":85,"line":392},15,[83,394,395],{"class":206},"  }\n",[83,397,399,402,404],{"class":85,"line":398},16,[83,400,401],{"class":195},"  return",[83,403,203],{"class":202},[83,405,406],{"class":206},"(config)\n",[83,408,410],{"class":85,"line":409},17,[83,411,412],{"class":206},"};\n",[10,414,415,416,419],{},"同时将 Axios create 时的 ",[35,417,418],{},"baseURL"," 参数去除。",[10,421,422,423,426],{},"这样一套组合拳下来，将所有打向 ",[35,424,425],{},"/api*"," 的请求和响应通过前端的开发服务器作为中介做了中转，让浏览器以为并没有跨域（事实上也没有跨域），从而解决了相关的问题。",[28,428,151],{"id":429},"部署阶段-1",[10,431,432,433,438],{},"在开发阶段，我们通过 vite 的开发服务器做反向代理规避了跨域请求，但在部署阶段就用不了了。由于 vite 服务器的性能太弱，一般情况下我们是不会在生产环境中使用 vite 作为正式的服务器的，而是使用 vite build 出网站的静态网页资源，通过 nginx 等 static server 去向用户提供前端网页。而通过 vite build 出来的静态网页资源本身是不具备反向代理的能力的，这意味着没法在前端侧规避跨域问题。此时，我们应该配置 nginx 规避跨域问题。我一向不怎么使用 nginx，使用的是它的平替品 caddy，因此 nginx 的配置文件需要大家自行搜索，",[14,434,437],{"href":435,"rel":436},"https://zhul.in/2023/12/27/php-and-vuejs-project-deploy-on-caddy/#Caddy-%E9%85%8D%E7%BD%AE",[63],"我的 caddyfile 在上一篇博客中已经给出","，仅供参考。",[440,441,442],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .szBVR, html code.shiki .szBVR{--shiki-default:#D73A49;--shiki-dark:#F97583}html pre.shiki code .sScJk, html code.shiki .sScJk{--shiki-default:#6F42C1;--shiki-dark:#B392F0}html pre.shiki code .sVt8B, html code.shiki .sVt8B{--shiki-default:#24292E;--shiki-dark:#E1E4E8}html pre.shiki code .sZZnC, html code.shiki .sZZnC{--shiki-default:#032F62;--shiki-dark:#9ECBFF}html pre.shiki code .sj4cs, html code.shiki .sj4cs{--shiki-default:#005CC5;--shiki-dark:#79B8FF}html pre.shiki code .sJ8bj, html code.shiki .sJ8bj{--shiki-default:#6A737D;--shiki-dark:#6A737D}",{"title":79,"searchDepth":210,"depth":210,"links":444},[445,449],{"id":25,"depth":210,"text":26,"children":446},[447,448],{"id":30,"depth":222,"text":30},{"id":151,"depth":222,"text":151},{"id":167,"depth":210,"text":167,"children":450},[451,452],{"id":173,"depth":222,"text":30},{"id":429,"depth":222,"text":151},"2024-01-10 23:55:36","在上一篇博客中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。","md",{},"/2024/01/10/cors-when-using-splited-frontend-and-backend","---\ntitle: 结合 Vue.js 与 php 完成的 web 期末大作业，讲讲前后端分离站点开发与部署中可能遇到的 CORS 跨域问题\ndate: 2024-01-10 23:55:36\nsticky:\ntags:\n- Vue.js\n- PHP\n- Network\n- 笔记\n- Web\n---\n\n在[上一篇博客](/2023/12/27/php-and-vuejs-project-deploy-on-caddy/)中，我讲到了 web 期末大作业的上云部署。整个项目是使用 Vue.js 作为前端，php 作为后端，mysql 作为数据库实现的。\n\n在使用 Vue.js 开发前端界面时，我选择了使用 vite 脚手架帮助开发，这意味着我的作品将使用前后端分离的架构实现。因此在开发部署过程中均遇到了跨域的问题，故写下这篇博客记录下解决方案。\n\n## 基于后端返回对应 http 响应头的解决方案\n\n### 开发阶段\n\n在我完成前后端的开发，并且经过 Apifox 的 mock 测试后，第一次在浏览器尝试前后端对接，遇到了 `CORS Missing Allow Origin` 的报错。\n\n![CORS Missing Allow Origin](https://static.031130.xyz/uploads/2024/08/12/659ec607c69af.webp)\n\nvite 启动的 dev 开发服务器使用的域是 `http://localhost:5173` ，而 php 后端我指定的是 `http://127.0.0.1:8080` ，前后端并不运行在一个域下，前端使用 Axios(AJAX) 向后端发送请求获取资源输入 CORS 跨域资源共享的范畴。\n\n关于跨域资源共享 CORS 的相关内容，[阮一峰老师在 2016 年就已经在他的博客中有过解释](https://www.ruanyifeng.com/blog/2016/04/cors.html)，看了下也是全网中文内容中解释得比较通俗易懂的，因此本文在这方面不过多做解释。错误的提示信息是 Missing Allow Origin，结合阮一峰老师的博文，我们应该在后端向前端发送的 http 响应头中添加 `Access-Control-Allow-Origin` 这一字段。\n\n在一般的前后端分离项目（不涉及 cookie 等 Credentials 属性）中，我们可以将这一字段设置为 * 通配符，默认允许所有的域向自己发起跨域资源请求。php 可以通过下面这行代码很方便地进行设置:\n\n```php\nheader('Access-Control-Allow-Origin: *');\n```\n\n但在用户的注册登录方面，我使用了 session 作为用户的登录凭据。阮一峰老师关于 CORS 的博文中有这样一句话:\n\n> 需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。\n\n因此，我们必须明确指定 `Access-Control-Allow-Origin` 字段为前端所使用的域，写上 `http://localhost:5173` 才行。\n\n```php\nheader('Access-Control-Allow-Origin: http://localhost:5173');\n```\n\n再次刷新网页，获得了新的错误 `CORS Missing Allow Credentials`\n\n![CORS Missing Allow Credentials](https://static.031130.xyz/uploads/2024/08/12/659ec95acc0bc.webp)\n\n这个问题处理起来也简单\n\n```php\nheader('Access-Control-Allow-Credentials: true');\n```\n\n再次运行网页，跨域问题成功解决。\n\n### 部署阶段\n\n顺着这个思路进行下去，我们在部署阶段解决跨域问题需要做的事情很简单。提前将前端部署起来，将前端的域写到后端返回给前端的 http 相应头中即可。需要注意的是，`Access-Control-Allow-Origin` 字段仅允许填写一个值，如果需要同时允许来自多个不同域的跨域资源共享，后端部分需要根据前端发来的请求头中的 `Origin` 字段相应地设置响应头中的 `Access-Control-Allow-Origin` 。当然，nginx 等先进的 static server 也支持劫持 http 请求，添加相关的 Access-Control 语句，也可以在这一层解决这个问题。\n\n## 直接规避跨域的方案\n\n上面通过后端返回带有 Access-Control 语句相应头的解决方案确实可以解决问题，却显得不够优雅。开发和部署阶段都要手动的去指定前端的域来允许跨域资源共享，这一点过于麻烦了，因此引出了下面的解决方案。\n\n### 开发阶段\n\n在 vite（或者其他同类开发服务器）的帮助下，我们可以使用前端的开发服务器去反向代理后端服务，也就是让前端的请求打到前端服务器上，由前端服务器去返回后端服务器返回的结果。\n\n在 `vite.config.ts` 配置文件下，我将原本的\n\n```typescript\nexport default defineConfig({\n  plugins: [vue()],\n})\n```\n\n换成了\n\n```typescript\nexport default () => {\n  process.env = { ...process.env, ...loadEnv(process.cwd(),'') };\n\n  const config = {\n    plugins: [vue()],\n    server: {\n      proxy: {\n        '/api': {\n          target: http://127.0.0.1:8080,\n          changeOrigin: true,\n          secure: false,\n        }\n      }\n    }\n  }\n  return defineConfig(config)\n};\n```\n\n同时将 Axios create 时的 `baseURL` 参数去除。\n\n这样一套组合拳下来，将所有打向 `/api*` 的请求和响应通过前端的开发服务器作为中介做了中转，让浏览器以为并没有跨域（事实上也没有跨域），从而解决了相关的问题。\n\n### 部署阶段\n\n在开发阶段，我们通过 vite 的开发服务器做反向代理规避了跨域请求，但在部署阶段就用不了了。由于 vite 服务器的性能太弱，一般情况下我们是不会在生产环境中使用 vite 作为正式的服务器的，而是使用 vite build 出网站的静态网页资源，通过 nginx 等 static server 去向用户提供前端网页。而通过 vite build 出来的静态网页资源本身是不具备反向代理的能力的，这意味着没法在前端侧规避跨域问题。此时，我们应该配置 nginx 规避跨域问题。我一向不怎么使用 nginx，使用的是它的平替品 caddy，因此 nginx 的配置文件需要大家自行搜索，[我的 caddyfile 在上一篇博客中已经给出](https://zhul.in/2023/12/27/php-and-vuejs-project-deploy-on-caddy/#Caddy-%E9%85%8D%E7%BD%AE)，仅供参考。\n",{"title":5,"description":454},"posts/cors-when-using-splited-frontend-and-backend",false,[463,464,465,466,467],"Vue.js","PHP","Network","笔记","Web","34qBxQ_n-W5A-Z5r05xmd5VP79RoxxyWLCoOCtnCQAA",[470,475],{"title":471,"path":472,"stem":473,"date":474,"children":-1},"在 JavaScript 中，箭头函数中的 this 指针到底指向哪里？","/2024/01/14/where-does-this-refer-in-arrow-function-in-js","posts/where-does-this-refer-in-arrow-function-in-js","2024-01-14 02:50:03",{"title":476,"path":477,"stem":478,"date":479,"children":-1},"vuejs、php、caddy 与 docker —— web 期末大作业上云部署","/2023/12/27/php-and-vuejs-project-deploy-on-caddy","posts/php-and-vuejs-project-deploy-on-caddy","2023-12-27 22:09:00",20,1761699272199]