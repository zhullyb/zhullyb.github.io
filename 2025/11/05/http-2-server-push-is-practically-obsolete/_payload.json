[{"data":1,"prerenderedAt":479},["ShallowReactive",2],{"post-2025-11-05-http-2-server-push-is-practically-obsolete-zh":3,"surround-2025-11-05-http-2-server-push-is-practically-obsolete-zh":466,"randomIndex/2025/11/05/http-2-server-push-is-practically-obsolete/":51,"language-switch-/2025/11/05/http-2-server-push-is-practically-obsolete/-en":478},{"title":4,"date":5,"path":6,"tags":7,"body":13,"description":19},"HTTP/2 Server Push 已事实性“死亡”，我很怀念它","2025-11-05","/2025/11/05/http-2-server-push-is-practically-obsolete",[8,9,10,11,12],"HTTP","Caddy","Network","HTML","Vercel",{"type":14,"value":15,"toc":455},"minimark",[16,20,25,38,121,128,181,192,198,201,204,207,252,265,268,271,279,288,296,299,302,307,310,313,316,326,341,345,352,366,372,376,379,384,387,390,393,404,407,410,451],[17,18,19],"p",{},"我最近一阵子在重构我的博客，恰巧之前一阵子准备秋招的时候背八股时看到了 HTTP/2 的服务端推送，于是便尝试在部署阶段为我的博客配置好 HTTP/2 的服务端推送，试图以此来进一步优化首屏加载速度。",[21,22,24],"h2",{"id":23},"http2-服务端推送为什么能提升首屏加载速度","HTTP/2 服务端推送为什么能提升首屏加载速度",[17,26,27,28,32,33,37],{},"如下图，在传统的 HTTP/1.1 中，浏览器会先下载 ",[29,30,31],"code",{},"index.html"," 并完成第一轮解析，然后再从解析出的数据中拿到 css/js 资源的 url，再进行第二轮请求，在 tcp/tls 连接建立后最小需要",[34,35,36],"strong",{},"两个 RTT 才能取回","完整渲染页面所需的资源。",[39,40,45],"pre",{"className":41,"code":42,"language":43,"meta":44,"style":44},"language-mermaid shiki shiki-themes one-light one-dark-pro","sequenceDiagram\n    participant Browser\n    participant Server\n\n    Browser->>Server: GET /index.html\n    Server-->>Browser: 200 OK + HTML\n    Browser->>Server: GET /style.css\n    Browser->>Server: GET /app.js\n    Server-->>Browser: 200 OK + CSS\n    Server-->>Browser: 200 OK + JS\n\n    Note over Browser: 浏览器必须等 HTML 下载并解析后\u003Cbr/>才能发起后续请求，增加往返延迟 (RTT)\n\n","mermaid","",[29,46,47,55,61,67,74,80,86,92,98,104,110,115],{"__ignoreMap":44},[48,49,52],"span",{"class":50,"line":51},"line",1,[48,53,54],{},"sequenceDiagram\n",[48,56,58],{"class":50,"line":57},2,[48,59,60],{},"    participant Browser\n",[48,62,64],{"class":50,"line":63},3,[48,65,66],{},"    participant Server\n",[48,68,70],{"class":50,"line":69},4,[48,71,73],{"emptyLinePlaceholder":72},true,"\n",[48,75,77],{"class":50,"line":76},5,[48,78,79],{},"    Browser->>Server: GET /index.html\n",[48,81,83],{"class":50,"line":82},6,[48,84,85],{},"    Server-->>Browser: 200 OK + HTML\n",[48,87,89],{"class":50,"line":88},7,[48,90,91],{},"    Browser->>Server: GET /style.css\n",[48,93,95],{"class":50,"line":94},8,[48,96,97],{},"    Browser->>Server: GET /app.js\n",[48,99,101],{"class":50,"line":100},9,[48,102,103],{},"    Server-->>Browser: 200 OK + CSS\n",[48,105,107],{"class":50,"line":106},10,[48,108,109],{},"    Server-->>Browser: 200 OK + JS\n",[48,111,113],{"class":50,"line":112},11,[48,114,73],{"emptyLinePlaceholder":72},[48,116,118],{"class":50,"line":117},12,[48,119,120],{},"    Note over Browser: 浏览器必须等 HTML 下载并解析后\u003Cbr/>才能发起后续请求，增加往返延迟 (RTT)\n",[17,122,123,124,127],{},"而在 HTTP/2 的设想中，流程则是像下面这张图一样。当浏览器请求 index.html 时，服务端可以顺带将 css/js 资源一起推送给客户端，这样在 tcp/tls 连接建立后最小只需要",[34,125,126],{},"一个 RTT 就可以","将页面渲染所需的资源取回。",[39,129,131],{"className":41,"code":130,"language":43,"meta":44,"style":44},"sequenceDiagram\n    participant Browser\n    participant Server\n\n    Browser->>Server: GET /index.html\n    Server-->>Browser: 200 OK + HTML\n    Server-->>Browser: PUSH_PROMISE /style.css\n    Server-->>Browser: PUSH_PROMISE /app.js\n    Server-->>Browser: (推送) style.css + app.js 内容\n\n    Note over Browser: 浏览器收到资源前置推送\u003Cbr/>减少请求轮次与首屏延迟\n\n",[29,132,133,137,141,145,149,153,157,162,167,172,176],{"__ignoreMap":44},[48,134,135],{"class":50,"line":51},[48,136,54],{},[48,138,139],{"class":50,"line":57},[48,140,60],{},[48,142,143],{"class":50,"line":63},[48,144,66],{},[48,146,147],{"class":50,"line":69},[48,148,73],{"emptyLinePlaceholder":72},[48,150,151],{"class":50,"line":76},[48,152,79],{},[48,154,155],{"class":50,"line":82},[48,156,85],{},[48,158,159],{"class":50,"line":88},[48,160,161],{},"    Server-->>Browser: PUSH_PROMISE /style.css\n",[48,163,164],{"class":50,"line":94},[48,165,166],{},"    Server-->>Browser: PUSH_PROMISE /app.js\n",[48,168,169],{"class":50,"line":100},[48,170,171],{},"    Server-->>Browser: (推送) style.css + app.js 内容\n",[48,173,174],{"class":50,"line":106},[48,175,73],{"emptyLinePlaceholder":72},[48,177,178],{"class":50,"line":112},[48,179,180],{},"    Note over Browser: 浏览器收到资源前置推送\u003Cbr/>减少请求轮次与首屏延迟\n",[17,182,183,184,191],{},"为了在 HTTP/1.1 中尽可能减少后续的请求，前端开发者尝试了非常多的优化手段，正如 Sukka 在《",[185,186,190],"a",{"href":187,"rel":188},"https://blog.skk.moe/post/http2-server-push/",[189],"nofollow","静态资源递送优化：HTTP/2 和 Server Push","》一文中所讲：",[193,194,195],"blockquote",{},[17,196,197],{},"关键资源、关键渲染路径、关键请求链的概念诞生已久，异步加载资源的概念可谓是老生常谈：懒加载图片、视频、iframe，乃至懒加载 CSS、JS、DOM，懒执行函数。但是，关键资源递送的思路却依然没有多少改变。",[17,199,200],{},"HTTP/2 的 Server Push 创造了新的资源递送思路，CSS/JS 等资源不用随着 html 一起递送也能在一个 RTT 内被传送到客户端，而这一部分资源可以被浏览器缓存起来，不被 html 那较短的 TTL 所限制。",[21,202,203],{"id":203},"初步方案",[17,205,206],{},"既然理清了 HTTP/2 服务端推送的优势，于是准备着手优化。我的博客是纯静态的，通过 DNS 进行境内外分流：境内流量会访问到 DMIT 一台带有 cmin2/9929 网络优化的 vps 上，通过 caddy 提供服务；境外流量则是直接打到 vercel，借助 Amazon 的 CDN 为全球网络提供边缘加速。网络架构大概是下面这个样子：",[39,208,210],{"className":41,"code":209,"language":43,"meta":44,"style":44},"graph TD\n    A[博客访客] --> B[发起DNS解析请求]\n    B --> C[DNSPod 服务]\n    C -->|境内访客：智能分流| D[网络优化 VPS]\n    C -->|境外访客：智能分流| E[Vercel 平台]\n    D --> F[Caddy]\n    F --> G[返回博客内容给境内访客]\n    E --> H[返回博客内容给境外访客]\n",[29,211,212,217,222,227,232,237,242,247],{"__ignoreMap":44},[48,213,214],{"class":50,"line":51},[48,215,216],{},"graph TD\n",[48,218,219],{"class":50,"line":57},[48,220,221],{},"    A[博客访客] --> B[发起DNS解析请求]\n",[48,223,224],{"class":50,"line":63},[48,225,226],{},"    B --> C[DNSPod 服务]\n",[48,228,229],{"class":50,"line":69},[48,230,231],{},"    C -->|境内访客：智能分流| D[网络优化 VPS]\n",[48,233,234],{"class":50,"line":76},[48,235,236],{},"    C -->|境外访客：智能分流| E[Vercel 平台]\n",[48,238,239],{"class":50,"line":82},[48,240,241],{},"    D --> F[Caddy]\n",[48,243,244],{"class":50,"line":88},[48,245,246],{},"    F --> G[返回博客内容给境内访客]\n",[48,248,249],{"class":50,"line":94},[48,250,251],{},"    E --> H[返回博客内容给境外访客]\n",[17,253,254,255,258,259,264],{},"Caddy 可以通过 ",[29,256,257],{},"http.handlers.push"," 模块实现 HTTP/2 的服务端推送，在 Caddyfile 中我们可以编写简单的推送逻辑，这没问题；vercel 平台则没有给开发者提供 HTTP/2 服务端推送的配置项，但好在我是静态博客，对平台依赖性不强，考虑迁移到 Cloudflare Workers，",[185,260,263],{"href":261,"rel":262},"https://brianli.com/cloudflare-workers-sites-http2-server-push/",[189],"五年前就有开发者实现了","。",[21,266,267],{"id":267},"客户端的支持情况",[17,269,270],{},"历史上主流浏览器引擎（Chrome/Chromium、Firefox、Edge、Safari）曾普遍支持服务器推送技术。",[17,272,273,274,264],{},"2020 年 11 月，谷歌宣布",[185,275,278],{"href":276,"rel":277},"https://groups.google.com/a/chromium.org/g/blink-dev/c/K3rYLvmQUBY/m/vOWBKZGoAQAJ",[189],"计划在其 Chrome 浏览器的 HTTP/2 及 gQUIC（后发展为HTTP/3）实现中移除服务器推送功能",[17,280,281,282,287],{},"2022 年 10 月，谷歌宣布",[185,283,286],{"href":284,"rel":285},"https://developer.chrome.com/blog/removing-push/",[189],"计划从Chrome浏览器中移除服务器推送功能","，指出该扩展在实际应用中性能不佳、使用率低且存在更优替代方案。Chrome 106 成为首个默认禁用服务器推送的版本。",[17,289,290,291],{},"2024 年 10 月 29 日，Mozilla 发布了 Firefox 132版本，",[185,292,295],{"href":293,"rel":294},"https://www.firefox.com/en-US/firefox/132.0/releasenotes/",[189],"因“与多个网站存在兼容性问题”移除了对HTTP/2服务器推送功能的支持。",[17,297,298],{},"至此，主流浏览器对 HTTP/2 服务端推送（Server Push）的支持已全部终结。从最初被视为“减少往返延迟、优化首屏加载”的创新特性，到最终被全面弃用，HTTP/2 推送的生命周期不过短短数年，成为 Web 性能优化历史上的一次重要实验。",[21,300,301],{"id":301},"替代方案",[303,304,306],"h3",{"id":305},"_1-http-103-early-hints","1. HTTP 103 Early Hints",[17,308,309],{},"103 Early Hints 是对服务端推送最直接的“继任者”。它是一个信息性的 HTTP 状态码 (Informational Response)，允许服务器在生成完整的 HTML 响应（例如，状态码为 200 OK）之前，先发送一个带有 Link 头部的“早期提示”响应。",[17,311,312],{},"这个 Link 头部可以告诉浏览器：“嘿，我还在准备主菜（HTML），但你可以先去把配菜（CSS、JS）准备好”。这样，浏览器就能利用服务器的“思考时间”提前开始下载关键资源或预热到所需源的连接，从而显著缩短首屏渲染时间。",[17,314,315],{},"与服务端推送的对比：",[317,318,319,323],"ul",{},[320,321,322],"li",{},"决策权在客户端：Early Hints 只是“提示”，浏览器可以根据自身缓存情况、网络状况等因素决定是否采纳该提示。这就解决了服务端推送最大的痛点——服务器无法知晓客户端缓存而导致推送冗余资源。",[320,324,325],{},"兼容性更好：它是一种更轻量、更易于中间代理服务器理解和传递的机制。",[17,327,328,329,332,333,336,337,340],{},"103 Early Hints 对动态博客很有意义，在后端进行计算之前先把需要的资源通过 103 响应告知浏览器，让浏览器先取回其他资源，再等待后端返回最终的 html；而",[34,330,331],{},"对于","我这种产物都是预构建好的",[34,334,335],{},"静态博客","，完全",[34,338,339],{},"没有任何意义","，网关有那个发 103 响应的闲工夫完全可以把 html 直接发过去了。",[303,342,344],{"id":343},"_2-资源提示resource-hints-preload-prefetch","2. 资源提示（Resource Hints）: Preload & Prefetch",[17,346,347,348,351],{},"早在服务端推送被弃用前，通过 ",[29,349,350],{},"\u003Clink>","标签实现的资源提示就已经是前端性能优化的常用手段。它们将资源加载的提示声明在 HTML 中，由浏览器主导整个过程。",[317,353,354,360],{},[320,355,356,359],{},[29,357,358],{},"\u003Clink rel=\"preload\">",": 用于告诉浏览器当前页面必定会用到的资源，请以高优先级立即开始加载，但加载后不执行。比如，隐藏在 CSS 深处的字体文件或由 JS 动态加载的首屏图片。通过 Preload，可以确保这些关键资源能尽早被发现和下载，避免渲染阻塞。",[320,361,362,365],{},[29,363,364],{},"\u003Clink rel=\"prefetch\">",": 用于告诉浏览器用户在未来可能访问的页面或用到的资源，请在浏览器空闲时以低优先级在后台下载。例如，在文章列表页 prefetch 用户最可能点击的文章页面的资源，从而实现近乎“秒开”的跳转体验。",[17,367,368,369,264],{},"Preload 和 Prefetch 将资源加载的控制权完全交给了开发者和浏览器，通过声明式的方式精细化管理资源加载的优先级和时机，是目前最成熟、应用最广泛的资源预加载方案，但仍然",[34,370,371],{},"逃不过 2 RTT 的魔咒",[21,373,375],{"id":374},"尾声写给一个理想主义者的挽歌","尾声：写给一个理想主义者的挽歌",[17,377,378],{},"写到最后，我终究是没能为我的博客配上 HTTP/2 服务端推送。",[17,380,381],{},[34,382,383],{},"HTTP/2 Server Push 已事实性“死亡”，我很怀念它。",[17,385,386],{},"在一个理想模型里，当浏览器请求 HTML 时，服务器顺手将渲染所需的 CSS 和 JS  一并推来，将原本至少两次的往返（RTT）干脆利落地压缩为一次。这是一个如此直接、如此漂亮的解决方案，几乎是前端工程师面对首屏渲染延迟问题时梦寐以求的“银弹”。它背后蕴含的是一种雄心勃勃的魄力：试图由服务端一次性地、彻底地解决“关键请求链”的延迟问题。",[17,388,389],{},"但 Web 的世界终究不是一个理想的实验室。它充满了缓存、重复访问的用户、以及形形色色的网络环境。",[17,391,392],{},"服务端推送最大的魅力，在于它的“主动”，而它最大的遗憾，也恰恰源于这份“主动”。它无法知晓浏览器缓存中是否早已静静躺着那个它正准备满腔热情推送的 style.css 文件。为了那一小部分首次访问用户的极致体验，却可能要以浪费更多再次访问用户的宝贵带宽为代价。",[17,394,395,396,399,400,403],{},"Web 的演进最终选择了一条更稳妥、更具协作精神的道路。它将决策权交还给了最了解情况的浏览器，整个交互从服务器的“",[34,397,398],{},"我推送给你","”，变成了服务器的“",[34,401,402],{},"我建议你拿","”，再由浏览器自己定夺。这或许不够浪漫，不够极致，但它更普适，也更健壮。",[17,405,406],{},"所以，我依然会怀念那个雄心勃勃的 Server Push。它代表了一种对极致性能的纯粹追求，一种美好的技术理想主义。尽管它已悄然淡出历史舞台，但它所指向的那个关于“速度”的梦想，早已被 103 Early Hints 和 preload 以一种更成熟、更懂得权衡的方式继承了下来。",[21,408,409],{"id":409},"参见",[317,411,412,419,426,432,439,445],{},[320,413,414],{},[185,415,418],{"href":416,"rel":417},"https://developer.chrome.com/blog/removing-push",[189],"Remove HTTP/2 Server Push from Chrome  |  Blog  |  Chrome for Developers",[320,420,421],{},[185,422,425],{"href":423,"rel":424},"https://en.wikipedia.org/wiki/HTTP/2_Server_Push",[189],"HTTP/2 Server Push - Wikipedia",[320,427,428],{},[185,429,431],{"href":187,"rel":430},[189],"静态资源递送优化：HTTP/2 和 Server Push | Sukka's Blog",[320,433,434],{},[185,435,438],{"href":436,"rel":437},"https://caddyserver.com/docs/modules/http.handlers.push",[189],"Module http.handlers.push - Caddy Documentation",[320,440,441],{},[185,442,444],{"href":261,"rel":443},[189],"How to Configure HTTP/2 Server Push on Cloudflare Workers Sites",[320,446,447],{},[185,448,450],{"href":276,"rel":449},[189],"Intent to Remove: HTTP/2 and gQUIC server push",[452,453,454],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}",{"title":44,"searchDepth":57,"depth":57,"links":456},[457,458,459,460,464,465],{"id":23,"depth":57,"text":24},{"id":203,"depth":57,"text":203},{"id":267,"depth":57,"text":267},{"id":301,"depth":57,"text":301,"children":461},[462,463],{"id":305,"depth":63,"text":306},{"id":343,"depth":63,"text":344},{"id":374,"depth":57,"text":375},{"id":409,"depth":57,"text":409},[467,473],{"title":468,"path":469,"stem":470,"date":471,"lang":472,"children":-1},"DNS 冷启动：小型站点的“西西弗斯之石”","/2025/11/11/dns-cold-start-dilemma","posts/zh/dns-cold-start-dilemma","2025-11-11","zh-CN",{"title":474,"path":475,"stem":476,"date":477,"lang":472,"children":-1},"Nuxt Content v3 中数组字段的筛选困境与性能优化","/2025/10/20/nuxt-content-v3-z-array-query-challenge","posts/zh/nuxt-content-v3-z-array-query-challenge","2025-10-20 21:52:59","/en/2025/11/05/http-2-server-push-is-practically-obsolete/",1771555473363]