[{"data":1,"prerenderedAt":1369},["ShallowReactive",2],{"post-2025-07-12-vue-markdown-render-improvement-1":3,"surround-2025-07-12-vue-markdown-render-improvement-1":1358,"randomIndex/2025/07/12/vue-markdown-render-improvement-1/":142},{"id":4,"title":5,"body":6,"date":1343,"description":77,"extension":1344,"meta":1345,"navigation":138,"path":1346,"rawbody":1347,"seo":1348,"stem":1349,"sticky":1350,"tags":1351,"__hash__":1357},"posts/posts/vue-markdown-render-improvement-1.md","Vue Markdown 渲染优化实战(上)：从暴力刷新、分块更新到 Morphdom 的华丽变身",{"type":7,"value":8,"toc":1332},"minimark",[9,13,17,46,50,53,56,68,71,309,313,320,334,347,356,359,855,859,862,867,877,884,895,905,908,911,1282,1286,1289,1295,1301,1307,1310,1316,1322,1328],[10,11,12],"h2",{"id":12},"需求背景",[14,15,16],"p",{},"在最近接手的 AI 需求中，需要实现一个类似 ChatGPT 的对话交互界面。其核心流程是：后端通过 SSE（Server-Sent  Events）协议，持续地将 AI 生成的 Markdown 格式文本片段推送到前端。前端负责动态接收并拼接这些 Markdown  片段，最终将拼接完成的 Markdown 文本实时渲染并显示在用户界面上。",[14,18,19,20,27,28,33,34,39,40,45],{},"Markdown 渲染并不是什么罕见的需求，尤其是在 LLM 相关落地产品满天飞的当下。不同于 React 生态拥有一个 14k+ star 的著名第三方库——",[21,22,26],"a",{"href":23,"rel":24},"https://github.com/remarkjs/react-markdown",[25],"nofollow","react-markdown","，Vue 这边似乎暂时还没有一个仍在活跃维护的、star 数量不低（起码得 2k+ 吧？）的 markdown 渲染库。",[21,29,32],{"href":30,"rel":31},"https://github.com/cloudacy/vue-markdown-render#readme",[25],"cloudacy/vue-markdown-render"," 最后一次发版在一年前，但截止本文写作时间只有 103 个 star；",[21,35,38],{"href":36,"rel":37},"https://github.com/miaolz123/vue-markdown",[25],"miaolz123/vue-markdown"," 有 2k star，但最后一次 commit 已经是 7 年前了；",[21,41,44],{"href":42,"rel":43},"https://github.com/zhaoxuhui1122/vue-markdown",[25],"zhaoxuhui1122/vue-markdown"," 更是 archived 状态。",[10,47,49],{"id":48},"第一版方案简单粗暴的-v-html","第一版方案：简单粗暴的 v-html",[14,51,52],{},"简单调研了一圈，发现 Vue 生态里确实缺少一个能打的 Markdown 渲染库。既然没有现成的轮子，那咱就自己造一个！",[14,54,55],{},"根据大部分文章以及 LLM 的推荐，我们首先采用 markdown-it 这个第三方库将 markdown 转换为 html 字符串，再通过 v-html 传入。",[14,57,58,62,63,67],{},[59,60,61],"strong",{},"PS:"," 我们这里假设 Markdown 内容是可信的（比如由我们自己的 AI 生成）。如果内容来自用户输入，一定要使用 ",[64,65,66],"code",{},"DOMPurify"," 这类库来防止 XSS 攻击，避免给网站“开天窗”哦！",[14,69,70],{},"示例代码如下：",[72,73,78],"pre",{"className":74,"code":75,"language":76,"meta":77,"style":77},"language-vue shiki shiki-themes github-light github-dark","\u003Ctemplate>\n  \u003Cdiv v-html=\"renderedHtml\">\u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { computed, onMounted, ref } from 'vue';\nimport MarkdownIt from 'markdown-it';\n\nconst markdownContent = ref('');\nconst md = new MarkdownIt();\n\nconst renderedHtml = computed(() => md.render(markdownContent.value))\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n","vue","",[64,79,80,96,123,133,140,153,172,187,192,217,236,241,269,274,287,294,300],{"__ignoreMap":77},[81,82,85,89,93],"span",{"class":83,"line":84},"line",1,[81,86,88],{"class":87},"sVt8B","\u003C",[81,90,92],{"class":91},"s9eBZ","template",[81,94,95],{"class":87},">\n",[81,97,99,102,105,109,112,116,119,121],{"class":83,"line":98},2,[81,100,101],{"class":87},"  \u003C",[81,103,104],{"class":91},"div",[81,106,108],{"class":107},"sScJk"," v-html",[81,110,111],{"class":87},"=",[81,113,115],{"class":114},"sZZnC","\"renderedHtml\"",[81,117,118],{"class":87},">\u003C/",[81,120,104],{"class":91},[81,122,95],{"class":87},[81,124,126,129,131],{"class":83,"line":125},3,[81,127,128],{"class":87},"\u003C/",[81,130,92],{"class":91},[81,132,95],{"class":87},[81,134,136],{"class":83,"line":135},4,[81,137,139],{"emptyLinePlaceholder":138},true,"\n",[81,141,143,145,148,151],{"class":83,"line":142},5,[81,144,88],{"class":87},[81,146,147],{"class":91},"script",[81,149,150],{"class":107}," setup",[81,152,95],{"class":87},[81,154,156,160,163,166,169],{"class":83,"line":155},6,[81,157,159],{"class":158},"szBVR","import",[81,161,162],{"class":87}," { computed, onMounted, ref } ",[81,164,165],{"class":158},"from",[81,167,168],{"class":114}," 'vue'",[81,170,171],{"class":87},";\n",[81,173,175,177,180,182,185],{"class":83,"line":174},7,[81,176,159],{"class":158},[81,178,179],{"class":87}," MarkdownIt ",[81,181,165],{"class":158},[81,183,184],{"class":114}," 'markdown-it'",[81,186,171],{"class":87},[81,188,190],{"class":83,"line":189},8,[81,191,139],{"emptyLinePlaceholder":138},[81,193,195,198,202,205,208,211,214],{"class":83,"line":194},9,[81,196,197],{"class":158},"const",[81,199,201],{"class":200},"sj4cs"," markdownContent",[81,203,204],{"class":158}," =",[81,206,207],{"class":107}," ref",[81,209,210],{"class":87},"(",[81,212,213],{"class":114},"''",[81,215,216],{"class":87},");\n",[81,218,220,222,225,227,230,233],{"class":83,"line":219},10,[81,221,197],{"class":158},[81,223,224],{"class":200}," md",[81,226,204],{"class":158},[81,228,229],{"class":158}," new",[81,231,232],{"class":107}," MarkdownIt",[81,234,235],{"class":87},"();\n",[81,237,239],{"class":83,"line":238},11,[81,240,139],{"emptyLinePlaceholder":138},[81,242,244,246,249,251,254,257,260,263,266],{"class":83,"line":243},12,[81,245,197],{"class":158},[81,247,248],{"class":200}," renderedHtml",[81,250,204],{"class":158},[81,252,253],{"class":107}," computed",[81,255,256],{"class":87},"(() ",[81,258,259],{"class":158},"=>",[81,261,262],{"class":87}," md.",[81,264,265],{"class":107},"render",[81,267,268],{"class":87},"(markdownContent.value))\n",[81,270,272],{"class":83,"line":271},13,[81,273,139],{"emptyLinePlaceholder":138},[81,275,277,280,282,284],{"class":83,"line":276},14,[81,278,279],{"class":107},"onMounted",[81,281,256],{"class":87},[81,283,259],{"class":158},[81,285,286],{"class":87}," {\n",[81,288,290],{"class":83,"line":289},15,[81,291,293],{"class":292},"sJ8bj","  // markdownContent.value = await fetch() ...\n",[81,295,297],{"class":83,"line":296},16,[81,298,299],{"class":87},"})\n",[81,301,303,305,307],{"class":83,"line":302},17,[81,304,128],{"class":87},[81,306,147],{"class":91},[81,308,95],{"class":87},[10,310,312],{"id":311},"进化版给-markdown-分块更新","进化版：给 Markdown 分块更新",[14,314,315,316,319],{},"上述方案虽然能实现基础渲染，但在实时更新场景下存在明显缺陷：",[59,317,318],{},"每次接收到新的 Markdown 片段，整个文档都会触发全量重渲染","。即使只有最后一行是新增内容，整个文档的 DOM 也会被完全替换。这导致两个核心问题：",[321,322,323,331],"ol",{},[324,325,326,327,330],"li",{},"**性能顶不住：**Markdown 内容增长时，",[64,328,329],{},"markdown-it"," 解析和 DOM 重建的开销呈线性上升。",[324,332,333],{},"**交互状态丢失：**全量刷新会把用户当前的操作状态冲掉。最明显的就是，如果你选中了某段文字，一刷新，选中状态就没了！",[14,335,336,337,342,343,346],{},"为了解决这两个问题，",[21,338,341],{"href":339,"rel":340},"https://juejin.cn/post/7480900772386734143",[25],"我们在网上找到了分块渲染的方案"," —— 把 Markdown 按两个连续的换行符 (",[64,344,345],{},"\\n\\n",") 切成一块一块的。这样每次更新，只重新渲染最后一块新的，前面的老块直接复用缓存。好处很明显：",[348,349,350,353],"ul",{},[324,351,352],{},"用户如果选中了前面块里的文字，下次更新时选中状态不会丢（因为前面的块没动）。",[324,354,355],{},"需要重新渲染的 DOM 变少了，性能自然就上来了。",[14,357,358],{},"代码调整后像这样：",[72,360,362],{"className":74,"code":361,"language":76,"meta":77,"style":77},"\u003Ctemplate>\n  \u003Cdiv>\n    \u003Cdiv\n      v-for=\"(block, idx) in renderedBlocks\"\n      :key=\"idx\"\n      v-html=\"block\"\n      class=\"markdown-block\"\n    >\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { ref, computed, watch } from 'vue'\nimport MarkdownIt from 'markdown-it'\n\nconst markdownContent = ref('')\nconst md = new MarkdownIt()\n\nconst renderedBlocks = ref([])\nconst blockCache = ref([])\n\nwatch(\n  markdownContent,\n  (newContent, oldContent) => {\n    const blocks = newContent.split(/\\n{2,}/)\n    // 只重新渲染最后一个块，其余用缓存\n    // 处理块减少、块增多的场景\n    blockCache.value.length = blocks.length\n    for (let i = 0; i \u003C blocks.length; i++) {\n      // 只渲染最后一个，或新块\n      if (i === blocks.length - 1 || !blockCache.value[i]) {\n        blockCache.value[i] = md.render(blocks[i] || '')\n      }\n      // 其余块直接复用\n    }\n    renderedBlocks.value = blockCache.value.slice()\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n",[64,363,364,372,380,388,398,408,418,428,437,446,454,458,468,480,491,495,512,527,532,547,561,566,575,581,604,636,642,648,665,703,709,740,763,769,775,781,797,803,815,820,825,836,841,846],{"__ignoreMap":77},[81,365,366,368,370],{"class":83,"line":84},[81,367,88],{"class":87},[81,369,92],{"class":91},[81,371,95],{"class":87},[81,373,374,376,378],{"class":83,"line":98},[81,375,101],{"class":87},[81,377,104],{"class":91},[81,379,95],{"class":87},[81,381,382,385],{"class":83,"line":125},[81,383,384],{"class":87},"    \u003C",[81,386,387],{"class":91},"div\n",[81,389,390,393,395],{"class":83,"line":135},[81,391,392],{"class":107},"      v-for",[81,394,111],{"class":87},[81,396,397],{"class":114},"\"(block, idx) in renderedBlocks\"\n",[81,399,400,403,405],{"class":83,"line":142},[81,401,402],{"class":107},"      :key",[81,404,111],{"class":87},[81,406,407],{"class":114},"\"idx\"\n",[81,409,410,413,415],{"class":83,"line":155},[81,411,412],{"class":107},"      v-html",[81,414,111],{"class":87},[81,416,417],{"class":114},"\"block\"\n",[81,419,420,423,425],{"class":83,"line":174},[81,421,422],{"class":107},"      class",[81,424,111],{"class":87},[81,426,427],{"class":114},"\"markdown-block\"\n",[81,429,430,433,435],{"class":83,"line":189},[81,431,432],{"class":87},"    >\u003C/",[81,434,104],{"class":91},[81,436,95],{"class":87},[81,438,439,442,444],{"class":83,"line":194},[81,440,441],{"class":87},"  \u003C/",[81,443,104],{"class":91},[81,445,95],{"class":87},[81,447,448,450,452],{"class":83,"line":219},[81,449,128],{"class":87},[81,451,92],{"class":91},[81,453,95],{"class":87},[81,455,456],{"class":83,"line":238},[81,457,139],{"emptyLinePlaceholder":138},[81,459,460,462,464,466],{"class":83,"line":243},[81,461,88],{"class":87},[81,463,147],{"class":91},[81,465,150],{"class":107},[81,467,95],{"class":87},[81,469,470,472,475,477],{"class":83,"line":271},[81,471,159],{"class":158},[81,473,474],{"class":87}," { ref, computed, watch } ",[81,476,165],{"class":158},[81,478,479],{"class":114}," 'vue'\n",[81,481,482,484,486,488],{"class":83,"line":276},[81,483,159],{"class":158},[81,485,179],{"class":87},[81,487,165],{"class":158},[81,489,490],{"class":114}," 'markdown-it'\n",[81,492,493],{"class":83,"line":289},[81,494,139],{"emptyLinePlaceholder":138},[81,496,497,499,501,503,505,507,509],{"class":83,"line":296},[81,498,197],{"class":158},[81,500,201],{"class":200},[81,502,204],{"class":158},[81,504,207],{"class":107},[81,506,210],{"class":87},[81,508,213],{"class":114},[81,510,511],{"class":87},")\n",[81,513,514,516,518,520,522,524],{"class":83,"line":302},[81,515,197],{"class":158},[81,517,224],{"class":200},[81,519,204],{"class":158},[81,521,229],{"class":158},[81,523,232],{"class":107},[81,525,526],{"class":87},"()\n",[81,528,530],{"class":83,"line":529},18,[81,531,139],{"emptyLinePlaceholder":138},[81,533,535,537,540,542,544],{"class":83,"line":534},19,[81,536,197],{"class":158},[81,538,539],{"class":200}," renderedBlocks",[81,541,204],{"class":158},[81,543,207],{"class":107},[81,545,546],{"class":87},"([])\n",[81,548,550,552,555,557,559],{"class":83,"line":549},20,[81,551,197],{"class":158},[81,553,554],{"class":200}," blockCache",[81,556,204],{"class":158},[81,558,207],{"class":107},[81,560,546],{"class":87},[81,562,564],{"class":83,"line":563},21,[81,565,139],{"emptyLinePlaceholder":138},[81,567,569,572],{"class":83,"line":568},22,[81,570,571],{"class":107},"watch",[81,573,574],{"class":87},"(\n",[81,576,578],{"class":83,"line":577},23,[81,579,580],{"class":87},"  markdownContent,\n",[81,582,584,587,591,594,597,600,602],{"class":83,"line":583},24,[81,585,586],{"class":87},"  (",[81,588,590],{"class":589},"s4XuR","newContent",[81,592,593],{"class":87},", ",[81,595,596],{"class":589},"oldContent",[81,598,599],{"class":87},") ",[81,601,259],{"class":158},[81,603,286],{"class":87},[81,605,607,610,613,615,618,621,623,626,629,632,634],{"class":83,"line":606},25,[81,608,609],{"class":158},"    const",[81,611,612],{"class":200}," blocks",[81,614,204],{"class":158},[81,616,617],{"class":87}," newContent.",[81,619,620],{"class":107},"split",[81,622,210],{"class":87},[81,624,625],{"class":114},"/",[81,627,628],{"class":200},"\\n",[81,630,631],{"class":158},"{2,}",[81,633,625],{"class":114},[81,635,511],{"class":87},[81,637,639],{"class":83,"line":638},26,[81,640,641],{"class":292},"    // 只重新渲染最后一个块，其余用缓存\n",[81,643,645],{"class":83,"line":644},27,[81,646,647],{"class":292},"    // 处理块减少、块增多的场景\n",[81,649,651,654,657,659,662],{"class":83,"line":650},28,[81,652,653],{"class":87},"    blockCache.value.",[81,655,656],{"class":200},"length",[81,658,204],{"class":158},[81,660,661],{"class":87}," blocks.",[81,663,664],{"class":200},"length\n",[81,666,668,671,674,677,680,682,685,688,690,692,694,697,700],{"class":83,"line":667},29,[81,669,670],{"class":158},"    for",[81,672,673],{"class":87}," (",[81,675,676],{"class":158},"let",[81,678,679],{"class":87}," i ",[81,681,111],{"class":158},[81,683,684],{"class":200}," 0",[81,686,687],{"class":87},"; i ",[81,689,88],{"class":158},[81,691,661],{"class":87},[81,693,656],{"class":200},[81,695,696],{"class":87},"; i",[81,698,699],{"class":158},"++",[81,701,702],{"class":87},") {\n",[81,704,706],{"class":83,"line":705},30,[81,707,708],{"class":292},"      // 只渲染最后一个，或新块\n",[81,710,712,715,718,721,723,725,728,731,734,737],{"class":83,"line":711},31,[81,713,714],{"class":158},"      if",[81,716,717],{"class":87}," (i ",[81,719,720],{"class":158},"===",[81,722,661],{"class":87},[81,724,656],{"class":200},[81,726,727],{"class":158}," -",[81,729,730],{"class":200}," 1",[81,732,733],{"class":158}," ||",[81,735,736],{"class":158}," !",[81,738,739],{"class":87},"blockCache.value[i]) {\n",[81,741,743,746,748,750,752,755,758,761],{"class":83,"line":742},32,[81,744,745],{"class":87},"        blockCache.value[i] ",[81,747,111],{"class":158},[81,749,262],{"class":87},[81,751,265],{"class":107},[81,753,754],{"class":87},"(blocks[i] ",[81,756,757],{"class":158},"||",[81,759,760],{"class":114}," ''",[81,762,511],{"class":87},[81,764,766],{"class":83,"line":765},33,[81,767,768],{"class":87},"      }\n",[81,770,772],{"class":83,"line":771},34,[81,773,774],{"class":292},"      // 其余块直接复用\n",[81,776,778],{"class":83,"line":777},35,[81,779,780],{"class":87},"    }\n",[81,782,784,787,789,792,795],{"class":83,"line":783},36,[81,785,786],{"class":87},"    renderedBlocks.value ",[81,788,111],{"class":158},[81,790,791],{"class":87}," blockCache.value.",[81,793,794],{"class":107},"slice",[81,796,526],{"class":87},[81,798,800],{"class":83,"line":799},37,[81,801,802],{"class":87},"  },\n",[81,804,806,809,812],{"class":83,"line":805},38,[81,807,808],{"class":87},"  { immediate: ",[81,810,811],{"class":200},"true",[81,813,814],{"class":87}," }\n",[81,816,818],{"class":83,"line":817},39,[81,819,511],{"class":87},[81,821,823],{"class":83,"line":822},40,[81,824,139],{"emptyLinePlaceholder":138},[81,826,828,830,832,834],{"class":83,"line":827},41,[81,829,279],{"class":107},[81,831,256],{"class":87},[81,833,259],{"class":158},[81,835,286],{"class":87},[81,837,839],{"class":83,"line":838},42,[81,840,293],{"class":292},[81,842,844],{"class":83,"line":843},43,[81,845,299],{"class":87},[81,847,849,851,853],{"class":83,"line":848},44,[81,850,128],{"class":87},[81,852,147],{"class":91},[81,854,95],{"class":87},[10,856,858],{"id":857},"终极武器用-morphdom-实现精准更新","终极武器：用 morphdom 实现精准更新",[14,860,861],{},"分块渲染虽然解决了大部分问题，但遇到 Markdown 列表就有点力不从心了。因为 Markdown 语法里，列表项之间通常只有一个换行符，整个列表会被当成一个大块。想象一下一个几百项的列表，哪怕只更新最后一项，整个列表块也要全部重来，前面的问题又回来了。",[863,864,866],"h3",{"id":865},"morphdom-是何方神圣","morphdom 是何方神圣？",[14,868,869,872,873,876],{},[64,870,871],{},"morphdom"," 是一个仅 5KB（gzip 后）的 JavaScript 库，核心功能是：",[59,874,875],{},"接收两个 DOM 节点（或 HTML 字符串），计算出最小化的 DOM 操作，将第一个节点 “变形” 为第二个节点，而非直接替换","。",[14,878,879,880,883],{},"其工作原理类似虚拟 DOM 的 Diff 算法，但",[59,881,882],{},"直接操作真实 DOM","：",[321,885,886,889,892],{},[324,887,888],{},"对比新旧 DOM 的标签名、属性、文本内容等；",[324,890,891],{},"仅对差异部分执行增 / 删 / 改操作（如修改文本、更新属性、移动节点位置）；",[324,893,894],{},"未变化的 DOM 节点会被完整保留，包括其事件监听、滚动位置、选中状态等。",[14,896,897,898,901,902,904],{},"Markdown 把列表当整体，但生成的 HTML 里，每个列表项 (",[64,899,900],{},"\u003Cli>",") 都是独立的！",[64,903,871],{}," 在更新后面的列表项时，能保证前面的列表项纹丝不动，状态自然就保住了。",[14,906,907],{},"这不就是我们梦寐以求的效果吗？在 Markdown 实时更新的同时，最大程度留住用户的操作状态，还能省掉一堆不必要的 DOM 操作！",[863,909,910],{"id":910},"示例代码",[72,912,914],{"className":74,"code":913,"language":76,"meta":77,"style":77},"\u003Ctemplate>\n  \u003Cdiv ref=\"markdownContainer\" class=\"markdown-container\">\n    \u003Cdiv id=\"md-root\">\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { nextTick, ref, watch } from 'vue';\nimport MarkdownIt from 'markdown-it';\nimport morphdom from 'morphdom';\n\nconst markdownContent = ref('');\nconst markdownContainer = ref(null);\nconst md = new MarkdownIt();\n    \nconst render = () => {\n  if (!markdownContainer.value.querySelector('#md-root')) return;\n  \n  const newHtml = `\u003Cdiv id=\"md-root\">` + md.render(markdownContent.value) + `\u003C/div>`\n\n  morphdom(markdownContainer.value, newHtml, {\n    childrenOnly: true\n  });\n}\n\nwatch(markdownContent, () => {\n    render()\n});\n    \nonMounted(async () => {\n  // 等待 Dom 被挂载上\n  await nextTick()\n  render()\n})\n\u003C/script>\n\n",[64,915,916,924,947,967,975,983,987,997,1010,1022,1036,1040,1056,1074,1088,1093,1109,1138,1143,1172,1176,1184,1192,1197,1202,1206,1217,1224,1229,1233,1248,1253,1263,1270,1274],{"__ignoreMap":77},[81,917,918,920,922],{"class":83,"line":84},[81,919,88],{"class":87},[81,921,92],{"class":91},[81,923,95],{"class":87},[81,925,926,928,930,932,934,937,940,942,945],{"class":83,"line":98},[81,927,101],{"class":87},[81,929,104],{"class":91},[81,931,207],{"class":107},[81,933,111],{"class":87},[81,935,936],{"class":114},"\"markdownContainer\"",[81,938,939],{"class":107}," class",[81,941,111],{"class":87},[81,943,944],{"class":114},"\"markdown-container\"",[81,946,95],{"class":87},[81,948,949,951,953,956,958,961,963,965],{"class":83,"line":125},[81,950,384],{"class":87},[81,952,104],{"class":91},[81,954,955],{"class":107}," id",[81,957,111],{"class":87},[81,959,960],{"class":114},"\"md-root\"",[81,962,118],{"class":87},[81,964,104],{"class":91},[81,966,95],{"class":87},[81,968,969,971,973],{"class":83,"line":135},[81,970,441],{"class":87},[81,972,104],{"class":91},[81,974,95],{"class":87},[81,976,977,979,981],{"class":83,"line":142},[81,978,128],{"class":87},[81,980,92],{"class":91},[81,982,95],{"class":87},[81,984,985],{"class":83,"line":155},[81,986,139],{"emptyLinePlaceholder":138},[81,988,989,991,993,995],{"class":83,"line":174},[81,990,88],{"class":87},[81,992,147],{"class":91},[81,994,150],{"class":107},[81,996,95],{"class":87},[81,998,999,1001,1004,1006,1008],{"class":83,"line":189},[81,1000,159],{"class":158},[81,1002,1003],{"class":87}," { nextTick, ref, watch } ",[81,1005,165],{"class":158},[81,1007,168],{"class":114},[81,1009,171],{"class":87},[81,1011,1012,1014,1016,1018,1020],{"class":83,"line":194},[81,1013,159],{"class":158},[81,1015,179],{"class":87},[81,1017,165],{"class":158},[81,1019,184],{"class":114},[81,1021,171],{"class":87},[81,1023,1024,1026,1029,1031,1034],{"class":83,"line":219},[81,1025,159],{"class":158},[81,1027,1028],{"class":87}," morphdom ",[81,1030,165],{"class":158},[81,1032,1033],{"class":114}," 'morphdom'",[81,1035,171],{"class":87},[81,1037,1038],{"class":83,"line":238},[81,1039,139],{"emptyLinePlaceholder":138},[81,1041,1042,1044,1046,1048,1050,1052,1054],{"class":83,"line":243},[81,1043,197],{"class":158},[81,1045,201],{"class":200},[81,1047,204],{"class":158},[81,1049,207],{"class":107},[81,1051,210],{"class":87},[81,1053,213],{"class":114},[81,1055,216],{"class":87},[81,1057,1058,1060,1063,1065,1067,1069,1072],{"class":83,"line":271},[81,1059,197],{"class":158},[81,1061,1062],{"class":200}," markdownContainer",[81,1064,204],{"class":158},[81,1066,207],{"class":107},[81,1068,210],{"class":87},[81,1070,1071],{"class":200},"null",[81,1073,216],{"class":87},[81,1075,1076,1078,1080,1082,1084,1086],{"class":83,"line":276},[81,1077,197],{"class":158},[81,1079,224],{"class":200},[81,1081,204],{"class":158},[81,1083,229],{"class":158},[81,1085,232],{"class":107},[81,1087,235],{"class":87},[81,1089,1090],{"class":83,"line":289},[81,1091,1092],{"class":87},"    \n",[81,1094,1095,1097,1100,1102,1105,1107],{"class":83,"line":296},[81,1096,197],{"class":158},[81,1098,1099],{"class":107}," render",[81,1101,204],{"class":158},[81,1103,1104],{"class":87}," () ",[81,1106,259],{"class":158},[81,1108,286],{"class":87},[81,1110,1111,1114,1116,1119,1122,1125,1127,1130,1133,1136],{"class":83,"line":302},[81,1112,1113],{"class":158},"  if",[81,1115,673],{"class":87},[81,1117,1118],{"class":158},"!",[81,1120,1121],{"class":87},"markdownContainer.value.",[81,1123,1124],{"class":107},"querySelector",[81,1126,210],{"class":87},[81,1128,1129],{"class":114},"'#md-root'",[81,1131,1132],{"class":87},")) ",[81,1134,1135],{"class":158},"return",[81,1137,171],{"class":87},[81,1139,1140],{"class":83,"line":529},[81,1141,1142],{"class":87},"  \n",[81,1144,1145,1148,1151,1153,1156,1159,1161,1163,1166,1169],{"class":83,"line":534},[81,1146,1147],{"class":158},"  const",[81,1149,1150],{"class":200}," newHtml",[81,1152,204],{"class":158},[81,1154,1155],{"class":114}," `\u003Cdiv id=\"md-root\">`",[81,1157,1158],{"class":158}," +",[81,1160,262],{"class":87},[81,1162,265],{"class":107},[81,1164,1165],{"class":87},"(markdownContent.value) ",[81,1167,1168],{"class":158},"+",[81,1170,1171],{"class":114}," `\u003C/div>`\n",[81,1173,1174],{"class":83,"line":549},[81,1175,139],{"emptyLinePlaceholder":138},[81,1177,1178,1181],{"class":83,"line":563},[81,1179,1180],{"class":107},"  morphdom",[81,1182,1183],{"class":87},"(markdownContainer.value, newHtml, {\n",[81,1185,1186,1189],{"class":83,"line":568},[81,1187,1188],{"class":87},"    childrenOnly: ",[81,1190,1191],{"class":200},"true\n",[81,1193,1194],{"class":83,"line":577},[81,1195,1196],{"class":87},"  });\n",[81,1198,1199],{"class":83,"line":583},[81,1200,1201],{"class":87},"}\n",[81,1203,1204],{"class":83,"line":606},[81,1205,139],{"emptyLinePlaceholder":138},[81,1207,1208,1210,1213,1215],{"class":83,"line":638},[81,1209,571],{"class":107},[81,1211,1212],{"class":87},"(markdownContent, () ",[81,1214,259],{"class":158},[81,1216,286],{"class":87},[81,1218,1219,1222],{"class":83,"line":644},[81,1220,1221],{"class":107},"    render",[81,1223,526],{"class":87},[81,1225,1226],{"class":83,"line":650},[81,1227,1228],{"class":87},"});\n",[81,1230,1231],{"class":83,"line":667},[81,1232,1092],{"class":87},[81,1234,1235,1237,1239,1242,1244,1246],{"class":83,"line":705},[81,1236,279],{"class":107},[81,1238,210],{"class":87},[81,1240,1241],{"class":158},"async",[81,1243,1104],{"class":87},[81,1245,259],{"class":158},[81,1247,286],{"class":87},[81,1249,1250],{"class":83,"line":711},[81,1251,1252],{"class":292},"  // 等待 Dom 被挂载上\n",[81,1254,1255,1258,1261],{"class":83,"line":742},[81,1256,1257],{"class":158},"  await",[81,1259,1260],{"class":107}," nextTick",[81,1262,526],{"class":87},[81,1264,1265,1268],{"class":83,"line":765},[81,1266,1267],{"class":107},"  render",[81,1269,526],{"class":87},[81,1271,1272],{"class":83,"line":771},[81,1273,299],{"class":87},[81,1275,1276,1278,1280],{"class":83,"line":777},[81,1277,128],{"class":87},[81,1279,147],{"class":91},[81,1281,95],{"class":87},[863,1283,1285],{"id":1284},"眼见为实demo-对比","眼见为实：Demo 对比",[14,1287,1288],{},"下面这个 iframe 里放了个对比 Demo，展示了不同方案的效果差异。",[14,1290,1291,1294],{},[59,1292,1293],{},"小技巧："," 如果你用的是 Chrome、Edge 这类 Chromium 内核的浏览器，打开开发者工具 (DevTools)，找到“渲染”(Rendering) 标签页，勾选「突出显示重绘区域(Paint flashing)」。这样你就能直观看到每次更新时，哪些部分被重新绘制了——重绘区域越少，性能越好！",[14,1296,1297],{},[1298,1299],"img",{"alt":77,"src":1300},"https://static.031130.xyz/uploads/2025/07/12/d5721c40fb076.webp",[1302,1303],"iframe",{"src":1304,"width":1305,"height":1306,"allowFullScreen":138},"https://static.031130.xyz/demo/morphdom-vs-markdown-chunk.html","100%",500,[10,1308,1309],{"id":1309},"阶段性成果",[14,1311,1312,1313,1315],{},"从最开始的“暴力全量刷新”，到“聪明点的分块更新”，再到如今“精准手术刀般的 ",[64,1314,871],{}," 更新”，我们一步步把那些不必要的渲染开销给砍掉了，最终搞出了一个既快又能留住用户状态的 Markdown 实时渲染方案。",[14,1317,1318,1319,1321],{},"不过，用 ",[64,1320,871],{}," 这个第三方库来直接操作 Vue 组件里的 DOM，总觉得有点...不够“Vue”？它虽然解决了核心的性能和状态问题，但在 Vue 的世界里这么玩，多少有点旁门左道的意思。",[14,1323,1324,1327],{},[59,1325,1326],{},"下篇预告："," 在下一篇文章里，咱们就来聊聊，在 Vue 的世界里，有没有更优雅、更“原生”的方案来搞定 Markdown 的精准更新？敬请期待！",[1329,1330,1331],"style",{},"html pre.shiki code .sVt8B, html code.shiki .sVt8B{--shiki-default:#24292E;--shiki-dark:#E1E4E8}html pre.shiki code .s9eBZ, html code.shiki .s9eBZ{--shiki-default:#22863A;--shiki-dark:#85E89D}html pre.shiki code .sScJk, html code.shiki .sScJk{--shiki-default:#6F42C1;--shiki-dark:#B392F0}html pre.shiki code .sZZnC, html code.shiki .sZZnC{--shiki-default:#032F62;--shiki-dark:#9ECBFF}html pre.shiki code .szBVR, html code.shiki .szBVR{--shiki-default:#D73A49;--shiki-dark:#F97583}html pre.shiki code .sj4cs, html code.shiki .sj4cs{--shiki-default:#005CC5;--shiki-dark:#79B8FF}html pre.shiki code .sJ8bj, html code.shiki .sJ8bj{--shiki-default:#6A737D;--shiki-dark:#6A737D}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .s4XuR, html code.shiki .s4XuR{--shiki-default:#E36209;--shiki-dark:#FFAB70}",{"title":77,"searchDepth":98,"depth":98,"links":1333},[1334,1335,1336,1337,1342],{"id":12,"depth":98,"text":12},{"id":48,"depth":98,"text":49},{"id":311,"depth":98,"text":312},{"id":857,"depth":98,"text":858,"children":1338},[1339,1340,1341],{"id":865,"depth":125,"text":866},{"id":910,"depth":125,"text":910},{"id":1284,"depth":125,"text":1285},{"id":1309,"depth":98,"text":1309},"2025-07-12 20:48:56","md",{},"/2025/07/12/vue-markdown-render-improvement-1","---\ntitle: Vue Markdown 渲染优化实战(上)：从暴力刷新、分块更新到 Morphdom 的华丽变身\ndate: 2025-07-12 20:48:56\nsticky:\ntags:\n- Vue.js\n- Markdown\n- JavaScript\n- Web\n- HTML\n---\n\n## 需求背景\n\n在最近接手的 AI 需求中，需要实现一个类似 ChatGPT 的对话交互界面。其核心流程是：后端通过 SSE（Server-Sent  Events）协议，持续地将 AI 生成的 Markdown 格式文本片段推送到前端。前端负责动态接收并拼接这些 Markdown  片段，最终将拼接完成的 Markdown 文本实时渲染并显示在用户界面上。\n\nMarkdown 渲染并不是什么罕见的需求，尤其是在 LLM 相关落地产品满天飞的当下。不同于 React 生态拥有一个 14k+ star 的著名第三方库——[react-markdown](https://github.com/remarkjs/react-markdown)，Vue 这边似乎暂时还没有一个仍在活跃维护的、star 数量不低（起码得 2k+ 吧？）的 markdown 渲染库。[cloudacy/vue-markdown-render](https://github.com/cloudacy/vue-markdown-render#readme) 最后一次发版在一年前，但截止本文写作时间只有 103 个 star；[miaolz123/vue-markdown](https://github.com/miaolz123/vue-markdown) 有 2k star，但最后一次 commit 已经是 7 年前了；[zhaoxuhui1122/vue-markdown](https://github.com/zhaoxuhui1122/vue-markdown) 更是 archived 状态。\n\n## 第一版方案：简单粗暴的 v-html\n\n简单调研了一圈，发现 Vue 生态里确实缺少一个能打的 Markdown 渲染库。既然没有现成的轮子，那咱就自己造一个！\n\n根据大部分文章以及 LLM 的推荐，我们首先采用 markdown-it 这个第三方库将 markdown 转换为 html 字符串，再通过 v-html 传入。\n\n**PS:** 我们这里假设 Markdown 内容是可信的（比如由我们自己的 AI 生成）。如果内容来自用户输入，一定要使用 `DOMPurify` 这类库来防止 XSS 攻击，避免给网站“开天窗”哦！\n\n示例代码如下：\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv v-html=\"renderedHtml\">\u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { computed, onMounted, ref } from 'vue';\nimport MarkdownIt from 'markdown-it';\n\nconst markdownContent = ref('');\nconst md = new MarkdownIt();\n\nconst renderedHtml = computed(() => md.render(markdownContent.value))\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n```\n\n## 进化版：给 Markdown 分块更新\n\n上述方案虽然能实现基础渲染，但在实时更新场景下存在明显缺陷：**每次接收到新的 Markdown 片段，整个文档都会触发全量重渲染**。即使只有最后一行是新增内容，整个文档的 DOM 也会被完全替换。这导致两个核心问题：\n\n1. **性能顶不住：**Markdown 内容增长时，`markdown-it` 解析和 DOM 重建的开销呈线性上升。\n2. **交互状态丢失：**全量刷新会把用户当前的操作状态冲掉。最明显的就是，如果你选中了某段文字，一刷新，选中状态就没了！\n\n为了解决这两个问题，[我们在网上找到了分块渲染的方案](https://juejin.cn/post/7480900772386734143) —— 把 Markdown 按两个连续的换行符 (`\\n\\n`) 切成一块一块的。这样每次更新，只重新渲染最后一块新的，前面的老块直接复用缓存。好处很明显：\n\n- 用户如果选中了前面块里的文字，下次更新时选中状态不会丢（因为前面的块没动）。\n- 需要重新渲染的 DOM 变少了，性能自然就上来了。\n\n代码调整后像这样：\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv>\n    \u003Cdiv\n      v-for=\"(block, idx) in renderedBlocks\"\n      :key=\"idx\"\n      v-html=\"block\"\n      class=\"markdown-block\"\n    >\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { ref, computed, watch } from 'vue'\nimport MarkdownIt from 'markdown-it'\n\nconst markdownContent = ref('')\nconst md = new MarkdownIt()\n\nconst renderedBlocks = ref([])\nconst blockCache = ref([])\n\nwatch(\n  markdownContent,\n  (newContent, oldContent) => {\n    const blocks = newContent.split(/\\n{2,}/)\n    // 只重新渲染最后一个块，其余用缓存\n    // 处理块减少、块增多的场景\n    blockCache.value.length = blocks.length\n    for (let i = 0; i \u003C blocks.length; i++) {\n      // 只渲染最后一个，或新块\n      if (i === blocks.length - 1 || !blockCache.value[i]) {\n        blockCache.value[i] = md.render(blocks[i] || '')\n      }\n      // 其余块直接复用\n    }\n    renderedBlocks.value = blockCache.value.slice()\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n```\n\n## 终极武器：用 morphdom 实现精准更新\n\n分块渲染虽然解决了大部分问题，但遇到 Markdown 列表就有点力不从心了。因为 Markdown 语法里，列表项之间通常只有一个换行符，整个列表会被当成一个大块。想象一下一个几百项的列表，哪怕只更新最后一项，整个列表块也要全部重来，前面的问题又回来了。\n\n### morphdom 是何方神圣？\n\n`morphdom` 是一个仅 5KB（gzip 后）的 JavaScript 库，核心功能是：**接收两个 DOM 节点（或 HTML 字符串），计算出最小化的 DOM 操作，将第一个节点 “变形” 为第二个节点，而非直接替换**。\n\n其工作原理类似虚拟 DOM 的 Diff 算法，但**直接操作真实 DOM**：\n\n1. 对比新旧 DOM 的标签名、属性、文本内容等；\n2. 仅对差异部分执行增 / 删 / 改操作（如修改文本、更新属性、移动节点位置）；\n3. 未变化的 DOM 节点会被完整保留，包括其事件监听、滚动位置、选中状态等。\n\nMarkdown 把列表当整体，但生成的 HTML 里，每个列表项 (`\u003Cli>`) 都是独立的！`morphdom` 在更新后面的列表项时，能保证前面的列表项纹丝不动，状态自然就保住了。\n\n这不就是我们梦寐以求的效果吗？在 Markdown 实时更新的同时，最大程度留住用户的操作状态，还能省掉一堆不必要的 DOM 操作！\n\n### 示例代码\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv ref=\"markdownContainer\" class=\"markdown-container\">\n    \u003Cdiv id=\"md-root\">\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { nextTick, ref, watch } from 'vue';\nimport MarkdownIt from 'markdown-it';\nimport morphdom from 'morphdom';\n\nconst markdownContent = ref('');\nconst markdownContainer = ref(null);\nconst md = new MarkdownIt();\n    \nconst render = () => {\n  if (!markdownContainer.value.querySelector('#md-root')) return;\n  \n  const newHtml = `\u003Cdiv id=\"md-root\">` + md.render(markdownContent.value) + `\u003C/div>`\n\n  morphdom(markdownContainer.value, newHtml, {\n    childrenOnly: true\n  });\n}\n\nwatch(markdownContent, () => {\n    render()\n});\n    \nonMounted(async () => {\n  // 等待 Dom 被挂载上\n  await nextTick()\n  render()\n})\n\u003C/script>\n\n```\n\n### 眼见为实：Demo 对比\n\n下面这个 iframe 里放了个对比 Demo，展示了不同方案的效果差异。\n\n**小技巧：** 如果你用的是 Chrome、Edge 这类 Chromium 内核的浏览器，打开开发者工具 (DevTools)，找到“渲染”(Rendering) 标签页，勾选「突出显示重绘区域(Paint flashing)」。这样你就能直观看到每次更新时，哪些部分被重新绘制了——重绘区域越少，性能越好！\n\n![](https://static.031130.xyz/uploads/2025/07/12/d5721c40fb076.webp)\n\n\u003Ciframe src=\"https://static.031130.xyz/demo/morphdom-vs-markdown-chunk.html\" width=\"100%\" height=\"500\" allowfullscreen>\u003C/iframe>\n\n## 阶段性成果\n\n从最开始的“暴力全量刷新”，到“聪明点的分块更新”，再到如今“精准手术刀般的 `morphdom` 更新”，我们一步步把那些不必要的渲染开销给砍掉了，最终搞出了一个既快又能留住用户状态的 Markdown 实时渲染方案。\n\n不过，用 `morphdom` 这个第三方库来直接操作 Vue 组件里的 DOM，总觉得有点...不够“Vue”？它虽然解决了核心的性能和状态问题，但在 Vue 的世界里这么玩，多少有点旁门左道的意思。\n\n**下篇预告：** 在下一篇文章里，咱们就来聊聊，在 Vue 的世界里，有没有更优雅、更“原生”的方案来搞定 Markdown 的精准更新？敬请期待！\n",{"title":5,"description":77},"posts/vue-markdown-render-improvement-1",false,[1352,1353,1354,1355,1356],"Vue.js","Markdown","JavaScript","Web","HTML","5l1uTANcrmkL82DLzRCrmi6GBIiTyOm27NdAc9AAqEA",[1359,1364],{"title":1360,"path":1361,"stem":1362,"date":1363},"Vue Markdown 渲染优化实战(下)：告别 DOM 操作，拥抱 AST 与函数式渲染","/2025/07/13/vue-markdown-render-improvement-2","posts/vue-markdown-render-improvement-2","2025-07-13 00:01:35",{"title":1365,"path":1366,"stem":1367,"date":1368},"node-sass 迁移至 dart-sass 踩坑实录","/2025/07/05/node-sass-migration-to-dart-sass","posts/node-sass-migration-to-dart-sass","2025-07-05 17:57:02",1761696664861]