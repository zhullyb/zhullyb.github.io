[{"data":1,"prerenderedAt":1565},["ShallowReactive",2],{"post-2025-07-12-vue-markdown-render-improvement-1":3,"has-en-2025-07-12-vue-markdown-render-improvement-1":1546,"surround-2025-07-12-vue-markdown-render-improvement-1":1554,"randomIndex/2025/07/12/vue-markdown-render-improvement-1/":160},{"id":4,"title":5,"body":6,"date":1538,"description":77,"extension":1539,"lang":1540,"meta":1541,"navigation":143,"path":1542,"rawbody":1543,"seo":1544,"stem":1545,"sticky":1546,"tags":1547,"__hash__":1553},"posts/posts/vue-markdown-render-improvement-1.md","Vue Markdown 渲染优化实战(上)：从暴力刷新、分块更新到 Morphdom 的华丽变身",{"type":7,"value":8,"toc":1527},"minimark",[9,13,17,46,50,53,56,68,71,346,350,357,371,384,393,396,1005,1009,1012,1017,1027,1034,1045,1055,1058,1061,1476,1480,1483,1489,1495,1502,1505,1511,1517,1523],[10,11,12],"h2",{"id":12},"需求背景",[14,15,16],"p",{},"在最近接手的 AI 需求中，需要实现一个类似 ChatGPT 的对话交互界面。其核心流程是：后端通过 SSE（Server-Sent  Events）协议，持续地将 AI 生成的 Markdown 格式文本片段推送到前端。前端负责动态接收并拼接这些 Markdown  片段，最终将拼接完成的 Markdown 文本实时渲染并显示在用户界面上。",[14,18,19,20,27,28,33,34,39,40,45],{},"Markdown 渲染并不是什么罕见的需求，尤其是在 LLM 相关落地产品满天飞的当下。不同于 React 生态拥有一个 14k+ star 的著名第三方库——",[21,22,26],"a",{"href":23,"rel":24},"https://github.com/remarkjs/react-markdown",[25],"nofollow","react-markdown","，Vue 这边似乎暂时还没有一个仍在活跃维护的、star 数量不低（起码得 2k+ 吧？）的 markdown 渲染库。",[21,29,32],{"href":30,"rel":31},"https://github.com/cloudacy/vue-markdown-render#readme",[25],"cloudacy/vue-markdown-render"," 最后一次发版在一年前，但截止本文写作时间只有 103 个 star；",[21,35,38],{"href":36,"rel":37},"https://github.com/miaolz123/vue-markdown",[25],"miaolz123/vue-markdown"," 有 2k star，但最后一次 commit 已经是 7 年前了；",[21,41,44],{"href":42,"rel":43},"https://github.com/zhaoxuhui1122/vue-markdown",[25],"zhaoxuhui1122/vue-markdown"," 更是 archived 状态。",[10,47,49],{"id":48},"第一版方案简单粗暴的-v-html","第一版方案：简单粗暴的 v-html",[14,51,52],{},"简单调研了一圈，发现 Vue 生态里确实缺少一个能打的 Markdown 渲染库。既然没有现成的轮子，那咱就自己造一个！",[14,54,55],{},"根据大部分文章以及 LLM 的推荐，我们首先采用 markdown-it 这个第三方库将 markdown 转换为 html 字符串，再通过 v-html 传入。",[14,57,58,62,63,67],{},[59,60,61],"strong",{},"PS:"," 我们这里假设 Markdown 内容是可信的（比如由我们自己的 AI 生成）。如果内容来自用户输入，一定要使用 ",[64,65,66],"code",{},"DOMPurify"," 这类库来防止 XSS 攻击，避免给网站“开天窗”哦！",[14,69,70],{},"示例代码如下：",[72,73,78],"pre",{"className":74,"code":75,"language":76,"meta":77,"style":77},"language-vue shiki shiki-themes one-light one-dark-pro","\u003Ctemplate>\n  \u003Cdiv v-html=\"renderedHtml\">\u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { computed, onMounted, ref } from 'vue';\nimport MarkdownIt from 'markdown-it';\n\nconst markdownContent = ref('');\nconst md = new MarkdownIt();\n\nconst renderedHtml = computed(() => md.render(markdownContent.value))\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n","vue","",[64,79,80,96,128,138,145,158,195,211,216,243,261,266,307,312,324,331,337],{"__ignoreMap":77},[81,82,85,89,93],"span",{"class":83,"line":84},"line",1,[81,86,88],{"class":87},"s5ixo","\u003C",[81,90,92],{"class":91},"sJa8x","template",[81,94,95],{"class":87},">\n",[81,97,99,102,105,109,112,115,119,121,124,126],{"class":83,"line":98},2,[81,100,101],{"class":87},"  \u003C",[81,103,104],{"class":91},"div",[81,106,108],{"class":107},"sAGMh"," v-html",[81,110,111],{"class":87},"=",[81,113,114],{"class":87},"\"",[81,116,118],{"class":117},"sz0mV","renderedHtml",[81,120,114],{"class":87},[81,122,123],{"class":87},">\u003C/",[81,125,104],{"class":91},[81,127,95],{"class":87},[81,129,131,134,136],{"class":83,"line":130},3,[81,132,133],{"class":87},"\u003C/",[81,135,92],{"class":91},[81,137,95],{"class":87},[81,139,141],{"class":83,"line":140},4,[81,142,144],{"emptyLinePlaceholder":143},true,"\n",[81,146,148,150,153,156],{"class":83,"line":147},5,[81,149,88],{"class":87},[81,151,152],{"class":91},"script",[81,154,155],{"class":107}," setup",[81,157,95],{"class":87},[81,159,161,165,168,171,174,177,179,182,185,188,192],{"class":83,"line":160},6,[81,162,164],{"class":163},"sLKXg","import",[81,166,167],{"class":87}," { ",[81,169,170],{"class":91},"computed",[81,172,173],{"class":87},", ",[81,175,176],{"class":91},"onMounted",[81,178,173],{"class":87},[81,180,181],{"class":91},"ref",[81,183,184],{"class":87}," } ",[81,186,187],{"class":163},"from",[81,189,191],{"class":190},"sDhpE"," 'vue'",[81,193,194],{"class":87},";\n",[81,196,198,200,203,206,209],{"class":83,"line":197},7,[81,199,164],{"class":163},[81,201,202],{"class":91}," MarkdownIt",[81,204,205],{"class":163}," from",[81,207,208],{"class":190}," 'markdown-it'",[81,210,194],{"class":87},[81,212,214],{"class":83,"line":213},8,[81,215,144],{"emptyLinePlaceholder":143},[81,217,219,222,226,230,234,237,240],{"class":83,"line":218},9,[81,220,221],{"class":163},"const",[81,223,225],{"class":224},"sNmU0"," markdownContent",[81,227,229],{"class":228},"s_Sar"," =",[81,231,233],{"class":232},"sAdtL"," ref",[81,235,236],{"class":87},"(",[81,238,239],{"class":190},"''",[81,241,242],{"class":87},");\n",[81,244,246,248,251,253,256,258],{"class":83,"line":245},10,[81,247,221],{"class":163},[81,249,250],{"class":224}," md",[81,252,229],{"class":228},[81,254,255],{"class":163}," new",[81,257,202],{"class":232},[81,259,260],{"class":87},"();\n",[81,262,264],{"class":83,"line":263},11,[81,265,144],{"emptyLinePlaceholder":143},[81,267,269,271,274,276,279,282,285,288,291,294,296,299,301,304],{"class":83,"line":268},12,[81,270,221],{"class":163},[81,272,273],{"class":224}," renderedHtml",[81,275,229],{"class":228},[81,277,278],{"class":232}," computed",[81,280,281],{"class":87},"(() ",[81,283,284],{"class":163},"=>",[81,286,250],{"class":287},"s7GmK",[81,289,290],{"class":87},".",[81,292,293],{"class":232},"render",[81,295,236],{"class":87},[81,297,298],{"class":287},"markdownContent",[81,300,290],{"class":87},[81,302,303],{"class":91},"value",[81,305,306],{"class":87},"))\n",[81,308,310],{"class":83,"line":309},13,[81,311,144],{"emptyLinePlaceholder":143},[81,313,315,317,319,321],{"class":83,"line":314},14,[81,316,176],{"class":232},[81,318,281],{"class":87},[81,320,284],{"class":163},[81,322,323],{"class":87}," {\n",[81,325,327],{"class":83,"line":326},15,[81,328,330],{"class":329},"sW2Sy","  // markdownContent.value = await fetch() ...\n",[81,332,334],{"class":83,"line":333},16,[81,335,336],{"class":87},"})\n",[81,338,340,342,344],{"class":83,"line":339},17,[81,341,133],{"class":87},[81,343,152],{"class":91},[81,345,95],{"class":87},[10,347,349],{"id":348},"进化版给-markdown-分块更新","进化版：给 Markdown 分块更新",[14,351,352,353,356],{},"上述方案虽然能实现基础渲染，但在实时更新场景下存在明显缺陷：",[59,354,355],{},"每次接收到新的 Markdown 片段，整个文档都会触发全量重渲染","。即使只有最后一行是新增内容，整个文档的 DOM 也会被完全替换。这导致两个核心问题：",[358,359,360,368],"ol",{},[361,362,363,364,367],"li",{},"**性能顶不住：**Markdown 内容增长时，",[64,365,366],{},"markdown-it"," 解析和 DOM 重建的开销呈线性上升。",[361,369,370],{},"**交互状态丢失：**全量刷新会把用户当前的操作状态冲掉。最明显的就是，如果你选中了某段文字，一刷新，选中状态就没了！",[14,372,373,374,379,380,383],{},"为了解决这两个问题，",[21,375,378],{"href":376,"rel":377},"https://juejin.cn/post/7480900772386734143",[25],"我们在网上找到了分块渲染的方案"," —— 把 Markdown 按两个连续的换行符 (",[64,381,382],{},"\\n\\n",") 切成一块一块的。这样每次更新，只重新渲染最后一块新的，前面的老块直接复用缓存。好处很明显：",[385,386,387,390],"ul",{},[361,388,389],{},"用户如果选中了前面块里的文字，下次更新时选中状态不会丢（因为前面的块没动）。",[361,391,392],{},"需要重新渲染的 DOM 变少了，性能自然就上来了。",[14,394,395],{},"代码调整后像这样：",[72,397,399],{"className":74,"code":398,"language":76,"meta":77,"style":77},"\u003Ctemplate>\n  \u003Cdiv>\n    \u003Cdiv\n      v-for=\"(block, idx) in renderedBlocks\"\n      :key=\"idx\"\n      v-html=\"block\"\n      class=\"markdown-block\"\n    >\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { ref, computed, watch } from 'vue'\nimport MarkdownIt from 'markdown-it'\n\nconst markdownContent = ref('')\nconst md = new MarkdownIt()\n\nconst renderedBlocks = ref([])\nconst blockCache = ref([])\n\nwatch(\n  markdownContent,\n  (newContent, oldContent) => {\n    const blocks = newContent.split(/\\n{2,}/)\n    // 只重新渲染最后一个块，其余用缓存\n    // 处理块减少、块增多的场景\n    blockCache.value.length = blocks.length\n    for (let i = 0; i \u003C blocks.length; i++) {\n      // 只渲染最后一个，或新块\n      if (i === blocks.length - 1 || !blockCache.value[i]) {\n        blockCache.value[i] = md.render(blocks[i] || '')\n      }\n      // 其余块直接复用\n    }\n    renderedBlocks.value = blockCache.value.slice()\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n",[64,400,401,409,417,425,456,472,485,495,504,513,521,525,535,559,570,574,591,606,611,625,639,644,652,661,682,719,725,731,756,801,807,853,897,903,909,915,940,946,965,970,975,986,991,996],{"__ignoreMap":77},[81,402,403,405,407],{"class":83,"line":84},[81,404,88],{"class":87},[81,406,92],{"class":91},[81,408,95],{"class":87},[81,410,411,413,415],{"class":83,"line":98},[81,412,101],{"class":87},[81,414,104],{"class":91},[81,416,95],{"class":87},[81,418,419,422],{"class":83,"line":130},[81,420,421],{"class":87},"    \u003C",[81,423,424],{"class":91},"div\n",[81,426,427,430,432,434,436,439,441,444,447,450,453],{"class":83,"line":140},[81,428,429],{"class":163},"      v-for",[81,431,111],{"class":87},[81,433,114],{"class":87},[81,435,236],{"class":87},[81,437,438],{"class":117},"block",[81,440,173],{"class":87},[81,442,443],{"class":117},"idx",[81,445,446],{"class":87},") ",[81,448,449],{"class":163},"in",[81,451,452],{"class":117}," renderedBlocks",[81,454,455],{"class":87},"\"\n",[81,457,458,461,464,466,468,470],{"class":83,"line":147},[81,459,460],{"class":87},"      :",[81,462,463],{"class":107},"key",[81,465,111],{"class":87},[81,467,114],{"class":87},[81,469,443],{"class":117},[81,471,455],{"class":87},[81,473,474,477,479,481,483],{"class":83,"line":160},[81,475,476],{"class":107},"      v-html",[81,478,111],{"class":87},[81,480,114],{"class":87},[81,482,438],{"class":117},[81,484,455],{"class":87},[81,486,487,490,492],{"class":83,"line":197},[81,488,489],{"class":107},"      class",[81,491,111],{"class":87},[81,493,494],{"class":190},"\"markdown-block\"\n",[81,496,497,500,502],{"class":83,"line":213},[81,498,499],{"class":87},"    >\u003C/",[81,501,104],{"class":91},[81,503,95],{"class":87},[81,505,506,509,511],{"class":83,"line":218},[81,507,508],{"class":87},"  \u003C/",[81,510,104],{"class":91},[81,512,95],{"class":87},[81,514,515,517,519],{"class":83,"line":245},[81,516,133],{"class":87},[81,518,92],{"class":91},[81,520,95],{"class":87},[81,522,523],{"class":83,"line":263},[81,524,144],{"emptyLinePlaceholder":143},[81,526,527,529,531,533],{"class":83,"line":268},[81,528,88],{"class":87},[81,530,152],{"class":91},[81,532,155],{"class":107},[81,534,95],{"class":87},[81,536,537,539,541,543,545,547,549,552,554,556],{"class":83,"line":309},[81,538,164],{"class":163},[81,540,167],{"class":87},[81,542,181],{"class":91},[81,544,173],{"class":87},[81,546,170],{"class":91},[81,548,173],{"class":87},[81,550,551],{"class":91},"watch",[81,553,184],{"class":87},[81,555,187],{"class":163},[81,557,558],{"class":190}," 'vue'\n",[81,560,561,563,565,567],{"class":83,"line":314},[81,562,164],{"class":163},[81,564,202],{"class":91},[81,566,205],{"class":163},[81,568,569],{"class":190}," 'markdown-it'\n",[81,571,572],{"class":83,"line":326},[81,573,144],{"emptyLinePlaceholder":143},[81,575,576,578,580,582,584,586,588],{"class":83,"line":333},[81,577,221],{"class":163},[81,579,225],{"class":224},[81,581,229],{"class":228},[81,583,233],{"class":232},[81,585,236],{"class":87},[81,587,239],{"class":190},[81,589,590],{"class":87},")\n",[81,592,593,595,597,599,601,603],{"class":83,"line":339},[81,594,221],{"class":163},[81,596,250],{"class":224},[81,598,229],{"class":228},[81,600,255],{"class":163},[81,602,202],{"class":232},[81,604,605],{"class":87},"()\n",[81,607,609],{"class":83,"line":608},18,[81,610,144],{"emptyLinePlaceholder":143},[81,612,614,616,618,620,622],{"class":83,"line":613},19,[81,615,221],{"class":163},[81,617,452],{"class":224},[81,619,229],{"class":228},[81,621,233],{"class":232},[81,623,624],{"class":87},"([])\n",[81,626,628,630,633,635,637],{"class":83,"line":627},20,[81,629,221],{"class":163},[81,631,632],{"class":224}," blockCache",[81,634,229],{"class":228},[81,636,233],{"class":232},[81,638,624],{"class":87},[81,640,642],{"class":83,"line":641},21,[81,643,144],{"emptyLinePlaceholder":143},[81,645,647,649],{"class":83,"line":646},22,[81,648,551],{"class":232},[81,650,651],{"class":87},"(\n",[81,653,655,658],{"class":83,"line":654},23,[81,656,657],{"class":117},"  markdownContent",[81,659,660],{"class":87},",\n",[81,662,664,667,671,673,676,678,680],{"class":83,"line":663},24,[81,665,666],{"class":87},"  (",[81,668,670],{"class":669},"s8iYz","newContent",[81,672,173],{"class":87},[81,674,675],{"class":669},"oldContent",[81,677,446],{"class":87},[81,679,284],{"class":163},[81,681,323],{"class":87},[81,683,685,688,691,693,696,698,701,703,707,711,715,717],{"class":83,"line":684},25,[81,686,687],{"class":163},"    const",[81,689,690],{"class":224}," blocks",[81,692,229],{"class":228},[81,694,695],{"class":287}," newContent",[81,697,290],{"class":87},[81,699,700],{"class":232},"split",[81,702,236],{"class":87},[81,704,706],{"class":705},"sDaw7","/",[81,708,710],{"class":709},"sRZ4U","\\n",[81,712,714],{"class":713},"sYoRg","{2,}",[81,716,706],{"class":705},[81,718,590],{"class":87},[81,720,722],{"class":83,"line":721},26,[81,723,724],{"class":329},"    // 只重新渲染最后一个块，其余用缓存\n",[81,726,728],{"class":83,"line":727},27,[81,729,730],{"class":329},"    // 处理块减少、块增多的场景\n",[81,732,734,737,739,742,744,747,749,751,753],{"class":83,"line":733},28,[81,735,736],{"class":287},"    blockCache",[81,738,290],{"class":87},[81,740,303],{"class":741},"s2QsP",[81,743,290],{"class":87},[81,745,746],{"class":91},"length",[81,748,229],{"class":228},[81,750,690],{"class":287},[81,752,290],{"class":87},[81,754,755],{"class":91},"length\n",[81,757,759,762,765,768,771,773,776,779,782,785,787,789,791,793,795,798],{"class":83,"line":758},29,[81,760,761],{"class":163},"    for",[81,763,764],{"class":87}," (",[81,766,767],{"class":163},"let",[81,769,770],{"class":117}," i",[81,772,229],{"class":228},[81,774,775],{"class":107}," 0",[81,777,778],{"class":87},"; ",[81,780,781],{"class":117},"i",[81,783,784],{"class":228}," \u003C",[81,786,690],{"class":287},[81,788,290],{"class":87},[81,790,746],{"class":91},[81,792,778],{"class":87},[81,794,781],{"class":117},[81,796,797],{"class":228},"++",[81,799,800],{"class":87},") {\n",[81,802,804],{"class":83,"line":803},30,[81,805,806],{"class":329},"      // 只渲染最后一个，或新块\n",[81,808,810,813,815,817,820,822,824,826,829,832,835,838,841,843,845,848,850],{"class":83,"line":809},31,[81,811,812],{"class":163},"      if",[81,814,764],{"class":87},[81,816,781],{"class":117},[81,818,819],{"class":228}," ===",[81,821,690],{"class":287},[81,823,290],{"class":87},[81,825,746],{"class":91},[81,827,828],{"class":228}," -",[81,830,831],{"class":107}," 1",[81,833,834],{"class":228}," ||",[81,836,837],{"class":228}," !",[81,839,840],{"class":287},"blockCache",[81,842,290],{"class":87},[81,844,303],{"class":91},[81,846,847],{"class":87},"[",[81,849,781],{"class":117},[81,851,852],{"class":87},"]) {\n",[81,854,856,859,861,863,865,867,870,872,874,876,878,880,883,885,887,889,892,895],{"class":83,"line":855},32,[81,857,858],{"class":287},"        blockCache",[81,860,290],{"class":87},[81,862,303],{"class":91},[81,864,847],{"class":87},[81,866,781],{"class":117},[81,868,869],{"class":87},"] ",[81,871,111],{"class":228},[81,873,250],{"class":287},[81,875,290],{"class":87},[81,877,293],{"class":232},[81,879,236],{"class":87},[81,881,882],{"class":117},"blocks",[81,884,847],{"class":87},[81,886,781],{"class":117},[81,888,869],{"class":87},[81,890,891],{"class":228},"||",[81,893,894],{"class":190}," ''",[81,896,590],{"class":87},[81,898,900],{"class":83,"line":899},33,[81,901,902],{"class":87},"      }\n",[81,904,906],{"class":83,"line":905},34,[81,907,908],{"class":329},"      // 其余块直接复用\n",[81,910,912],{"class":83,"line":911},35,[81,913,914],{"class":87},"    }\n",[81,916,918,921,923,925,927,929,931,933,935,938],{"class":83,"line":917},36,[81,919,920],{"class":287},"    renderedBlocks",[81,922,290],{"class":87},[81,924,303],{"class":91},[81,926,229],{"class":228},[81,928,632],{"class":287},[81,930,290],{"class":87},[81,932,303],{"class":741},[81,934,290],{"class":87},[81,936,937],{"class":232},"slice",[81,939,605],{"class":87},[81,941,943],{"class":83,"line":942},37,[81,944,945],{"class":87},"  },\n",[81,947,949,952,955,959,962],{"class":83,"line":948},38,[81,950,951],{"class":87},"  { ",[81,953,954],{"class":91},"immediate",[81,956,958],{"class":957},"st7oF",":",[81,960,961],{"class":107}," true",[81,963,964],{"class":87}," }\n",[81,966,968],{"class":83,"line":967},39,[81,969,590],{"class":87},[81,971,973],{"class":83,"line":972},40,[81,974,144],{"emptyLinePlaceholder":143},[81,976,978,980,982,984],{"class":83,"line":977},41,[81,979,176],{"class":232},[81,981,281],{"class":87},[81,983,284],{"class":163},[81,985,323],{"class":87},[81,987,989],{"class":83,"line":988},42,[81,990,330],{"class":329},[81,992,994],{"class":83,"line":993},43,[81,995,336],{"class":87},[81,997,999,1001,1003],{"class":83,"line":998},44,[81,1000,133],{"class":87},[81,1002,152],{"class":91},[81,1004,95],{"class":87},[10,1006,1008],{"id":1007},"终极武器用-morphdom-实现精准更新","终极武器：用 morphdom 实现精准更新",[14,1010,1011],{},"分块渲染虽然解决了大部分问题，但遇到 Markdown 列表就有点力不从心了。因为 Markdown 语法里，列表项之间通常只有一个换行符，整个列表会被当成一个大块。想象一下一个几百项的列表，哪怕只更新最后一项，整个列表块也要全部重来，前面的问题又回来了。",[1013,1014,1016],"h3",{"id":1015},"morphdom-是何方神圣","morphdom 是何方神圣？",[14,1018,1019,1022,1023,1026],{},[64,1020,1021],{},"morphdom"," 是一个仅 5KB（gzip 后）的 JavaScript 库，核心功能是：",[59,1024,1025],{},"接收两个 DOM 节点（或 HTML 字符串），计算出最小化的 DOM 操作，将第一个节点 “变形” 为第二个节点，而非直接替换","。",[14,1028,1029,1030,1033],{},"其工作原理类似虚拟 DOM 的 Diff 算法，但",[59,1031,1032],{},"直接操作真实 DOM","：",[358,1035,1036,1039,1042],{},[361,1037,1038],{},"对比新旧 DOM 的标签名、属性、文本内容等；",[361,1040,1041],{},"仅对差异部分执行增 / 删 / 改操作（如修改文本、更新属性、移动节点位置）；",[361,1043,1044],{},"未变化的 DOM 节点会被完整保留，包括其事件监听、滚动位置、选中状态等。",[14,1046,1047,1048,1051,1052,1054],{},"Markdown 把列表当整体，但生成的 HTML 里，每个列表项 (",[64,1049,1050],{},"\u003Cli>",") 都是独立的！",[64,1053,1021],{}," 在更新后面的列表项时，能保证前面的列表项纹丝不动，状态自然就保住了。",[14,1056,1057],{},"这不就是我们梦寐以求的效果吗？在 Markdown 实时更新的同时，最大程度留住用户的操作状态，还能省掉一堆不必要的 DOM 操作！",[1013,1059,1060],{"id":1060},"示例代码",[72,1062,1064],{"className":74,"code":1063,"language":76,"meta":77,"style":77},"\u003Ctemplate>\n  \u003Cdiv ref=\"markdownContainer\" class=\"markdown-container\">\n    \u003Cdiv id=\"md-root\">\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { nextTick, ref, watch } from 'vue';\nimport MarkdownIt from 'markdown-it';\nimport morphdom from 'morphdom';\n\nconst markdownContent = ref('');\nconst markdownContainer = ref(null);\nconst md = new MarkdownIt();\n\nconst render = () => {\n  if (!markdownContainer.value.querySelector('#md-root')) return;\n\n  const newHtml = `\u003Cdiv id=\"md-root\">` + md.render(markdownContent.value) + `\u003C/div>`\n\n  morphdom(markdownContainer.value, newHtml, {\n    childrenOnly: true\n  });\n}\n\nwatch(markdownContent, () => {\n    render()\n});\n\nonMounted(async () => {\n  // 等待 Dom 被挂载上\n  await nextTick()\n  render()\n})\n\u003C/script>\n\n",[64,1065,1066,1074,1097,1117,1125,1133,1137,1147,1172,1184,1198,1202,1218,1236,1250,1254,1270,1305,1309,1347,1351,1372,1382,1387,1392,1396,1411,1418,1423,1427,1442,1447,1457,1464,1468],{"__ignoreMap":77},[81,1067,1068,1070,1072],{"class":83,"line":84},[81,1069,88],{"class":87},[81,1071,92],{"class":91},[81,1073,95],{"class":87},[81,1075,1076,1078,1080,1082,1084,1087,1090,1092,1095],{"class":83,"line":98},[81,1077,101],{"class":87},[81,1079,104],{"class":91},[81,1081,233],{"class":107},[81,1083,111],{"class":87},[81,1085,1086],{"class":190},"\"markdownContainer\"",[81,1088,1089],{"class":107}," class",[81,1091,111],{"class":87},[81,1093,1094],{"class":190},"\"markdown-container\"",[81,1096,95],{"class":87},[81,1098,1099,1101,1103,1106,1108,1111,1113,1115],{"class":83,"line":130},[81,1100,421],{"class":87},[81,1102,104],{"class":91},[81,1104,1105],{"class":107}," id",[81,1107,111],{"class":87},[81,1109,1110],{"class":190},"\"md-root\"",[81,1112,123],{"class":87},[81,1114,104],{"class":91},[81,1116,95],{"class":87},[81,1118,1119,1121,1123],{"class":83,"line":140},[81,1120,508],{"class":87},[81,1122,104],{"class":91},[81,1124,95],{"class":87},[81,1126,1127,1129,1131],{"class":83,"line":147},[81,1128,133],{"class":87},[81,1130,92],{"class":91},[81,1132,95],{"class":87},[81,1134,1135],{"class":83,"line":160},[81,1136,144],{"emptyLinePlaceholder":143},[81,1138,1139,1141,1143,1145],{"class":83,"line":197},[81,1140,88],{"class":87},[81,1142,152],{"class":91},[81,1144,155],{"class":107},[81,1146,95],{"class":87},[81,1148,1149,1151,1153,1156,1158,1160,1162,1164,1166,1168,1170],{"class":83,"line":213},[81,1150,164],{"class":163},[81,1152,167],{"class":87},[81,1154,1155],{"class":91},"nextTick",[81,1157,173],{"class":87},[81,1159,181],{"class":91},[81,1161,173],{"class":87},[81,1163,551],{"class":91},[81,1165,184],{"class":87},[81,1167,187],{"class":163},[81,1169,191],{"class":190},[81,1171,194],{"class":87},[81,1173,1174,1176,1178,1180,1182],{"class":83,"line":218},[81,1175,164],{"class":163},[81,1177,202],{"class":91},[81,1179,205],{"class":163},[81,1181,208],{"class":190},[81,1183,194],{"class":87},[81,1185,1186,1188,1191,1193,1196],{"class":83,"line":245},[81,1187,164],{"class":163},[81,1189,1190],{"class":91}," morphdom",[81,1192,205],{"class":163},[81,1194,1195],{"class":190}," 'morphdom'",[81,1197,194],{"class":87},[81,1199,1200],{"class":83,"line":263},[81,1201,144],{"emptyLinePlaceholder":143},[81,1203,1204,1206,1208,1210,1212,1214,1216],{"class":83,"line":268},[81,1205,221],{"class":163},[81,1207,225],{"class":224},[81,1209,229],{"class":228},[81,1211,233],{"class":232},[81,1213,236],{"class":87},[81,1215,239],{"class":190},[81,1217,242],{"class":87},[81,1219,1220,1222,1225,1227,1229,1231,1234],{"class":83,"line":309},[81,1221,221],{"class":163},[81,1223,1224],{"class":224}," markdownContainer",[81,1226,229],{"class":228},[81,1228,233],{"class":232},[81,1230,236],{"class":87},[81,1232,1233],{"class":107},"null",[81,1235,242],{"class":87},[81,1237,1238,1240,1242,1244,1246,1248],{"class":83,"line":314},[81,1239,221],{"class":163},[81,1241,250],{"class":224},[81,1243,229],{"class":228},[81,1245,255],{"class":163},[81,1247,202],{"class":232},[81,1249,260],{"class":87},[81,1251,1252],{"class":83,"line":326},[81,1253,144],{"emptyLinePlaceholder":143},[81,1255,1256,1258,1261,1263,1266,1268],{"class":83,"line":333},[81,1257,221],{"class":163},[81,1259,1260],{"class":232}," render",[81,1262,229],{"class":228},[81,1264,1265],{"class":87}," () ",[81,1267,284],{"class":163},[81,1269,323],{"class":87},[81,1271,1272,1275,1277,1280,1283,1285,1287,1289,1292,1294,1297,1300,1303],{"class":83,"line":339},[81,1273,1274],{"class":163},"  if",[81,1276,764],{"class":87},[81,1278,1279],{"class":228},"!",[81,1281,1282],{"class":287},"markdownContainer",[81,1284,290],{"class":87},[81,1286,303],{"class":741},[81,1288,290],{"class":87},[81,1290,1291],{"class":232},"querySelector",[81,1293,236],{"class":87},[81,1295,1296],{"class":190},"'#md-root'",[81,1298,1299],{"class":87},")) ",[81,1301,1302],{"class":163},"return",[81,1304,194],{"class":87},[81,1306,1307],{"class":83,"line":608},[81,1308,144],{"emptyLinePlaceholder":143},[81,1310,1311,1314,1317,1319,1322,1325,1327,1329,1331,1333,1335,1337,1339,1341,1344],{"class":83,"line":613},[81,1312,1313],{"class":163},"  const",[81,1315,1316],{"class":224}," newHtml",[81,1318,229],{"class":228},[81,1320,1321],{"class":190}," `\u003Cdiv id=\"md-root\">`",[81,1323,1324],{"class":228}," +",[81,1326,250],{"class":287},[81,1328,290],{"class":87},[81,1330,293],{"class":232},[81,1332,236],{"class":87},[81,1334,298],{"class":287},[81,1336,290],{"class":87},[81,1338,303],{"class":91},[81,1340,446],{"class":87},[81,1342,1343],{"class":228},"+",[81,1345,1346],{"class":190}," `\u003C/div>`\n",[81,1348,1349],{"class":83,"line":627},[81,1350,144],{"emptyLinePlaceholder":143},[81,1352,1353,1356,1358,1360,1362,1364,1366,1369],{"class":83,"line":641},[81,1354,1355],{"class":232},"  morphdom",[81,1357,236],{"class":87},[81,1359,1282],{"class":287},[81,1361,290],{"class":87},[81,1363,303],{"class":91},[81,1365,173],{"class":87},[81,1367,1368],{"class":117},"newHtml",[81,1370,1371],{"class":87},", {\n",[81,1373,1374,1377,1379],{"class":83,"line":646},[81,1375,1376],{"class":91},"    childrenOnly",[81,1378,958],{"class":957},[81,1380,1381],{"class":107}," true\n",[81,1383,1384],{"class":83,"line":654},[81,1385,1386],{"class":87},"  });\n",[81,1388,1389],{"class":83,"line":663},[81,1390,1391],{"class":87},"}\n",[81,1393,1394],{"class":83,"line":684},[81,1395,144],{"emptyLinePlaceholder":143},[81,1397,1398,1400,1402,1404,1407,1409],{"class":83,"line":721},[81,1399,551],{"class":232},[81,1401,236],{"class":87},[81,1403,298],{"class":117},[81,1405,1406],{"class":87},", () ",[81,1408,284],{"class":163},[81,1410,323],{"class":87},[81,1412,1413,1416],{"class":83,"line":727},[81,1414,1415],{"class":232},"    render",[81,1417,605],{"class":87},[81,1419,1420],{"class":83,"line":733},[81,1421,1422],{"class":87},"});\n",[81,1424,1425],{"class":83,"line":758},[81,1426,144],{"emptyLinePlaceholder":143},[81,1428,1429,1431,1433,1436,1438,1440],{"class":83,"line":803},[81,1430,176],{"class":232},[81,1432,236],{"class":87},[81,1434,1435],{"class":163},"async",[81,1437,1265],{"class":87},[81,1439,284],{"class":163},[81,1441,323],{"class":87},[81,1443,1444],{"class":83,"line":809},[81,1445,1446],{"class":329},"  // 等待 Dom 被挂载上\n",[81,1448,1449,1452,1455],{"class":83,"line":855},[81,1450,1451],{"class":163},"  await",[81,1453,1454],{"class":232}," nextTick",[81,1456,605],{"class":87},[81,1458,1459,1462],{"class":83,"line":899},[81,1460,1461],{"class":232},"  render",[81,1463,605],{"class":87},[81,1465,1466],{"class":83,"line":905},[81,1467,336],{"class":87},[81,1469,1470,1472,1474],{"class":83,"line":911},[81,1471,133],{"class":87},[81,1473,152],{"class":91},[81,1475,95],{"class":87},[1013,1477,1479],{"id":1478},"眼见为实demo-对比","眼见为实：Demo 对比",[14,1481,1482],{},"下面这个 iframe 里放了个对比 Demo，展示了不同方案的效果差异。",[14,1484,1485,1488],{},[59,1486,1487],{},"小技巧："," 如果你用的是 Chrome、Edge 这类 Chromium 内核的浏览器，打开开发者工具 (DevTools)，找到“渲染”(Rendering) 标签页，勾选「突出显示重绘区域(Paint flashing)」。这样你就能直观看到每次更新时，哪些部分被重新绘制了——重绘区域越少，性能越好！",[14,1490,1491],{},[1492,1493],"img",{"alt":77,"src":1494},"https://static.031130.xyz/uploads/2025/07/12/d5721c40fb076.webp",[1496,1497],"iframe",{"src":1498,"width":1499,"height":1500,"allowFullScreen":143,"loading":1501},"https://static.031130.xyz/demo/morphdom-vs-markdown-chunk.html","100%",500,"lazy",[10,1503,1504],{"id":1504},"阶段性成果",[14,1506,1507,1508,1510],{},"从最开始的“暴力全量刷新”，到“聪明点的分块更新”，再到如今“精准手术刀般的 ",[64,1509,1021],{}," 更新”，我们一步步把那些不必要的渲染开销给砍掉了，最终搞出了一个既快又能留住用户状态的 Markdown 实时渲染方案。",[14,1512,1513,1514,1516],{},"不过，用 ",[64,1515,1021],{}," 这个第三方库来直接操作 Vue 组件里的 DOM，总觉得有点...不够“Vue”？它虽然解决了核心的性能和状态问题，但在 Vue 的世界里这么玩，多少有点旁门左道的意思。",[14,1518,1519,1522],{},[59,1520,1521],{},"下篇预告："," 在下一篇文章里，咱们就来聊聊，在 Vue 的世界里，有没有更优雅、更“原生”的方案来搞定 Markdown 的精准更新？敬请期待！",[1524,1525,1526],"style",{},"html pre.shiki code .s5ixo, html code.shiki .s5ixo{--shiki-default:#383A42;--shiki-dark:#ABB2BF}html pre.shiki code .sJa8x, html code.shiki .sJa8x{--shiki-default:#E45649;--shiki-dark:#E06C75}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}html pre.shiki code .sz0mV, html code.shiki .sz0mV{--shiki-default:#383A42;--shiki-dark:#E06C75}html pre.shiki code .sLKXg, html code.shiki .sLKXg{--shiki-default:#A626A4;--shiki-dark:#C678DD}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html pre.shiki code .sNmU0, html code.shiki .sNmU0{--shiki-default:#986801;--shiki-dark:#E5C07B}html pre.shiki code .s_Sar, html code.shiki .s_Sar{--shiki-default:#0184BC;--shiki-dark:#56B6C2}html pre.shiki code .sAdtL, html code.shiki .sAdtL{--shiki-default:#4078F2;--shiki-dark:#61AFEF}html pre.shiki code .s7GmK, html code.shiki .s7GmK{--shiki-default:#383A42;--shiki-dark:#E5C07B}html pre.shiki code .sW2Sy, html code.shiki .sW2Sy{--shiki-default:#A0A1A7;--shiki-default-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .s8iYz, html code.shiki .s8iYz{--shiki-default:#383A42;--shiki-default-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic}html pre.shiki code .sDaw7, html code.shiki .sDaw7{--shiki-default:#0184BC;--shiki-dark:#E06C75}html pre.shiki code .sRZ4U, html code.shiki .sRZ4U{--shiki-default:#986801;--shiki-dark:#E06C75}html pre.shiki code .sYoRg, html code.shiki .sYoRg{--shiki-default:#0184BC;--shiki-dark:#D19A66}html pre.shiki code .s2QsP, html code.shiki .s2QsP{--shiki-default:#E45649;--shiki-dark:#E5C07B}html pre.shiki code .st7oF, html code.shiki .st7oF{--shiki-default:#0184BC;--shiki-dark:#ABB2BF}",{"title":77,"searchDepth":98,"depth":98,"links":1528},[1529,1530,1531,1532,1537],{"id":12,"depth":98,"text":12},{"id":48,"depth":98,"text":49},{"id":348,"depth":98,"text":349},{"id":1007,"depth":98,"text":1008,"children":1533},[1534,1535,1536],{"id":1015,"depth":130,"text":1016},{"id":1060,"depth":130,"text":1060},{"id":1478,"depth":130,"text":1479},{"id":1504,"depth":98,"text":1504},"2025-07-12 20:48:56","md","zh-CN",{},"/2025/07/12/vue-markdown-render-improvement-1","---\ntitle: Vue Markdown 渲染优化实战(上)：从暴力刷新、分块更新到 Morphdom 的华丽变身\ndate: 2025-07-12 20:48:56\nsticky:\ntags:\n- Vue.js\n- Markdown\n- JavaScript\n- Web\n- HTML\n---\n\n## 需求背景\n\n在最近接手的 AI 需求中，需要实现一个类似 ChatGPT 的对话交互界面。其核心流程是：后端通过 SSE（Server-Sent  Events）协议，持续地将 AI 生成的 Markdown 格式文本片段推送到前端。前端负责动态接收并拼接这些 Markdown  片段，最终将拼接完成的 Markdown 文本实时渲染并显示在用户界面上。\n\nMarkdown 渲染并不是什么罕见的需求，尤其是在 LLM 相关落地产品满天飞的当下。不同于 React 生态拥有一个 14k+ star 的著名第三方库——[react-markdown](https://github.com/remarkjs/react-markdown)，Vue 这边似乎暂时还没有一个仍在活跃维护的、star 数量不低（起码得 2k+ 吧？）的 markdown 渲染库。[cloudacy/vue-markdown-render](https://github.com/cloudacy/vue-markdown-render#readme) 最后一次发版在一年前，但截止本文写作时间只有 103 个 star；[miaolz123/vue-markdown](https://github.com/miaolz123/vue-markdown) 有 2k star，但最后一次 commit 已经是 7 年前了；[zhaoxuhui1122/vue-markdown](https://github.com/zhaoxuhui1122/vue-markdown) 更是 archived 状态。\n\n## 第一版方案：简单粗暴的 v-html\n\n简单调研了一圈，发现 Vue 生态里确实缺少一个能打的 Markdown 渲染库。既然没有现成的轮子，那咱就自己造一个！\n\n根据大部分文章以及 LLM 的推荐，我们首先采用 markdown-it 这个第三方库将 markdown 转换为 html 字符串，再通过 v-html 传入。\n\n**PS:** 我们这里假设 Markdown 内容是可信的（比如由我们自己的 AI 生成）。如果内容来自用户输入，一定要使用 `DOMPurify` 这类库来防止 XSS 攻击，避免给网站“开天窗”哦！\n\n示例代码如下：\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv v-html=\"renderedHtml\">\u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { computed, onMounted, ref } from 'vue';\nimport MarkdownIt from 'markdown-it';\n\nconst markdownContent = ref('');\nconst md = new MarkdownIt();\n\nconst renderedHtml = computed(() => md.render(markdownContent.value))\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n```\n\n## 进化版：给 Markdown 分块更新\n\n上述方案虽然能实现基础渲染，但在实时更新场景下存在明显缺陷：**每次接收到新的 Markdown 片段，整个文档都会触发全量重渲染**。即使只有最后一行是新增内容，整个文档的 DOM 也会被完全替换。这导致两个核心问题：\n\n1. **性能顶不住：**Markdown 内容增长时，`markdown-it` 解析和 DOM 重建的开销呈线性上升。\n2. **交互状态丢失：**全量刷新会把用户当前的操作状态冲掉。最明显的就是，如果你选中了某段文字，一刷新，选中状态就没了！\n\n为了解决这两个问题，[我们在网上找到了分块渲染的方案](https://juejin.cn/post/7480900772386734143) —— 把 Markdown 按两个连续的换行符 (`\\n\\n`) 切成一块一块的。这样每次更新，只重新渲染最后一块新的，前面的老块直接复用缓存。好处很明显：\n\n- 用户如果选中了前面块里的文字，下次更新时选中状态不会丢（因为前面的块没动）。\n- 需要重新渲染的 DOM 变少了，性能自然就上来了。\n\n代码调整后像这样：\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv>\n    \u003Cdiv\n      v-for=\"(block, idx) in renderedBlocks\"\n      :key=\"idx\"\n      v-html=\"block\"\n      class=\"markdown-block\"\n    >\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { ref, computed, watch } from 'vue'\nimport MarkdownIt from 'markdown-it'\n\nconst markdownContent = ref('')\nconst md = new MarkdownIt()\n\nconst renderedBlocks = ref([])\nconst blockCache = ref([])\n\nwatch(\n  markdownContent,\n  (newContent, oldContent) => {\n    const blocks = newContent.split(/\\n{2,}/)\n    // 只重新渲染最后一个块，其余用缓存\n    // 处理块减少、块增多的场景\n    blockCache.value.length = blocks.length\n    for (let i = 0; i \u003C blocks.length; i++) {\n      // 只渲染最后一个，或新块\n      if (i === blocks.length - 1 || !blockCache.value[i]) {\n        blockCache.value[i] = md.render(blocks[i] || '')\n      }\n      // 其余块直接复用\n    }\n    renderedBlocks.value = blockCache.value.slice()\n  },\n  { immediate: true }\n)\n\nonMounted(() => {\n  // markdownContent.value = await fetch() ...\n})\n\u003C/script>\n```\n\n## 终极武器：用 morphdom 实现精准更新\n\n分块渲染虽然解决了大部分问题，但遇到 Markdown 列表就有点力不从心了。因为 Markdown 语法里，列表项之间通常只有一个换行符，整个列表会被当成一个大块。想象一下一个几百项的列表，哪怕只更新最后一项，整个列表块也要全部重来，前面的问题又回来了。\n\n### morphdom 是何方神圣？\n\n`morphdom` 是一个仅 5KB（gzip 后）的 JavaScript 库，核心功能是：**接收两个 DOM 节点（或 HTML 字符串），计算出最小化的 DOM 操作，将第一个节点 “变形” 为第二个节点，而非直接替换**。\n\n其工作原理类似虚拟 DOM 的 Diff 算法，但**直接操作真实 DOM**：\n\n1. 对比新旧 DOM 的标签名、属性、文本内容等；\n2. 仅对差异部分执行增 / 删 / 改操作（如修改文本、更新属性、移动节点位置）；\n3. 未变化的 DOM 节点会被完整保留，包括其事件监听、滚动位置、选中状态等。\n\nMarkdown 把列表当整体，但生成的 HTML 里，每个列表项 (`\u003Cli>`) 都是独立的！`morphdom` 在更新后面的列表项时，能保证前面的列表项纹丝不动，状态自然就保住了。\n\n这不就是我们梦寐以求的效果吗？在 Markdown 实时更新的同时，最大程度留住用户的操作状态，还能省掉一堆不必要的 DOM 操作！\n\n### 示例代码\n\n```vue\n\u003Ctemplate>\n  \u003Cdiv ref=\"markdownContainer\" class=\"markdown-container\">\n    \u003Cdiv id=\"md-root\">\u003C/div>\n  \u003C/div>\n\u003C/template>\n\n\u003Cscript setup>\nimport { nextTick, ref, watch } from 'vue';\nimport MarkdownIt from 'markdown-it';\nimport morphdom from 'morphdom';\n\nconst markdownContent = ref('');\nconst markdownContainer = ref(null);\nconst md = new MarkdownIt();\n\nconst render = () => {\n  if (!markdownContainer.value.querySelector('#md-root')) return;\n\n  const newHtml = `\u003Cdiv id=\"md-root\">` + md.render(markdownContent.value) + `\u003C/div>`\n\n  morphdom(markdownContainer.value, newHtml, {\n    childrenOnly: true\n  });\n}\n\nwatch(markdownContent, () => {\n    render()\n});\n\nonMounted(async () => {\n  // 等待 Dom 被挂载上\n  await nextTick()\n  render()\n})\n\u003C/script>\n\n```\n\n### 眼见为实：Demo 对比\n\n下面这个 iframe 里放了个对比 Demo，展示了不同方案的效果差异。\n\n**小技巧：** 如果你用的是 Chrome、Edge 这类 Chromium 内核的浏览器，打开开发者工具 (DevTools)，找到“渲染”(Rendering) 标签页，勾选「突出显示重绘区域(Paint flashing)」。这样你就能直观看到每次更新时，哪些部分被重新绘制了——重绘区域越少，性能越好！\n\n![](https://static.031130.xyz/uploads/2025/07/12/d5721c40fb076.webp)\n\n\u003Ciframe src=\"https://static.031130.xyz/demo/morphdom-vs-markdown-chunk.html\" width=\"100%\" height=\"500\" allowfullscreen loading=\"lazy\">\u003C/iframe>\n\n## 阶段性成果\n\n从最开始的“暴力全量刷新”，到“聪明点的分块更新”，再到如今“精准手术刀般的 `morphdom` 更新”，我们一步步把那些不必要的渲染开销给砍掉了，最终搞出了一个既快又能留住用户状态的 Markdown 实时渲染方案。\n\n不过，用 `morphdom` 这个第三方库来直接操作 Vue 组件里的 DOM，总觉得有点...不够“Vue”？它虽然解决了核心的性能和状态问题，但在 Vue 的世界里这么玩，多少有点旁门左道的意思。\n\n**下篇预告：** 在下一篇文章里，咱们就来聊聊，在 Vue 的世界里，有没有更优雅、更“原生”的方案来搞定 Markdown 的精准更新？敬请期待！\n",{"title":5,"description":77},"posts/vue-markdown-render-improvement-1",false,[1548,1549,1550,1551,1552],"Vue.js","Markdown","JavaScript","Web","HTML","PzhKNFSAik0h1pScBCrR6o2b7YOstRHpicvQb4IF220",[1555,1560],{"title":1556,"path":1557,"stem":1558,"date":1559,"children":-1},"Vue Markdown 渲染优化实战(下)：告别 DOM 操作，拥抱 AST 与函数式渲染","/2025/07/13/vue-markdown-render-improvement-2","posts/vue-markdown-render-improvement-2","2025-07-13 00:01:35",{"title":1561,"path":1562,"stem":1563,"date":1564,"children":-1},"node-sass 迁移至 dart-sass 踩坑实录","/2025/07/05/node-sass-migration-to-dart-sass","posts/node-sass-migration-to-dart-sass","2025-07-05 17:57:02",1762969853038]