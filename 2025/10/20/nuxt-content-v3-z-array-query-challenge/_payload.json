[{"data":1,"prerenderedAt":979},["ShallowReactive",2],{"post-2025-10-20-nuxt-content-v3-z-array-query-challenge":3,"surround-2025-10-20-nuxt-content-v3-z-array-query-challenge":971,"randomIndex/2025/10/20/nuxt-content-v3-z-array-query-challenge":978},{"id":4,"title":5,"body":6,"date":957,"description":958,"extension":959,"meta":960,"navigation":157,"path":961,"rawbody":962,"seo":963,"stem":964,"sticky":965,"tags":966,"__hash__":970},"posts/posts/nuxt-content-v3-z-array-query-challenge.md","Nuxt Content v3 中数组字段的筛选困境与性能优化",{"type":7,"value":8,"toc":951},"minimark",[9,27,30,94,101,106,116,208,223,383,393,403,407,410,655,661,679,686,691,695,708,726,732,746,898,901,911,917,923,928,931,938,947],[10,11,12,13,17,18,21,22,26],"p",{},"Nuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 ",[14,15,16],"strong",{},"Nuxt v4 + Nuxt Content v3"," 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API ",[14,19,20],{},"并未直接提供","对数组字段进行“包含”（",[23,24,25],"code",{},"$contains","）操作的支持。",[10,28,29],{},"例如，这是我的正在写的这篇博客的 Front Matter：",[31,32,37],"pre",{"className":33,"code":34,"language":35,"meta":36,"style":36},"language-markdown shiki shiki-themes github-light github-dark","---\ntitle: Nuxt Content v3 中数组字段的筛选困境\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n","markdown","",[23,38,39,47,53,59,65,71,77,83,89],{"__ignoreMap":36},[40,41,44],"span",{"class":42,"line":43},"line",1,[40,45,46],{},"---\n",[40,48,50],{"class":42,"line":49},2,[40,51,52],{},"title: Nuxt Content v3 中数组字段的筛选困境\n",[40,54,56],{"class":42,"line":55},3,[40,57,58],{},"date: 2025-10-20 21:52:59\n",[40,60,62],{"class":42,"line":61},4,[40,63,64],{},"sticky:\n",[40,66,68],{"class":42,"line":67},5,[40,69,70],{},"tags:\n",[40,72,74],{"class":42,"line":73},6,[40,75,76],{},"- Nuxt\n",[40,78,80],{"class":42,"line":79},7,[40,81,82],{},"- Nuxt Content\n",[40,84,86],{"class":42,"line":85},8,[40,87,88],{},"- JavaScript\n",[40,90,92],{"class":42,"line":91},9,[40,93,46],{},[10,95,96,97,100],{},"我的目标是创建一个 ",[14,98,99],{},"Tag 页面","，列出所有包含特定 Tag（例如 'Nuxt'）的文章。",[102,103,105],"h2",{"id":104},"v2-的便捷与-v3-的限制","v2 的便捷与 v3 的限制",[10,107,108,109,112,113,115],{},"在 Nuxt Content v2 中，数据基于文件系统存储，查询方式是对文件内容的抽象，模拟了类似 ",[14,110,111],{},"MongoDB 的 JSON 文档查询","语法。我们可以轻松地使用 ",[23,114,25],{}," 方法获取所有包含 “Nuxt” 标签的文章：",[31,117,121],{"className":118,"code":119,"language":120,"meta":36,"style":36},"language-typescript shiki shiki-themes github-light github-dark","const tag = decodeURIComponent(route.params.tag as string)\n\nconst articles = await queryContent('posts')\n  .where({ tags: { $contains: tag } })  // ✅ v2 中的 MongoDB Style 查询\n  .find()\n","typescript",[23,122,123,153,159,183,198],{"__ignoreMap":36},[40,124,125,129,133,136,140,144,147,150],{"class":42,"line":43},[40,126,128],{"class":127},"szBVR","const",[40,130,132],{"class":131},"sj4cs"," tag",[40,134,135],{"class":127}," =",[40,137,139],{"class":138},"sScJk"," decodeURIComponent",[40,141,143],{"class":142},"sVt8B","(route.params.tag ",[40,145,146],{"class":127},"as",[40,148,149],{"class":131}," string",[40,151,152],{"class":142},")\n",[40,154,155],{"class":42,"line":49},[40,156,158],{"emptyLinePlaceholder":157},true,"\n",[40,160,161,163,166,168,171,174,177,181],{"class":42,"line":55},[40,162,128],{"class":127},[40,164,165],{"class":131}," articles",[40,167,135],{"class":127},[40,169,170],{"class":127}," await",[40,172,173],{"class":138}," queryContent",[40,175,176],{"class":142},"(",[40,178,180],{"class":179},"sZZnC","'posts'",[40,182,152],{"class":142},[40,184,185,188,191,194],{"class":42,"line":61},[40,186,187],{"class":142},"  .",[40,189,190],{"class":138},"where",[40,192,193],{"class":142},"({ tags: { $contains: tag } })  ",[40,195,197],{"class":196},"sJ8bj","// ✅ v2 中的 MongoDB Style 查询\n",[40,199,200,202,205],{"class":42,"line":67},[40,201,187],{"class":142},[40,203,204],{"class":138},"find",[40,206,207],{"class":142},"()\n",[10,209,210,211,218,219,222],{},"但在使用 ",[14,212,213,214,217],{},"Nuxt Content v3 的 ",[23,215,216],{},"queryCollection"," API"," 时，我们很自然地会尝试使用 ",[23,220,221],{},".where()"," 方法进行筛选：",[31,224,226],{"className":118,"code":225,"language":120,"meta":36,"style":36},"const tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${tag}`, () =>\n    queryCollection('posts')\n        .where(tag, 'in', 'tags')  // ❌ 这样会报错，因为第一次参数必须是字段名\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n",[23,227,228,246,250,288,299,324,343,370,379],{"__ignoreMap":36},[40,229,230,232,234,236,238,240,242,244],{"class":42,"line":43},[40,231,128],{"class":127},[40,233,132],{"class":131},[40,235,135],{"class":127},[40,237,139],{"class":138},[40,239,143],{"class":142},[40,241,146],{"class":127},[40,243,149],{"class":131},[40,245,152],{"class":142},[40,247,248],{"class":42,"line":49},[40,249,158],{"emptyLinePlaceholder":157},[40,251,252,254,257,260,263,266,268,271,273,276,279,282,285],{"class":42,"line":55},[40,253,128],{"class":127},[40,255,256],{"class":142}," { ",[40,258,259],{"class":131},"data",[40,261,262],{"class":142}," } ",[40,264,265],{"class":127},"=",[40,267,170],{"class":127},[40,269,270],{"class":138}," useAsyncData",[40,272,176],{"class":142},[40,274,275],{"class":179},"`tag-${",[40,277,278],{"class":142},"tag",[40,280,281],{"class":179},"}`",[40,283,284],{"class":142},", () ",[40,286,287],{"class":127},"=>\n",[40,289,290,293,295,297],{"class":42,"line":61},[40,291,292],{"class":138},"    queryCollection",[40,294,176],{"class":142},[40,296,180],{"class":179},[40,298,152],{"class":142},[40,300,301,304,306,309,312,315,318,321],{"class":42,"line":67},[40,302,303],{"class":142},"        .",[40,305,190],{"class":138},[40,307,308],{"class":142},"(tag, ",[40,310,311],{"class":179},"'in'",[40,313,314],{"class":142},", ",[40,316,317],{"class":179},"'tags'",[40,319,320],{"class":142},")  ",[40,322,323],{"class":196},"// ❌ 这样会报错，因为第一次参数必须是字段名\n",[40,325,326,328,331,333,336,338,341],{"class":42,"line":73},[40,327,303],{"class":142},[40,329,330],{"class":138},"order",[40,332,176],{"class":142},[40,334,335],{"class":179},"'date'",[40,337,314],{"class":142},[40,339,340],{"class":179},"'DESC'",[40,342,152],{"class":142},[40,344,345,347,350,352,355,357,359,361,364,366,368],{"class":42,"line":79},[40,346,303],{"class":142},[40,348,349],{"class":138},"select",[40,351,176],{"class":142},[40,353,354],{"class":179},"'title'",[40,356,314],{"class":142},[40,358,335],{"class":179},[40,360,314],{"class":142},[40,362,363],{"class":179},"'path'",[40,365,314],{"class":142},[40,367,317],{"class":179},[40,369,152],{"class":142},[40,371,372,374,377],{"class":42,"line":85},[40,373,303],{"class":142},[40,375,376],{"class":138},"all",[40,378,207],{"class":142},[40,380,381],{"class":42,"line":91},[40,382,152],{"class":142},[10,384,385,386,388,389,392],{},"遗憾的是，这样是行不通的。",[23,387,221],{}," 的方法签名要求字段名必须作为首个参数传入：",[23,390,391],{},"where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)","。",[10,394,395,396,399,400,402],{},"由于 Nuxt Content v3 ",[14,397,398],{},"底层采用 SQLite 作为本地数据库","，所有查询都必须遵循类 SQL 语法。如果设计时未提供针对数组字段的内置操作符（例如 ",[23,401,25],{}," 的 SQL 等价形式），最终的解决方案往往会显得比较“别扭”。",[102,404,406],{"id":405},"初版实现牺牲性能的全量拉取","初版实现：牺牲性能的“全量拉取”",[10,408,409],{},"本着“尽快重构，后续优化”的思路，我写出了以下代码：",[31,411,413],{"className":118,"code":412,"language":120,"meta":36,"style":36},"// 初版实现：全量拉取后使用 JS 筛选\nconst allPosts = (\n    await useAsyncData(`tag-${route.params.tag}`, () =>\n        queryCollection('posts')\n            .order('date', 'DESC')\n            .select('title', 'date', 'path', 'tags')\n            .all()\n    )\n).data as Ref\u003CPost[]>\n\nconst Posts = computed(() => {\n    return allPosts.value.filter(post =>\n        typeof post.tags?.map === 'function'\n            ? post.tags?.includes(decodeURIComponent(route.params.tag as string))\n            : false\n    )\n})\n",[23,414,415,420,432,462,473,490,514,522,527,546,551,573,594,609,635,644,649],{"__ignoreMap":36},[40,416,417],{"class":42,"line":43},[40,418,419],{"class":196},"// 初版实现：全量拉取后使用 JS 筛选\n",[40,421,422,424,427,429],{"class":42,"line":49},[40,423,128],{"class":127},[40,425,426],{"class":138}," allPosts",[40,428,135],{"class":127},[40,430,431],{"class":142}," (\n",[40,433,434,437,439,441,443,446,449,452,454,456,458,460],{"class":42,"line":55},[40,435,436],{"class":127},"    await",[40,438,270],{"class":138},[40,440,176],{"class":142},[40,442,275],{"class":179},[40,444,445],{"class":142},"route",[40,447,448],{"class":179},".",[40,450,451],{"class":142},"params",[40,453,448],{"class":179},[40,455,278],{"class":142},[40,457,281],{"class":179},[40,459,284],{"class":142},[40,461,287],{"class":127},[40,463,464,467,469,471],{"class":42,"line":61},[40,465,466],{"class":138},"        queryCollection",[40,468,176],{"class":142},[40,470,180],{"class":179},[40,472,152],{"class":142},[40,474,475,478,480,482,484,486,488],{"class":42,"line":67},[40,476,477],{"class":142},"            .",[40,479,330],{"class":138},[40,481,176],{"class":142},[40,483,335],{"class":179},[40,485,314],{"class":142},[40,487,340],{"class":179},[40,489,152],{"class":142},[40,491,492,494,496,498,500,502,504,506,508,510,512],{"class":42,"line":73},[40,493,477],{"class":142},[40,495,349],{"class":138},[40,497,176],{"class":142},[40,499,354],{"class":179},[40,501,314],{"class":142},[40,503,335],{"class":179},[40,505,314],{"class":142},[40,507,363],{"class":179},[40,509,314],{"class":142},[40,511,317],{"class":179},[40,513,152],{"class":142},[40,515,516,518,520],{"class":42,"line":79},[40,517,477],{"class":142},[40,519,376],{"class":138},[40,521,207],{"class":142},[40,523,524],{"class":42,"line":85},[40,525,526],{"class":142},"    )\n",[40,528,529,532,534,537,540,543],{"class":42,"line":91},[40,530,531],{"class":142},").data ",[40,533,146],{"class":127},[40,535,536],{"class":138}," Ref",[40,538,539],{"class":142},"\u003C",[40,541,542],{"class":138},"Post",[40,544,545],{"class":142},"[]>\n",[40,547,549],{"class":42,"line":548},10,[40,550,158],{"emptyLinePlaceholder":157},[40,552,554,556,559,561,564,567,570],{"class":42,"line":553},11,[40,555,128],{"class":127},[40,557,558],{"class":131}," Posts",[40,560,135],{"class":127},[40,562,563],{"class":138}," computed",[40,565,566],{"class":142},"(() ",[40,568,569],{"class":127},"=>",[40,571,572],{"class":142}," {\n",[40,574,576,579,582,585,587,591],{"class":42,"line":575},12,[40,577,578],{"class":127},"    return",[40,580,581],{"class":142}," allPosts.value.",[40,583,584],{"class":138},"filter",[40,586,176],{"class":142},[40,588,590],{"class":589},"s4XuR","post",[40,592,593],{"class":127}," =>\n",[40,595,597,600,603,606],{"class":42,"line":596},13,[40,598,599],{"class":127},"        typeof",[40,601,602],{"class":142}," post.tags?.map ",[40,604,605],{"class":127},"===",[40,607,608],{"class":179}," 'function'\n",[40,610,612,615,618,621,623,626,628,630,632],{"class":42,"line":611},14,[40,613,614],{"class":127},"            ?",[40,616,617],{"class":142}," post.tags?.",[40,619,620],{"class":138},"includes",[40,622,176],{"class":142},[40,624,625],{"class":138},"decodeURIComponent",[40,627,143],{"class":142},[40,629,146],{"class":127},[40,631,149],{"class":131},[40,633,634],{"class":142},"))\n",[40,636,638,641],{"class":42,"line":637},15,[40,639,640],{"class":127},"            :",[40,642,643],{"class":131}," false\n",[40,645,647],{"class":42,"line":646},16,[40,648,526],{"class":142},[40,650,652],{"class":42,"line":651},17,[40,653,654],{"class":142},"})\n",[10,656,657,658],{},"这种方法虽然满足了需求，但也带来了明显的性能代价：",[14,659,660],{},"_payload.json 文件体积的膨胀。",[10,662,663,664,667,668,671,672,675,676,678],{},"在 Nuxt 项目中，",[23,665,666],{},"_payload.json"," 用于存储 ",[23,669,670],{},"useAsyncData"," 的结果等动态数据。在全量拉取的方案下，",[14,673,674],{},"每一个 Tag 页面"," 都会加载包含所有文章信息的 ",[23,677,666],{},"，造成数据冗余。很多 Tag 页面仅需一两篇文章的数据，却被迫加载了全部文章信息，严重影响了性能。",[10,680,681],{},[682,683],"img",{"alt":684,"src":685},"tags 目录占据了 2.9MiB，是所有目录中最大的","https://static.031130.xyz/uploads/2025/10/20/a748878c03c64.webp",[10,687,688],{},[682,689],{"alt":666,"src":690},"https://static.031130.xyz/uploads/2025/10/20/8ef786d873da1.webp",[102,692,694],{"id":693},"讨巧方案利用-sqlite-的存储特性进行优化","讨巧方案：利用 SQLite 的存储特性进行优化",[10,696,697,698,700,701,392],{},"为了减少 ",[23,699,670],{}," 返回的查询结果，我查阅了 Nuxt Content 的 GitHub Discussions，发现",[702,703,707],"a",{"href":704,"rel":705},"https://github.com/nuxt/content/discussions/2955",[706],"nofollow","在 v3.alpha.8 版本时就有人提出了一种“巧妙”的解决方案",[10,709,710,711,721,722,725],{},"由于 Nuxt Content v3 使用 SQLite 数据库，原本在 Front Matter 中定义的 ",[14,712,713,716,717,720],{},[23,714,715],{},"tags"," 数组（通过 ",[23,718,719],{},"z.array()"," 定义）最终会以 JSON 字符串的形式存储","在数据库中（具体格式可在 ",[23,723,724],{},".nuxt/content/sql_dump.txt"," 文件中查看）。",[10,727,728],{},[682,729],{"alt":730,"src":731},"sql_dump.txt","https://static.031130.xyz/uploads/2025/10/20/b70036c55bb29.webp",[10,733,734,735,738,739,745],{},"这意味着我们可以利用 SQLite 的",[14,736,737],{},"字符串操作","特性，通过 ",[14,740,741,744],{},[23,742,743],{},"LIKE"," 动词配合通配符","来完成数组包含的筛选，本质上是查询 JSON 字符串是否包含特定子串：",[31,747,749],{"className":118,"code":748,"language":120,"meta":36,"style":36},"const tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${route.params.tag}`, () =>\n    queryCollection('posts')\n        .where('tags', 'LIKE', `%\"${tag}\"%`)\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n",[23,750,751,769,773,809,819,846,862,886,894],{"__ignoreMap":36},[40,752,753,755,757,759,761,763,765,767],{"class":42,"line":43},[40,754,128],{"class":127},[40,756,132],{"class":131},[40,758,135],{"class":127},[40,760,139],{"class":138},[40,762,143],{"class":142},[40,764,146],{"class":127},[40,766,149],{"class":131},[40,768,152],{"class":142},[40,770,771],{"class":42,"line":49},[40,772,158],{"emptyLinePlaceholder":157},[40,774,775,777,779,781,783,785,787,789,791,793,795,797,799,801,803,805,807],{"class":42,"line":55},[40,776,128],{"class":127},[40,778,256],{"class":142},[40,780,259],{"class":131},[40,782,262],{"class":142},[40,784,265],{"class":127},[40,786,170],{"class":127},[40,788,270],{"class":138},[40,790,176],{"class":142},[40,792,275],{"class":179},[40,794,445],{"class":142},[40,796,448],{"class":179},[40,798,451],{"class":142},[40,800,448],{"class":179},[40,802,278],{"class":142},[40,804,281],{"class":179},[40,806,284],{"class":142},[40,808,287],{"class":127},[40,810,811,813,815,817],{"class":42,"line":61},[40,812,292],{"class":138},[40,814,176],{"class":142},[40,816,180],{"class":179},[40,818,152],{"class":142},[40,820,821,823,825,827,829,831,834,836,839,841,844],{"class":42,"line":67},[40,822,303],{"class":142},[40,824,190],{"class":138},[40,826,176],{"class":142},[40,828,317],{"class":179},[40,830,314],{"class":142},[40,832,833],{"class":179},"'LIKE'",[40,835,314],{"class":142},[40,837,838],{"class":179},"`%\"${",[40,840,278],{"class":142},[40,842,843],{"class":179},"}\"%`",[40,845,152],{"class":142},[40,847,848,850,852,854,856,858,860],{"class":42,"line":73},[40,849,303],{"class":142},[40,851,330],{"class":138},[40,853,176],{"class":142},[40,855,335],{"class":179},[40,857,314],{"class":142},[40,859,340],{"class":179},[40,861,152],{"class":142},[40,863,864,866,868,870,872,874,876,878,880,882,884],{"class":42,"line":79},[40,865,303],{"class":142},[40,867,349],{"class":138},[40,869,176],{"class":142},[40,871,354],{"class":179},[40,873,314],{"class":142},[40,875,335],{"class":179},[40,877,314],{"class":142},[40,879,363],{"class":179},[40,881,314],{"class":142},[40,883,317],{"class":179},[40,885,152],{"class":142},[40,887,888,890,892],{"class":42,"line":85},[40,889,303],{"class":142},[40,891,376],{"class":138},[40,893,207],{"class":142},[40,895,896],{"class":42,"line":91},[40,897,152],{"class":142},[10,899,900],{},"下面是优化后重新生成的文件占用，体积减小还是非常显著的",[902,903,904,908],"ul",{},[905,906,907],"li",{},"tags 目录体积: 2.9MiB -> 1.4MiB",[905,909,910],{},"单个 _payload.json 的体积: 23.1KiB -> 1.01 KiB",[10,912,913,914,916],{},"通过这种方法，我们成功将查询逻辑下推到了数据库层，避免了不必要的全量数据传输，显著降低了单个目录中 ",[23,915,666],{}," 的体积，实现了性能优化。",[10,918,919],{},[682,920],{"alt":921,"src":922},"tags 目录体积下降","https://static.031130.xyz/uploads/2025/10/20/007e72e7b476d.webp",[10,924,925],{},[682,926],{"alt":666,"src":927},"https://static.031130.xyz/uploads/2025/10/20/17ba3ccbbdf9e.webp",[102,929,930],{"id":930},"参见",[10,932,933],{},[702,934,937],{"href":935,"rel":936},"https://content.nuxt.com/docs/utils/query-collection#wherefield-keyof-collection-string-operator-sqloperator-value-unknown",[706],"queryCollection - Nuxt Content",[10,939,940],{},[702,941,943,944,946],{"href":704,"rel":942},[706],"How do you query ",[23,945,719],{}," fields (e.g. tags) in the latest nuxt-content module (v3.alpha.8) · nuxt/content · Discussion #2955",[948,949,950],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .szBVR, html code.shiki .szBVR{--shiki-default:#D73A49;--shiki-dark:#F97583}html pre.shiki code .sj4cs, html code.shiki .sj4cs{--shiki-default:#005CC5;--shiki-dark:#79B8FF}html pre.shiki code .sScJk, html code.shiki .sScJk{--shiki-default:#6F42C1;--shiki-dark:#B392F0}html pre.shiki code .sVt8B, html code.shiki .sVt8B{--shiki-default:#24292E;--shiki-dark:#E1E4E8}html pre.shiki code .sZZnC, html code.shiki .sZZnC{--shiki-default:#032F62;--shiki-dark:#9ECBFF}html pre.shiki code .sJ8bj, html code.shiki .sJ8bj{--shiki-default:#6A737D;--shiki-dark:#6A737D}html pre.shiki code .s4XuR, html code.shiki .s4XuR{--shiki-default:#E36209;--shiki-dark:#FFAB70}",{"title":36,"searchDepth":49,"depth":49,"links":952},[953,954,955,956],{"id":104,"depth":49,"text":105},{"id":405,"depth":49,"text":406},{"id":693,"depth":49,"text":694},{"id":930,"depth":49,"text":930},"2025-10-20 21:52:59","Nuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 Nuxt v4 + Nuxt Content v3 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API 并未直接提供对数组字段进行“包含”（$contains）操作的支持。","md",{},"/2025/10/20/nuxt-content-v3-z-array-query-challenge","---\ntitle: Nuxt Content v3 中数组字段的筛选困境与性能优化\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n\nNuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 **Nuxt v4 + Nuxt Content v3** 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API **并未直接提供**对数组字段进行“包含”（`$contains`）操作的支持。\n\n例如，这是我的正在写的这篇博客的 Front Matter：\n\n```markdown\n---\ntitle: Nuxt Content v3 中数组字段的筛选困境\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n```\n\n我的目标是创建一个 **Tag 页面**，列出所有包含特定 Tag（例如 'Nuxt'）的文章。\n\n## v2 的便捷与 v3 的限制\n\n在 Nuxt Content v2 中，数据基于文件系统存储，查询方式是对文件内容的抽象，模拟了类似 **MongoDB 的 JSON 文档查询**语法。我们可以轻松地使用 `$contains` 方法获取所有包含 “Nuxt” 标签的文章：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst articles = await queryContent('posts')\n  .where({ tags: { $contains: tag } })  // ✅ v2 中的 MongoDB Style 查询\n  .find()\n```\n\n但在使用 **Nuxt Content v3 的 `queryCollection` API** 时，我们很自然地会尝试使用 `.where()` 方法进行筛选：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${tag}`, () =>\n    queryCollection('posts')\n        .where(tag, 'in', 'tags')  // ❌ 这样会报错，因为第一次参数必须是字段名\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n```\n\n遗憾的是，这样是行不通的。`.where()` 的方法签名要求字段名必须作为首个参数传入：`where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`。\n\n由于 Nuxt Content v3 **底层采用 SQLite 作为本地数据库**，所有查询都必须遵循类 SQL 语法。如果设计时未提供针对数组字段的内置操作符（例如 `$contains` 的 SQL 等价形式），最终的解决方案往往会显得比较“别扭”。\n\n## 初版实现：牺牲性能的“全量拉取”\n\n本着“尽快重构，后续优化”的思路，我写出了以下代码：\n\n```typescript\n// 初版实现：全量拉取后使用 JS 筛选\nconst allPosts = (\n    await useAsyncData(`tag-${route.params.tag}`, () =>\n        queryCollection('posts')\n            .order('date', 'DESC')\n            .select('title', 'date', 'path', 'tags')\n            .all()\n    )\n).data as Ref\u003CPost[]>\n\nconst Posts = computed(() => {\n    return allPosts.value.filter(post =>\n        typeof post.tags?.map === 'function'\n            ? post.tags?.includes(decodeURIComponent(route.params.tag as string))\n            : false\n    )\n})\n```\n\n这种方法虽然满足了需求，但也带来了明显的性能代价：**\\_payload.json 文件体积的膨胀。**\n\n在 Nuxt 项目中，`_payload.json` 用于存储 `useAsyncData` 的结果等动态数据。在全量拉取的方案下，**每一个 Tag 页面** 都会加载包含所有文章信息的 `_payload.json`，造成数据冗余。很多 Tag 页面仅需一两篇文章的数据，却被迫加载了全部文章信息，严重影响了性能。\n\n![tags 目录占据了 2.9MiB，是所有目录中最大的](https://static.031130.xyz/uploads/2025/10/20/a748878c03c64.webp)\n\n![_payload.json](https://static.031130.xyz/uploads/2025/10/20/8ef786d873da1.webp)\n\n## 讨巧方案：利用 SQLite 的存储特性进行优化\n\n为了减少 `useAsyncData` 返回的查询结果，我查阅了 Nuxt Content 的 GitHub Discussions，发现[在 v3.alpha.8 版本时就有人提出了一种“巧妙”的解决方案](https://github.com/nuxt/content/discussions/2955)。\n\n由于 Nuxt Content v3 使用 SQLite 数据库，原本在 Front Matter 中定义的 **`tags` 数组（通过 `z.array()` 定义）最终会以 JSON 字符串的形式存储**在数据库中（具体格式可在 `.nuxt/content/sql_dump.txt` 文件中查看）。\n\n![sql_dump.txt](https://static.031130.xyz/uploads/2025/10/20/b70036c55bb29.webp)\n\n这意味着我们可以利用 SQLite 的**字符串操作**特性，通过 **`LIKE` 动词配合通配符**来完成数组包含的筛选，本质上是查询 JSON 字符串是否包含特定子串：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${route.params.tag}`, () =>\n    queryCollection('posts')\n        .where('tags', 'LIKE', `%\"${tag}\"%`)\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n```\n\n下面是优化后重新生成的文件占用，体积减小还是非常显著的\n\n- tags 目录体积: 2.9MiB -> 1.4MiB\n- 单个 _payload.json 的体积: 23.1KiB -> 1.01 KiB\n\n通过这种方法，我们成功将查询逻辑下推到了数据库层，避免了不必要的全量数据传输，显著降低了单个目录中 `_payload.json` 的体积，实现了性能优化。\n\n![tags 目录体积下降](https://static.031130.xyz/uploads/2025/10/20/007e72e7b476d.webp)\n\n![_payload.json](https://static.031130.xyz/uploads/2025/10/20/17ba3ccbbdf9e.webp)\n\n## 参见\n\n[queryCollection - Nuxt Content](https://content.nuxt.com/docs/utils/query-collection#wherefield-keyof-collection-string-operator-sqloperator-value-unknown)\n\n[How do you query `z.array()` fields (e.g. tags) in the latest nuxt-content module (v3.alpha.8) · nuxt/content · Discussion #2955](https://github.com/nuxt/content/discussions/2955)\n",{"title":5,"description":958},"posts/nuxt-content-v3-z-array-query-challenge",false,[967,968,969],"Nuxt","Nuxt Content","JavaScript","aiq2V6ke3CgUbCWj5NRQp_bdT1HNC2suj3VpmDabeFE",[972,973],null,{"title":974,"path":975,"stem":976,"date":977,"children":-1},"后 OCSP 时代，浏览器如何应对证书吊销新挑战","/2025/10/16/how-s-mozilla-crlite-going-now","posts/how-s-mozilla-crlite-going-now","2025-10-16 15:38:50",20,1761695678989]