[{"data":1,"prerenderedAt":1091},["ShallowReactive",2],{"post-2025-10-20-nuxt-content-v3-z-array-query-challenge":3,"surround-2025-10-20-nuxt-content-v3-z-array-query-challenge":1083,"randomIndex/2025/10/20/nuxt-content-v3-z-array-query-challenge/":1090},{"id":4,"title":5,"body":6,"date":1069,"description":1070,"extension":1071,"meta":1072,"navigation":177,"path":1073,"rawbody":1074,"seo":1075,"stem":1076,"sticky":1077,"tags":1078,"__hash__":1082},"posts/posts/nuxt-content-v3-z-array-query-challenge.md","Nuxt Content v3 中数组字段的筛选困境与性能优化",{"type":7,"value":8,"toc":1063},"minimark",[9,27,30,94,101,106,116,247,262,440,450,460,464,467,750,756,774,781,786,790,803,820,826,840,1010,1013,1023,1029,1035,1040,1043,1050,1059],[10,11,12,13,17,18,21,22,26],"p",{},"Nuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 ",[14,15,16],"strong",{},"Nuxt v4 + Nuxt Content v3"," 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API ",[14,19,20],{},"并未直接提供","对数组字段进行“包含”（",[23,24,25],"code",{},"$contains","）操作的支持。",[10,28,29],{},"例如，这是我的正在写的这篇博客的 Front Matter：",[31,32,37],"pre",{"className":33,"code":34,"language":35,"meta":36,"style":36},"language-markdown shiki shiki-themes one-light one-dark-pro","---\ntitle: Nuxt Content v3 中数组字段的筛选困境\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n","markdown","",[23,38,39,47,53,59,65,71,77,83,89],{"__ignoreMap":36},[40,41,44],"span",{"class":42,"line":43},"line",1,[40,45,46],{},"---\n",[40,48,50],{"class":42,"line":49},2,[40,51,52],{},"title: Nuxt Content v3 中数组字段的筛选困境\n",[40,54,56],{"class":42,"line":55},3,[40,57,58],{},"date: 2025-10-20 21:52:59\n",[40,60,62],{"class":42,"line":61},4,[40,63,64],{},"sticky:\n",[40,66,68],{"class":42,"line":67},5,[40,69,70],{},"tags:\n",[40,72,74],{"class":42,"line":73},6,[40,75,76],{},"- Nuxt\n",[40,78,80],{"class":42,"line":79},7,[40,81,82],{},"- Nuxt Content\n",[40,84,86],{"class":42,"line":85},8,[40,87,88],{},"- JavaScript\n",[40,90,92],{"class":42,"line":91},9,[40,93,46],{},[10,95,96,97,100],{},"我的目标是创建一个 ",[14,98,99],{},"Tag 页面","，列出所有包含特定 Tag（例如 'Nuxt'）的文章。",[102,103,105],"h2",{"id":104},"v2-的便捷与-v3-的限制","v2 的便捷与 v3 的限制",[10,107,108,109,112,113,115],{},"在 Nuxt Content v2 中，数据基于文件系统存储，查询方式是对文件内容的抽象，模拟了类似 ",[14,110,111],{},"MongoDB 的 JSON 文档查询","语法。我们可以轻松地使用 ",[23,114,25],{}," 方法获取所有包含 “Nuxt” 标签的文章：",[31,117,121],{"className":118,"code":119,"language":120,"meta":36,"style":36},"language-typescript shiki shiki-themes one-light one-dark-pro","const tag = decodeURIComponent(route.params.tag as string)\n\nconst articles = await queryContent('posts')\n  .where({ tags: { $contains: tag } })  // ✅ v2 中的 MongoDB Style 查询\n  .find()\n","typescript",[23,122,123,173,179,202,237],{"__ignoreMap":36},[40,124,125,129,133,137,141,145,149,152,156,158,162,166,170],{"class":42,"line":43},[40,126,128],{"class":127},"sLKXg","const",[40,130,132],{"class":131},"sNmU0"," tag",[40,134,136],{"class":135},"s_Sar"," =",[40,138,140],{"class":139},"sAdtL"," decodeURIComponent",[40,142,144],{"class":143},"s5ixo","(",[40,146,148],{"class":147},"s7GmK","route",[40,150,151],{"class":143},".",[40,153,155],{"class":154},"s2QsP","params",[40,157,151],{"class":143},[40,159,161],{"class":160},"sJa8x","tag",[40,163,165],{"class":164},"sblXP"," as",[40,167,169],{"class":168},"sN9Y4"," string",[40,171,172],{"class":143},")\n",[40,174,175],{"class":42,"line":49},[40,176,178],{"emptyLinePlaceholder":177},true,"\n",[40,180,181,183,186,188,191,194,196,200],{"class":42,"line":55},[40,182,128],{"class":127},[40,184,185],{"class":131}," articles",[40,187,136],{"class":135},[40,189,190],{"class":127}," await",[40,192,193],{"class":139}," queryContent",[40,195,144],{"class":143},[40,197,199],{"class":198},"sDhpE","'posts'",[40,201,172],{"class":143},[40,203,204,207,210,213,216,220,223,225,227,230,233],{"class":42,"line":61},[40,205,206],{"class":143},"  .",[40,208,209],{"class":139},"where",[40,211,212],{"class":143},"({ ",[40,214,215],{"class":160},"tags",[40,217,219],{"class":218},"st7oF",":",[40,221,222],{"class":143}," { ",[40,224,25],{"class":160},[40,226,219],{"class":218},[40,228,132],{"class":229},"sz0mV",[40,231,232],{"class":143}," } })  ",[40,234,236],{"class":235},"sW2Sy","// ✅ v2 中的 MongoDB Style 查询\n",[40,238,239,241,244],{"class":42,"line":67},[40,240,206],{"class":143},[40,242,243],{"class":139},"find",[40,245,246],{"class":143},"()\n",[10,248,249,250,257,258,261],{},"但在使用 ",[14,251,252,253,256],{},"Nuxt Content v3 的 ",[23,254,255],{},"queryCollection"," API"," 时，我们很自然地会尝试使用 ",[23,259,260],{},".where()"," 方法进行筛选：",[31,263,265],{"className":118,"code":264,"language":120,"meta":36,"style":36},"const tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${tag}`, () =>\n    queryCollection('posts')\n        .where(tag, 'in', 'tags')  // ❌ 这样会报错，因为第一次参数必须是字段名\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n",[23,266,267,295,299,342,353,381,400,427,436],{"__ignoreMap":36},[40,268,269,271,273,275,277,279,281,283,285,287,289,291,293],{"class":42,"line":43},[40,270,128],{"class":127},[40,272,132],{"class":131},[40,274,136],{"class":135},[40,276,140],{"class":139},[40,278,144],{"class":143},[40,280,148],{"class":147},[40,282,151],{"class":143},[40,284,155],{"class":154},[40,286,151],{"class":143},[40,288,161],{"class":160},[40,290,165],{"class":164},[40,292,169],{"class":168},[40,294,172],{"class":143},[40,296,297],{"class":42,"line":49},[40,298,178],{"emptyLinePlaceholder":177},[40,300,301,303,305,308,311,314,316,319,321,324,328,330,333,336,339],{"class":42,"line":55},[40,302,128],{"class":127},[40,304,222],{"class":143},[40,306,307],{"class":131},"data",[40,309,310],{"class":143}," } ",[40,312,313],{"class":135},"=",[40,315,190],{"class":127},[40,317,318],{"class":139}," useAsyncData",[40,320,144],{"class":143},[40,322,323],{"class":198},"`tag-",[40,325,327],{"class":326},"sAOjX","${",[40,329,161],{"class":229},[40,331,332],{"class":326},"}",[40,334,335],{"class":198},"`",[40,337,338],{"class":143},", () ",[40,340,341],{"class":127},"=>\n",[40,343,344,347,349,351],{"class":42,"line":61},[40,345,346],{"class":139},"    queryCollection",[40,348,144],{"class":143},[40,350,199],{"class":198},[40,352,172],{"class":143},[40,354,355,358,360,362,364,367,370,372,375,378],{"class":42,"line":67},[40,356,357],{"class":143},"        .",[40,359,209],{"class":139},[40,361,144],{"class":143},[40,363,161],{"class":229},[40,365,366],{"class":143},", ",[40,368,369],{"class":198},"'in'",[40,371,366],{"class":143},[40,373,374],{"class":198},"'tags'",[40,376,377],{"class":143},")  ",[40,379,380],{"class":235},"// ❌ 这样会报错，因为第一次参数必须是字段名\n",[40,382,383,385,388,390,393,395,398],{"class":42,"line":73},[40,384,357],{"class":143},[40,386,387],{"class":139},"order",[40,389,144],{"class":143},[40,391,392],{"class":198},"'date'",[40,394,366],{"class":143},[40,396,397],{"class":198},"'DESC'",[40,399,172],{"class":143},[40,401,402,404,407,409,412,414,416,418,421,423,425],{"class":42,"line":79},[40,403,357],{"class":143},[40,405,406],{"class":139},"select",[40,408,144],{"class":143},[40,410,411],{"class":198},"'title'",[40,413,366],{"class":143},[40,415,392],{"class":198},[40,417,366],{"class":143},[40,419,420],{"class":198},"'path'",[40,422,366],{"class":143},[40,424,374],{"class":198},[40,426,172],{"class":143},[40,428,429,431,434],{"class":42,"line":85},[40,430,357],{"class":143},[40,432,433],{"class":139},"all",[40,435,246],{"class":143},[40,437,438],{"class":42,"line":91},[40,439,172],{"class":143},[10,441,442,443,445,446,449],{},"遗憾的是，这样是行不通的。",[23,444,260],{}," 的方法签名要求字段名必须作为首个参数传入：",[23,447,448],{},"where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)","。",[10,451,452,453,456,457,459],{},"由于 Nuxt Content v3 ",[14,454,455],{},"底层采用 SQLite 作为本地数据库","，所有查询都必须遵循类 SQL 语法。如果设计时未提供针对数组字段的内置操作符（例如 ",[23,458,25],{}," 的 SQL 等价形式），最终的解决方案往往会显得比较“别扭”。",[102,461,463],{"id":462},"初版实现牺牲性能的全量拉取","初版实现：牺牲性能的“全量拉取”",[10,465,466],{},"本着“尽快重构，后续优化”的思路，我写出了以下代码：",[31,468,470],{"className":118,"code":469,"language":120,"meta":36,"style":36},"// 初版实现：全量拉取后使用 JS 筛选\nconst allPosts = (\n    await useAsyncData(`tag-${route.params.tag}`, () =>\n        queryCollection('posts')\n            .order('date', 'DESC')\n            .select('title', 'date', 'path', 'tags')\n            .all()\n    )\n).data as Ref\u003CPost[]>\n\nconst Posts = computed(() => {\n    return allPosts.value.filter(post =>\n        typeof post.tags?.map === 'function'\n            ? post.tags?.includes(decodeURIComponent(route.params.tag as string))\n            : false\n    )\n})\n",[23,471,472,477,489,521,532,549,573,581,586,608,613,635,662,688,729,739,744],{"__ignoreMap":36},[40,473,474],{"class":42,"line":43},[40,475,476],{"class":235},"// 初版实现：全量拉取后使用 JS 筛选\n",[40,478,479,481,484,486],{"class":42,"line":49},[40,480,128],{"class":127},[40,482,483],{"class":139}," allPosts",[40,485,136],{"class":135},[40,487,488],{"class":143}," (\n",[40,490,491,494,496,498,500,502,504,507,509,511,513,515,517,519],{"class":42,"line":55},[40,492,493],{"class":127},"    await",[40,495,318],{"class":139},[40,497,144],{"class":143},[40,499,323],{"class":198},[40,501,327],{"class":326},[40,503,148],{"class":147},[40,505,151],{"class":506},"sMj0N",[40,508,155],{"class":154},[40,510,151],{"class":506},[40,512,161],{"class":160},[40,514,332],{"class":326},[40,516,335],{"class":198},[40,518,338],{"class":143},[40,520,341],{"class":127},[40,522,523,526,528,530],{"class":42,"line":61},[40,524,525],{"class":139},"        queryCollection",[40,527,144],{"class":143},[40,529,199],{"class":198},[40,531,172],{"class":143},[40,533,534,537,539,541,543,545,547],{"class":42,"line":67},[40,535,536],{"class":143},"            .",[40,538,387],{"class":139},[40,540,144],{"class":143},[40,542,392],{"class":198},[40,544,366],{"class":143},[40,546,397],{"class":198},[40,548,172],{"class":143},[40,550,551,553,555,557,559,561,563,565,567,569,571],{"class":42,"line":73},[40,552,536],{"class":143},[40,554,406],{"class":139},[40,556,144],{"class":143},[40,558,411],{"class":198},[40,560,366],{"class":143},[40,562,392],{"class":198},[40,564,366],{"class":143},[40,566,420],{"class":198},[40,568,366],{"class":143},[40,570,374],{"class":198},[40,572,172],{"class":143},[40,574,575,577,579],{"class":42,"line":79},[40,576,536],{"class":143},[40,578,433],{"class":139},[40,580,246],{"class":143},[40,582,583],{"class":42,"line":85},[40,584,585],{"class":143},"    )\n",[40,587,588,591,593,595,599,602,605],{"class":42,"line":91},[40,589,590],{"class":143},").",[40,592,307],{"class":160},[40,594,165],{"class":164},[40,596,598],{"class":597},"sC09Y"," Ref",[40,600,601],{"class":143},"\u003C",[40,603,604],{"class":597},"Post",[40,606,607],{"class":143},"[]>\n",[40,609,611],{"class":42,"line":610},10,[40,612,178],{"emptyLinePlaceholder":177},[40,614,616,618,621,623,626,629,632],{"class":42,"line":615},11,[40,617,128],{"class":127},[40,619,620],{"class":131}," Posts",[40,622,136],{"class":135},[40,624,625],{"class":139}," computed",[40,627,628],{"class":143},"(() ",[40,630,631],{"class":127},"=>",[40,633,634],{"class":143}," {\n",[40,636,638,641,643,645,648,650,653,655,659],{"class":42,"line":637},12,[40,639,640],{"class":127},"    return",[40,642,483],{"class":147},[40,644,151],{"class":143},[40,646,647],{"class":154},"value",[40,649,151],{"class":143},[40,651,652],{"class":139},"filter",[40,654,144],{"class":143},[40,656,658],{"class":657},"s8iYz","post",[40,660,661],{"class":127}," =>\n",[40,663,665,669,672,674,676,679,682,685],{"class":42,"line":664},13,[40,666,668],{"class":667},"s7DPa","        typeof",[40,670,671],{"class":147}," post",[40,673,151],{"class":143},[40,675,215],{"class":154},[40,677,678],{"class":143},"?.",[40,680,681],{"class":160},"map",[40,683,684],{"class":135}," ===",[40,686,687],{"class":198}," 'function'\n",[40,689,691,694,696,698,700,702,705,707,710,712,714,716,718,720,722,724,726],{"class":42,"line":690},14,[40,692,693],{"class":667},"            ?",[40,695,671],{"class":147},[40,697,151],{"class":143},[40,699,215],{"class":154},[40,701,678],{"class":143},[40,703,704],{"class":139},"includes",[40,706,144],{"class":143},[40,708,709],{"class":139},"decodeURIComponent",[40,711,144],{"class":143},[40,713,148],{"class":147},[40,715,151],{"class":143},[40,717,155],{"class":154},[40,719,151],{"class":143},[40,721,161],{"class":160},[40,723,165],{"class":164},[40,725,169],{"class":168},[40,727,728],{"class":143},"))\n",[40,730,732,735],{"class":42,"line":731},15,[40,733,734],{"class":667},"            :",[40,736,738],{"class":737},"sAGMh"," false\n",[40,740,742],{"class":42,"line":741},16,[40,743,585],{"class":143},[40,745,747],{"class":42,"line":746},17,[40,748,749],{"class":143},"})\n",[10,751,752,753],{},"这种方法虽然满足了需求，但也带来了明显的性能代价：",[14,754,755],{},"_payload.json 文件体积的膨胀。",[10,757,758,759,762,763,766,767,770,771,773],{},"在 Nuxt 项目中，",[23,760,761],{},"_payload.json"," 用于存储 ",[23,764,765],{},"useAsyncData"," 的结果等动态数据。在全量拉取的方案下，",[14,768,769],{},"每一个 Tag 页面"," 都会加载包含所有文章信息的 ",[23,772,761],{},"，造成数据冗余。很多 Tag 页面仅需一两篇文章的数据，却被迫加载了全部文章信息，严重影响了性能。",[10,775,776],{},[777,778],"img",{"alt":779,"src":780},"tags 目录占据了 2.9MiB，是所有目录中最大的","https://static.031130.xyz/uploads/2025/10/20/a748878c03c64.webp",[10,782,783],{},[777,784],{"alt":761,"src":785},"https://static.031130.xyz/uploads/2025/10/20/8ef786d873da1.webp",[102,787,789],{"id":788},"讨巧方案利用-sqlite-的存储特性进行优化","讨巧方案：利用 SQLite 的存储特性进行优化",[10,791,792,793,795,796,449],{},"为了减少 ",[23,794,765],{}," 返回的查询结果，我查阅了 Nuxt Content 的 GitHub Discussions，发现",[797,798,802],"a",{"href":799,"rel":800},"https://github.com/nuxt/content/discussions/2955",[801],"nofollow","在 v3.alpha.8 版本时就有人提出了一种“巧妙”的解决方案",[10,804,805,806,815,816,819],{},"由于 Nuxt Content v3 使用 SQLite 数据库，原本在 Front Matter 中定义的 ",[14,807,808,810,811,814],{},[23,809,215],{}," 数组（通过 ",[23,812,813],{},"z.array()"," 定义）最终会以 JSON 字符串的形式存储","在数据库中（具体格式可在 ",[23,817,818],{},".nuxt/content/sql_dump.txt"," 文件中查看）。",[10,821,822],{},[777,823],{"alt":824,"src":825},"sql_dump.txt","https://static.031130.xyz/uploads/2025/10/20/b70036c55bb29.webp",[10,827,828,829,832,833,839],{},"这意味着我们可以利用 SQLite 的",[14,830,831],{},"字符串操作","特性，通过 ",[14,834,835,838],{},[23,836,837],{},"LIKE"," 动词配合通配符","来完成数组包含的筛选，本质上是查询 JSON 字符串是否包含特定子串：",[31,841,843],{"className":118,"code":842,"language":120,"meta":36,"style":36},"const tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${route.params.tag}`, () =>\n    queryCollection('posts')\n        .where('tags', 'LIKE', `%\"${tag}\"%`)\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n",[23,844,845,873,877,917,927,958,974,998,1006],{"__ignoreMap":36},[40,846,847,849,851,853,855,857,859,861,863,865,867,869,871],{"class":42,"line":43},[40,848,128],{"class":127},[40,850,132],{"class":131},[40,852,136],{"class":135},[40,854,140],{"class":139},[40,856,144],{"class":143},[40,858,148],{"class":147},[40,860,151],{"class":143},[40,862,155],{"class":154},[40,864,151],{"class":143},[40,866,161],{"class":160},[40,868,165],{"class":164},[40,870,169],{"class":168},[40,872,172],{"class":143},[40,874,875],{"class":42,"line":49},[40,876,178],{"emptyLinePlaceholder":177},[40,878,879,881,883,885,887,889,891,893,895,897,899,901,903,905,907,909,911,913,915],{"class":42,"line":55},[40,880,128],{"class":127},[40,882,222],{"class":143},[40,884,307],{"class":131},[40,886,310],{"class":143},[40,888,313],{"class":135},[40,890,190],{"class":127},[40,892,318],{"class":139},[40,894,144],{"class":143},[40,896,323],{"class":198},[40,898,327],{"class":326},[40,900,148],{"class":147},[40,902,151],{"class":506},[40,904,155],{"class":154},[40,906,151],{"class":506},[40,908,161],{"class":160},[40,910,332],{"class":326},[40,912,335],{"class":198},[40,914,338],{"class":143},[40,916,341],{"class":127},[40,918,919,921,923,925],{"class":42,"line":61},[40,920,346],{"class":139},[40,922,144],{"class":143},[40,924,199],{"class":198},[40,926,172],{"class":143},[40,928,929,931,933,935,937,939,942,944,947,949,951,953,956],{"class":42,"line":67},[40,930,357],{"class":143},[40,932,209],{"class":139},[40,934,144],{"class":143},[40,936,374],{"class":198},[40,938,366],{"class":143},[40,940,941],{"class":198},"'LIKE'",[40,943,366],{"class":143},[40,945,946],{"class":198},"`%\"",[40,948,327],{"class":326},[40,950,161],{"class":229},[40,952,332],{"class":326},[40,954,955],{"class":198},"\"%`",[40,957,172],{"class":143},[40,959,960,962,964,966,968,970,972],{"class":42,"line":73},[40,961,357],{"class":143},[40,963,387],{"class":139},[40,965,144],{"class":143},[40,967,392],{"class":198},[40,969,366],{"class":143},[40,971,397],{"class":198},[40,973,172],{"class":143},[40,975,976,978,980,982,984,986,988,990,992,994,996],{"class":42,"line":79},[40,977,357],{"class":143},[40,979,406],{"class":139},[40,981,144],{"class":143},[40,983,411],{"class":198},[40,985,366],{"class":143},[40,987,392],{"class":198},[40,989,366],{"class":143},[40,991,420],{"class":198},[40,993,366],{"class":143},[40,995,374],{"class":198},[40,997,172],{"class":143},[40,999,1000,1002,1004],{"class":42,"line":85},[40,1001,357],{"class":143},[40,1003,433],{"class":139},[40,1005,246],{"class":143},[40,1007,1008],{"class":42,"line":91},[40,1009,172],{"class":143},[10,1011,1012],{},"下面是优化后重新生成的文件占用，体积减小还是非常显著的",[1014,1015,1016,1020],"ul",{},[1017,1018,1019],"li",{},"tags 目录体积: 2.9MiB -> 1.4MiB",[1017,1021,1022],{},"单个 _payload.json 的体积: 23.1KiB -> 1.01 KiB",[10,1024,1025,1026,1028],{},"通过这种方法，我们成功将查询逻辑下推到了数据库层，避免了不必要的全量数据传输，显著降低了单个目录中 ",[23,1027,761],{}," 的体积，实现了性能优化。",[10,1030,1031],{},[777,1032],{"alt":1033,"src":1034},"tags 目录体积下降","https://static.031130.xyz/uploads/2025/10/20/007e72e7b476d.webp",[10,1036,1037],{},[777,1038],{"alt":761,"src":1039},"https://static.031130.xyz/uploads/2025/10/20/17ba3ccbbdf9e.webp",[102,1041,1042],{"id":1042},"参见",[10,1044,1045],{},[797,1046,1049],{"href":1047,"rel":1048},"https://content.nuxt.com/docs/utils/query-collection#wherefield-keyof-collection-string-operator-sqloperator-value-unknown",[801],"queryCollection - Nuxt Content",[10,1051,1052],{},[797,1053,1055,1056,1058],{"href":799,"rel":1054},[801],"How do you query ",[23,1057,813],{}," fields (e.g. tags) in the latest nuxt-content module (v3.alpha.8) · nuxt/content · Discussion #2955",[1060,1061,1062],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .sLKXg, html code.shiki .sLKXg{--shiki-default:#A626A4;--shiki-dark:#C678DD}html pre.shiki code .sNmU0, html code.shiki .sNmU0{--shiki-default:#986801;--shiki-dark:#E5C07B}html pre.shiki code .s_Sar, html code.shiki .s_Sar{--shiki-default:#0184BC;--shiki-dark:#56B6C2}html pre.shiki code .sAdtL, html code.shiki .sAdtL{--shiki-default:#4078F2;--shiki-dark:#61AFEF}html pre.shiki code .s5ixo, html code.shiki .s5ixo{--shiki-default:#383A42;--shiki-dark:#ABB2BF}html pre.shiki code .s7GmK, html code.shiki .s7GmK{--shiki-default:#383A42;--shiki-dark:#E5C07B}html pre.shiki code .s2QsP, html code.shiki .s2QsP{--shiki-default:#E45649;--shiki-dark:#E5C07B}html pre.shiki code .sJa8x, html code.shiki .sJa8x{--shiki-default:#E45649;--shiki-dark:#E06C75}html pre.shiki code .sblXP, html code.shiki .sblXP{--shiki-default:#383A42;--shiki-dark:#C678DD}html pre.shiki code .sN9Y4, html code.shiki .sN9Y4{--shiki-default:#0184BC;--shiki-dark:#E5C07B}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html pre.shiki code .st7oF, html code.shiki .st7oF{--shiki-default:#0184BC;--shiki-dark:#ABB2BF}html pre.shiki code .sz0mV, html code.shiki .sz0mV{--shiki-default:#383A42;--shiki-dark:#E06C75}html pre.shiki code .sW2Sy, html code.shiki .sW2Sy{--shiki-default:#A0A1A7;--shiki-default-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic}html pre.shiki code .sAOjX, html code.shiki .sAOjX{--shiki-default:#CA1243;--shiki-dark:#C678DD}html pre.shiki code .sMj0N, html code.shiki .sMj0N{--shiki-default:#50A14F;--shiki-dark:#ABB2BF}html pre.shiki code .sC09Y, html code.shiki .sC09Y{--shiki-default:#C18401;--shiki-dark:#E5C07B}html pre.shiki code .s8iYz, html code.shiki .s8iYz{--shiki-default:#383A42;--shiki-default-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic}html pre.shiki code .s7DPa, html code.shiki .s7DPa{--shiki-default:#0184BC;--shiki-dark:#C678DD}html pre.shiki code .sAGMh, html code.shiki .sAGMh{--shiki-default:#986801;--shiki-dark:#D19A66}",{"title":36,"searchDepth":49,"depth":49,"links":1064},[1065,1066,1067,1068],{"id":104,"depth":49,"text":105},{"id":462,"depth":49,"text":463},{"id":788,"depth":49,"text":789},{"id":1042,"depth":49,"text":1042},"2025-10-20 21:52:59","Nuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 Nuxt v4 + Nuxt Content v3 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API 并未直接提供对数组字段进行“包含”（$contains）操作的支持。","md",{},"/2025/10/20/nuxt-content-v3-z-array-query-challenge","---\ntitle: Nuxt Content v3 中数组字段的筛选困境与性能优化\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n\nNuxt Content 是 Nuxt 生态中用于处理 Markdown、YAML 等内容的强大模块。最近，我在使用 **Nuxt v4 + Nuxt Content v3** 重构博客（原为 Hexo）时，遇到了一个棘手的问题：v3 版本的默认查询 API **并未直接提供**对数组字段进行“包含”（`$contains`）操作的支持。\n\n例如，这是我的正在写的这篇博客的 Front Matter：\n\n```markdown\n---\ntitle: Nuxt Content v3 中数组字段的筛选困境\ndate: 2025-10-20 21:52:59\nsticky:\ntags:\n- Nuxt\n- Nuxt Content\n- JavaScript\n---\n```\n\n我的目标是创建一个 **Tag 页面**，列出所有包含特定 Tag（例如 'Nuxt'）的文章。\n\n## v2 的便捷与 v3 的限制\n\n在 Nuxt Content v2 中，数据基于文件系统存储，查询方式是对文件内容的抽象，模拟了类似 **MongoDB 的 JSON 文档查询**语法。我们可以轻松地使用 `$contains` 方法获取所有包含 “Nuxt” 标签的文章：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst articles = await queryContent('posts')\n  .where({ tags: { $contains: tag } })  // ✅ v2 中的 MongoDB Style 查询\n  .find()\n```\n\n但在使用 **Nuxt Content v3 的 `queryCollection` API** 时，我们很自然地会尝试使用 `.where()` 方法进行筛选：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${tag}`, () =>\n    queryCollection('posts')\n        .where(tag, 'in', 'tags')  // ❌ 这样会报错，因为第一次参数必须是字段名\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n```\n\n遗憾的是，这样是行不通的。`.where()` 的方法签名要求字段名必须作为首个参数传入：`where(field: keyof Collection | string, operator: SqlOperator, value?: unknown)`。\n\n由于 Nuxt Content v3 **底层采用 SQLite 作为本地数据库**，所有查询都必须遵循类 SQL 语法。如果设计时未提供针对数组字段的内置操作符（例如 `$contains` 的 SQL 等价形式），最终的解决方案往往会显得比较“别扭”。\n\n## 初版实现：牺牲性能的“全量拉取”\n\n本着“尽快重构，后续优化”的思路，我写出了以下代码：\n\n```typescript\n// 初版实现：全量拉取后使用 JS 筛选\nconst allPosts = (\n    await useAsyncData(`tag-${route.params.tag}`, () =>\n        queryCollection('posts')\n            .order('date', 'DESC')\n            .select('title', 'date', 'path', 'tags')\n            .all()\n    )\n).data as Ref\u003CPost[]>\n\nconst Posts = computed(() => {\n    return allPosts.value.filter(post =>\n        typeof post.tags?.map === 'function'\n            ? post.tags?.includes(decodeURIComponent(route.params.tag as string))\n            : false\n    )\n})\n```\n\n这种方法虽然满足了需求，但也带来了明显的性能代价：**\\_payload.json 文件体积的膨胀。**\n\n在 Nuxt 项目中，`_payload.json` 用于存储 `useAsyncData` 的结果等动态数据。在全量拉取的方案下，**每一个 Tag 页面** 都会加载包含所有文章信息的 `_payload.json`，造成数据冗余。很多 Tag 页面仅需一两篇文章的数据，却被迫加载了全部文章信息，严重影响了性能。\n\n![tags 目录占据了 2.9MiB，是所有目录中最大的](https://static.031130.xyz/uploads/2025/10/20/a748878c03c64.webp)\n\n![_payload.json](https://static.031130.xyz/uploads/2025/10/20/8ef786d873da1.webp)\n\n## 讨巧方案：利用 SQLite 的存储特性进行优化\n\n为了减少 `useAsyncData` 返回的查询结果，我查阅了 Nuxt Content 的 GitHub Discussions，发现[在 v3.alpha.8 版本时就有人提出了一种“巧妙”的解决方案](https://github.com/nuxt/content/discussions/2955)。\n\n由于 Nuxt Content v3 使用 SQLite 数据库，原本在 Front Matter 中定义的 **`tags` 数组（通过 `z.array()` 定义）最终会以 JSON 字符串的形式存储**在数据库中（具体格式可在 `.nuxt/content/sql_dump.txt` 文件中查看）。\n\n![sql_dump.txt](https://static.031130.xyz/uploads/2025/10/20/b70036c55bb29.webp)\n\n这意味着我们可以利用 SQLite 的**字符串操作**特性，通过 **`LIKE` 动词配合通配符**来完成数组包含的筛选，本质上是查询 JSON 字符串是否包含特定子串：\n\n```typescript\nconst tag = decodeURIComponent(route.params.tag as string)\n\nconst { data } = await useAsyncData(`tag-${route.params.tag}`, () =>\n    queryCollection('posts')\n        .where('tags', 'LIKE', `%\"${tag}\"%`)\n        .order('date', 'DESC')\n        .select('title', 'date', 'path', 'tags')\n        .all()\n)\n```\n\n下面是优化后重新生成的文件占用，体积减小还是非常显著的\n\n- tags 目录体积: 2.9MiB -> 1.4MiB\n- 单个 _payload.json 的体积: 23.1KiB -> 1.01 KiB\n\n通过这种方法，我们成功将查询逻辑下推到了数据库层，避免了不必要的全量数据传输，显著降低了单个目录中 `_payload.json` 的体积，实现了性能优化。\n\n![tags 目录体积下降](https://static.031130.xyz/uploads/2025/10/20/007e72e7b476d.webp)\n\n![_payload.json](https://static.031130.xyz/uploads/2025/10/20/17ba3ccbbdf9e.webp)\n\n## 参见\n\n[queryCollection - Nuxt Content](https://content.nuxt.com/docs/utils/query-collection#wherefield-keyof-collection-string-operator-sqloperator-value-unknown)\n\n[How do you query `z.array()` fields (e.g. tags) in the latest nuxt-content module (v3.alpha.8) · nuxt/content · Discussion #2955](https://github.com/nuxt/content/discussions/2955)\n",{"title":5,"description":1070},"posts/nuxt-content-v3-z-array-query-challenge",false,[1079,1080,1081],"Nuxt","Nuxt Content","JavaScript","54oaHlu7T3A_B2Xb6BHS2W6svTO3uAO6jShFSLqFFtQ",[1084,1085],null,{"title":1086,"path":1087,"stem":1088,"date":1089,"children":-1},"后 OCSP 时代，浏览器如何应对证书吊销新挑战","/2025/10/16/how-s-mozilla-crlite-going-now","posts/how-s-mozilla-crlite-going-now","2025-10-16 15:38:50",24,1761738773648]