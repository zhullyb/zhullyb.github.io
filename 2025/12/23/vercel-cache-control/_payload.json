[{"data":1,"prerenderedAt":543},["ShallowReactive",2],{"post-2025-12-23-vercel-cache-control-zh":3,"surround-2025-12-23-vercel-cache-control-zh":534,"randomIndex/2025/12/23/vercel-cache-control/":210,"language-switch-/2025/12/23/vercel-cache-control/-en":542},{"title":4,"date":5,"path":6,"tags":7,"body":11,"description":17},"Vercel 的缓存控制，你注意过吗？","2025-12-23","/2025/12/23/vercel-cache-control",[8,9,10],"Vercel","Network","HTTP",{"type":12,"value":13,"toc":523},"minimark",[14,18,22,29,35,38,42,53,69,80,86,89,93,102,105,111,116,119,122,126,129,140,143,163,169,172,175,232,235,238,245,248,256,262,441,452,455,481,484,487,493,496,519],[15,16,17],"p",{},"Vercel 默认的缓存配置其实并不合理，但鲜有人注意。",[19,20,21],"h2",{"id":21},"先看效果",[15,23,24],{},[25,26],"img",{"alt":27,"src":28},"图一","https://static.031130.xyz/uploads/2025/12/23/577e579eceb96.webp",[15,30,31],{},[25,32],{"alt":33,"src":34},"图二","https://static.031130.xyz/uploads/2025/12/23/0cfc9543c857a.webp",[19,36,37],{"id":37},"分析",[39,40,41],"h3",{"id":41},"测试方案",[15,43,44,45,52],{},"这两张图都是我博客在 ",[46,47,51],"a",{"href":48,"rel":49},"https://pagespeed.web.dev/",[50],"nofollow","PageSpeed Insights"," 上测得的，测试步骤如下：",[54,55,56,60,63,66],"ol",{},[57,58,59],"li",{},"部署",[57,61,62],{},"在 PageSpeed Insights 进行第一次测试",[57,64,65],{},"等待 120s，防止 PageSpeed Insights 拿之前的结果糊弄你",[57,67,68],{},"进行第二次测试，取第二次测试的结果",[15,70,71,75,76,79],{},[72,73,74],"strong",{},"取第二次结果的目的是为了","让 PageSpeed Insights 所命中的 Vercel CDN 节点完成回源，并",[72,77,78],{},"将内容缓存在 CDN 节点上","，这样第二次访问的时候就会直接从 CDN 的缓存中得到结果，不需要回源。",[15,81,82,83],{},"那我们看图一的测试结果，正常吗？针对首页的单个 html 加载时长达到了 ",[72,84,85],{},"450ms，看着不算慢，但其实细究下来是有问题的。",[15,87,88],{},"Vercel 采用的是 Amazon 提供的全球 CDN 网络，在我们的首次访问之后，CDN 节点应当该已经缓存了首页的内容，第二次访问的时候应该是直接从 CDN 节点的缓存中获取内容。",[39,90,92],{"id":91},"合理的时长是多久呢","合理的时长是多久呢？",[94,95,96,99],"ul",{},[57,97,98],{},"TCP 建立连接的三次握手，需要 1.5 个往返时延（RTT），再加上 TLS 1.3 握手的 1 个 RTT，共计 2.5 个 RTT。",[57,100,101],{},"HTML 文件大小 18KB，初始拥塞窗口（IW）10 MSS ≈ 1460 字节 ≈ 14.6KB，理论上应该可以在两个 RTT 内传输完毕。",[15,103,104],{},"共计 4.5 个 RTT。",[15,106,107,108],{},"PageSpeed Insights 测试时使用的节点大概率是在美国，Amazon CDN 在美国的节点覆盖非常广泛，单个 RTT 时长控制在 5ms 以内绰绰有余，所以理论加载时长应该在 22.5ms 左右。加上 DNS 解析时长（这个也不多，因为两分钟前有过一次访问，这次不是冷启动）和一些不可控的网络抖动，",[72,109,110],{},"50ms 以内应该是完全没有问题的。",[15,112,113],{},[72,114,115],{},"但实际测得的时长却高达 450ms，差了近 9 倍，这就很不合理了。",[15,117,118],{},"我们再来看图二的结果，单个 HTML 加载时长降到了 41ms，完全符合预期。",[15,120,121],{},"为什么会有这么大的差异呢？原因就在于 Vercel 对缓存控制的设置上。",[19,123,125],{"id":124},"vercel-的缓存控制","Vercel 的缓存控制",[15,127,128],{},"在 Vercel 上部署的网站，默认情况下，Vercel 会对 HTML 文件设置如下的缓存控制头：",[130,131,136],"pre",{"className":132,"code":134,"language":135},[133],"language-text","cache-control: public, max-age=0, must-revalidate\n","text",[137,138,134],"code",{"__ignoreMap":139},"",[15,141,142],{},"这个设置的含义是：",[94,144,145,151,157],{},[57,146,147,150],{},[137,148,149],{},"public","：响应可以被任何缓存区缓存，包括浏览器和 CDN。",[57,152,153,156],{},[137,154,155],{},"max-age=0","： 响应的最大缓存时间为 0 秒，意味着响应一旦被缓存后立即过期。",[57,158,159,162],{},[137,160,161],{},"must-revalidate","：一旦响应过期，缓存必须向源服务器验证其有效性。",[15,164,165,166,168],{},"结合这三个指令，Vercel 实际上是告诉 CDN 节点：你可以缓存这个 HTML 文件，但每次在使用缓存之前都必须回源验证其有效性。由于 ",[137,167,155],{},"，缓存一旦存储就立即过期，因此每次请求都会触发回源验证。",[15,170,171],{},"尽管 HTTP/1.1 和 HTTP/2 中的缓存验证通常使用条件请求（如文件的 ETag 或 Last-Modified 头）来节省传输流量，但这仍然需要与源服务器进行往返通信，从而增加了额外的延迟开销。",[15,173,174],{},"所以，在 Vercel 默认配置下，任何请求的响应都不会被 CDN 节点直接缓存，大致的流程如下：",[130,176,180],{"className":177,"code":178,"language":179,"meta":139,"style":139},"language-mermaid shiki shiki-themes one-light one-dark-pro","sequenceDiagram\n    participant Client\n    participant CDN\n    participant Vercel\n    Client->>CDN: 请求 HTML 文件\n    CDN->>Vercel: 条件请求验证缓存\n    Vercel->>CDN: 返回最新的 HTML 文件或 304 Not Modified\n    CDN->>Client: 返回 HTML 文件\n","mermaid",[137,181,182,190,196,202,208,214,220,226],{"__ignoreMap":139},[183,184,187],"span",{"class":185,"line":186},"line",1,[183,188,189],{},"sequenceDiagram\n",[183,191,193],{"class":185,"line":192},2,[183,194,195],{},"    participant Client\n",[183,197,199],{"class":185,"line":198},3,[183,200,201],{},"    participant CDN\n",[183,203,205],{"class":185,"line":204},4,[183,206,207],{},"    participant Vercel\n",[183,209,211],{"class":185,"line":210},5,[183,212,213],{},"    Client->>CDN: 请求 HTML 文件\n",[183,215,217],{"class":185,"line":216},6,[183,218,219],{},"    CDN->>Vercel: 条件请求验证缓存\n",[183,221,223],{"class":185,"line":222},7,[183,224,225],{},"    Vercel->>CDN: 返回最新的 HTML 文件或 304 Not Modified\n",[183,227,229],{"class":185,"line":228},8,[183,230,231],{},"    CDN->>Client: 返回 HTML 文件\n",[19,233,234],{"id":234},"解决方案",[15,236,237],{},"要解决这个问题，我们需要调整 Vercel 上的缓存控制设置，使得 HTML 文件能够被 CDN 节点缓存一段时间，而不需要每次都回源验证。",[15,239,240,241,244],{},"Vercel 允许我们在项目的根目录下创建一个 ",[137,242,243],{},"vercel.json"," 文件以对 Vercel 的部署行为进行一系列的配置，其中就包括 HTTP 的响应头的配置。",[15,246,247],{},"我的博客采用 Nuxt.js 框架构建，生成的构建产物大概分为两类：",[54,249,250,253],{},[57,251,252],{},"HTML 文件：这些文件的内容可能会频繁变化，不能设置过长的缓存时间；",[57,254,255],{},"静态资源文件：包括 JavaScript、CSS 等，这些文件的文件名通常带有 hash 值，可以设置较长的缓存时间甚至被标记为不可变（immutable）。",[15,257,258,259,261],{},"在部署流程上，我的博客在每次推送后会先 Github Actions 中构建成静态页面，再部署到 Vercel 上，所以我在我项目的 public 目录下创建了 ",[137,260,243],{}," 文件（这样 vercel.json 文件就会在构建产物的根目录），内容如下：",[130,263,267],{"className":264,"code":265,"language":266,"meta":139,"style":139},"language-json shiki shiki-themes one-light one-dark-pro","{\n  \"headers\": [\n    {\n      \"source\": \"/(.*)\",\n      \"headers\": [\n        {\n          \"key\": \"Cache-Control\",\n          \"value\": \"public, max-age=0, s-maxage=600, must-revalidate\"\n        }\n      ]\n    },\n    {\n      \"source\": \"/(.*)\\\\.(css|js)\",\n      \"headers\": [\n        {\n          \"key\": \"Cache-Control\",\n          \"value\": \"public, max-age=31536000, immutable\"\n        }\n      ]\n    }\n  ]\n}\n\n","json",[137,268,269,275,284,289,304,311,316,328,338,344,350,356,361,380,387,392,403,413,418,423,429,435],{"__ignoreMap":139},[183,270,271],{"class":185,"line":186},[183,272,274],{"class":273},"s5ixo","{\n",[183,276,277,281],{"class":185,"line":192},[183,278,280],{"class":279},"sJa8x","  \"headers\"",[183,282,283],{"class":273},": [\n",[183,285,286],{"class":185,"line":198},[183,287,288],{"class":273},"    {\n",[183,290,291,294,297,301],{"class":185,"line":204},[183,292,293],{"class":279},"      \"source\"",[183,295,296],{"class":273},": ",[183,298,300],{"class":299},"sDhpE","\"/(.*)\"",[183,302,303],{"class":273},",\n",[183,305,306,309],{"class":185,"line":210},[183,307,308],{"class":279},"      \"headers\"",[183,310,283],{"class":273},[183,312,313],{"class":185,"line":216},[183,314,315],{"class":273},"        {\n",[183,317,318,321,323,326],{"class":185,"line":222},[183,319,320],{"class":279},"          \"key\"",[183,322,296],{"class":273},[183,324,325],{"class":299},"\"Cache-Control\"",[183,327,303],{"class":273},[183,329,330,333,335],{"class":185,"line":228},[183,331,332],{"class":279},"          \"value\"",[183,334,296],{"class":273},[183,336,337],{"class":299},"\"public, max-age=0, s-maxage=600, must-revalidate\"\n",[183,339,341],{"class":185,"line":340},9,[183,342,343],{"class":273},"        }\n",[183,345,347],{"class":185,"line":346},10,[183,348,349],{"class":273},"      ]\n",[183,351,353],{"class":185,"line":352},11,[183,354,355],{"class":273},"    },\n",[183,357,359],{"class":185,"line":358},12,[183,360,288],{"class":273},[183,362,364,366,368,371,375,378],{"class":185,"line":363},13,[183,365,293],{"class":279},[183,367,296],{"class":273},[183,369,370],{"class":299},"\"/(.*)",[183,372,374],{"class":373},"s_Sar","\\\\",[183,376,377],{"class":299},".(css|js)\"",[183,379,303],{"class":273},[183,381,383,385],{"class":185,"line":382},14,[183,384,308],{"class":279},[183,386,283],{"class":273},[183,388,390],{"class":185,"line":389},15,[183,391,315],{"class":273},[183,393,395,397,399,401],{"class":185,"line":394},16,[183,396,320],{"class":279},[183,398,296],{"class":273},[183,400,325],{"class":299},[183,402,303],{"class":273},[183,404,406,408,410],{"class":185,"line":405},17,[183,407,332],{"class":279},[183,409,296],{"class":273},[183,411,412],{"class":299},"\"public, max-age=31536000, immutable\"\n",[183,414,416],{"class":185,"line":415},18,[183,417,343],{"class":273},[183,419,421],{"class":185,"line":420},19,[183,422,349],{"class":273},[183,424,426],{"class":185,"line":425},20,[183,427,428],{"class":273},"    }\n",[183,430,432],{"class":185,"line":431},21,[183,433,434],{"class":273},"  ]\n",[183,436,438],{"class":185,"line":437},22,[183,439,440],{"class":273},"}\n",[15,442,443,444,447,448,451],{},"这里我对所有的 CSS 和 JS 文件设置了 ",[137,445,446],{},"max-age=31536000, immutable","，这样这些静态资源文件就可以被浏览器和 CDN 长时间缓存。而对于所有其他文件（主要是 HTML 文件），我设置了 ",[137,449,450],{},"max-age=0, s-maxage=600, must-revalidate","，这样 HTML 文件就可以被 CDN 缓存 10 分钟，在这 10 分钟内的请求都可以直接从 CDN 节点的缓存中获取内容，而不需要回源验证。",[15,453,454],{},"这样一来，经过修改后的缓存控制设置，HTML 文件的请求流程变成了：",[130,456,458],{"className":177,"code":457,"language":179,"meta":139,"style":139},"sequenceDiagram\n    participant Client\n    participant CDN\n    Client->>CDN: 请求 HTML 文件\n    CDN->>Client: 直接返回缓存的 HTML 文件\n",[137,459,460,464,468,472,476],{"__ignoreMap":139},[183,461,462],{"class":185,"line":186},[183,463,189],{},[183,465,466],{"class":185,"line":192},[183,467,195],{},[183,469,470],{"class":185,"line":198},[183,471,201],{},[183,473,474],{"class":185,"line":204},[183,475,213],{},[183,477,478],{"class":185,"line":210},[183,479,480],{},"    CDN->>Client: 直接返回缓存的 HTML 文件\n",[15,482,483],{},"从而大大减少了请求的延迟，提高了页面加载速度。",[19,485,486],{"id":486},"其他",[15,488,489,490],{},"Vercel 所采用的架构并不是传统的 「源站 - CDN」 架构，而是更接近 「全球多区域存储 + CDN边缘缓存」 的架构，所以即使是回源请求，Vercel 也会尽量从离用户最近的存储节点获取内容，从而减少延迟。",[72,491,492],{},"但这并不意味着回源请求的延迟可以忽略不计，尤其是在追求极致的加载速度时，合理的缓存控制仍然是非常重要的。",[19,494,495],{"id":495},"参见",[94,497,498,505,512],{},[57,499,500],{},[46,501,504],{"href":502,"rel":503},"https://vercel.com/docs/headers/cache-control-headers",[50],"Cache-Control headers | Vercel",[57,506,507],{},[46,508,511],{"href":509,"rel":510},"https://vercel.com/docs/cdn-cache",[50],"Vercel CDN Cache | Vercel",[57,513,514],{},[46,515,518],{"href":516,"rel":517},"https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Caching",[50],"HTTP caching - HTTP | MDN",[520,521,522],"style",{},"html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html pre.shiki code .s5ixo, html code.shiki .s5ixo{--shiki-default:#383A42;--shiki-dark:#ABB2BF}html pre.shiki code .sJa8x, html code.shiki .sJa8x{--shiki-default:#E45649;--shiki-dark:#E06C75}html pre.shiki code .sDhpE, html code.shiki .sDhpE{--shiki-default:#50A14F;--shiki-dark:#98C379}html pre.shiki code .s_Sar, html code.shiki .s_Sar{--shiki-default:#0184BC;--shiki-dark:#56B6C2}",{"title":139,"searchDepth":192,"depth":192,"links":524},[525,526,530,531,532,533],{"id":21,"depth":192,"text":21},{"id":37,"depth":192,"text":37,"children":527},[528,529],{"id":41,"depth":198,"text":41},{"id":91,"depth":198,"text":92},{"id":124,"depth":192,"text":125},{"id":234,"depth":192,"text":234},{"id":486,"depth":192,"text":486},{"id":495,"depth":192,"text":495},[535,536],null,{"title":537,"path":538,"stem":539,"date":540,"lang":541,"children":-1},"小记 —— Caddy 在 Layer 4 上的流量代理实践","/2025/12/10/caddy-traffic-proxy-on-layer-4","posts/zh/caddy-traffic-proxy-on-layer-4","2025-12-10","zh-CN","/en/2025/12/23/vercel-cache-control/",1766566737217]